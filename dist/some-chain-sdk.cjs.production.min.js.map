{"version":3,"file":"some-chain-sdk.cjs.production.min.js","sources":["../src/constants/fee.ts","../src/api/APIRequester.ts","../src/api/BaseAPI.ts","../src/api/BankAPI.ts","../src/api/AuthAPI.ts","../src/api/SwapAPI.ts","../src/api/TokenAPI.ts","../src/api/TxAPI.ts","../src/constants/network.ts","../src/types/ICommon.ts","../src/constants/precision.ts","../src/constants/tick.ts","../src/utils/formatCurrencyAmount.ts","../src/utils/sort.ts","../src/utils/formatMoment.ts","../src/core/LiquidityMath.ts","../src/core/TickMath.ts","../src/msgs/BaseMsg.ts","../src/proto/google/protobuf/timestamp.ts","../src/proto/swap/tx.ts","../src/msgs/SwapMsg.ts","../src/proto/google/protobuf/any.ts","../src/proto/google/protobuf/duration.ts","../src/proto/cosmos/base/v1beta1/coin.ts","../src/proto/cosmos/gov/v1beta1/gov.ts","../src/proto/cosmos/gov/v1beta1/tx.ts","../src/msgs/GovMsg.ts","../src/proto/pool-incentives/rand_swap_reward.ts","../src/proto/pool-incentives/liquidity_reward.ts","../src/proto/pool-incentives/tx.ts","../src/msgs/PoolMsg.ts","../src/proto/tendermint/types/types.ts","../src/proto/cosmos/staking/v1beta1/staking.ts","../src/proto/tendermint/crypto/proof.ts","../src/proto/tendermint/version/types.ts","../src/proto/tendermint/crypto/keys.ts","../src/proto/tendermint/types/validator.ts","../src/proto/cosmos/staking/v1beta1/tx.ts","../src/msgs/StakingMsg.ts","../src/proto/cosmos/crypto/multisig/v1beta1/multisig.ts","../src/proto/cosmos/crypto/secp256k1/keys.ts","../src/proto/cosmos/tx/signing/v1beta1/signing.ts","../src/proto/cosmos/tx/v1beta1/tx.ts","../src/clients/TxClient.ts","../src/clients/APIClient.ts","../src/constants/date.ts","../src/core/TransactionLooper.ts","../src/constants/number.ts","../src/utils/parseToMap.ts","../src/utils/isNumberic.ts","../src/utils/decimalNumber.ts","../src/utils/deepCopy.ts","../src/utils/mathUtil.ts","../src/utils/encrypt.ts","../src/utils/toPercentFee.ts","../src/utils/getPoolAddress.ts","../src/types/IWallet.ts","../src/utils/crypto.ts","../src/utils/toPercent.ts","../src/utils/formatPrice.ts"],"sourcesContent":["export enum Fee_Amount {\n  LOWEST = 100,\n  LOW = 500,\n  MEDIUM = 3000,\n  HIGH = 10000,\n}\n\nexport const FEE_AMOUNT_DETAIL: Record<\n  Fee_Amount,\n  { label: string; value: Fee_Amount; description: string }\n> = {\n  [Fee_Amount.LOWEST]: {\n    label: \"0.01\",\n    value: Fee_Amount.LOWEST,\n    description: \"Best for very stable pairs.\",\n  },\n  [Fee_Amount.LOW]: {\n    label: \"0.05\",\n    value: Fee_Amount.LOW,\n    description: \"Best for stable pairs.\",\n  },\n  [Fee_Amount.MEDIUM]: {\n    label: \"0.3\",\n    value: Fee_Amount.MEDIUM,\n    description: \"Best for most pairs.\",\n  },\n  [Fee_Amount.HIGH]: {\n    label: \"1\",\n    value: Fee_Amount.HIGH,\n    description: \"Best for exotic pairs.\",\n  },\n};\n","import Axios, { AxiosInstance } from \"axios\";\nimport { OrderBy } from \"../proto/cosmos/tx/v1beta1/service\";\n\nexport type APIParams = Record<string, string | number | null | undefined | boolean | Array<string>>;\n\nexport interface PaginationOptions {\n  \"pagination.limit\": string;\n  \"pagination.offset\": string;\n  \"pagination.key\": string;\n  \"pagination.count_total\": \"true\" | \"false\";\n  \"pagination.reverse\": \"true\" | \"false\";\n  order_by: keyof typeof OrderBy;\n}\n\nexport interface Pagination {\n  next_key: string | null;\n  total: number;\n}\n\nexport class APIRequester {\n  private axios: AxiosInstance;\n\n  constructor(baseURL: string) {\n    this.axios = Axios.create({\n      baseURL,\n      headers: {\n        Accept: \"application/json\",\n      },\n      timeout: 60000,\n    });\n  }\n\n  public async get<T>(\n    endpoint: string,\n    params: URLSearchParams | APIParams = {}\n  ): Promise<T> {\n    return this.axios.get(endpoint, { params }).then((d) => d.data);\n  }\n\n  public async post<T>(endpoint: string, data?: APIParams): Promise<T> {\n    return this.axios.post(endpoint, data).then((d) => d.data);\n  }\n}\n","import { APIRequester } from \"./APIRequester\";\n\nexport abstract class BaseAPI {\n  constructor(protected request: APIRequester) {}\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { IToken } from \"../types\";\n\nexport interface IResBalances {\n  balance: {\n    denom: string;\n    amount: string;\n  };\n}\n\nexport class BankAPI extends BaseAPI {\n  public async apiTokenBalance(\n    token: IToken,\n    accountAddress: string\n  ): Promise<IResBalances> {\n    return this.request.get<IResBalances>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}/by_denom`,\n      {\n        denom: token.base,\n      }\n    );\n  }\n\n  public async apiAccountBalance(\n    accountAddress: string\n  ): Promise<IResBalances> {\n    return this.request.get<IResBalances>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}`\n    );\n  }\n\n  public async apiDenomMetadata(\n    denom: string\n  ): Promise<IToken> {\n    return this.request.get<IToken>(\n      `/cosmos/bank/v1beta1/denom_metadata/${denom}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\n\nexport interface IResAccountInfo {\n  account: {\n    \"@type\": string;\n    base_account: {\n      address: string;\n      pub_key: {\n        \"@type\": string;\n        key: string;\n      };\n      account_number: string;\n      sequence: string;\n    };\n    code_hash: string;\n  };\n}\n\nexport class AuthAPI extends BaseAPI {\n  public async apiAccountInfo(\n    accountAddress: string\n  ): Promise<IResAccountInfo> {\n    return this.request.get<IResAccountInfo>(\n      `/cosmos/auth/v1beta1/accounts/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { ILiquidityPosition, IPool, IPoolPrice } from \"../types\";\nimport qs from 'qs';\n\nexport interface IResPoolInfo {\n  pool: IPool;\n  pool_slot0: IPoolPrice;\n}\n\nexport interface IResPoolMetadataNew {\n  [pool: string]: IPool;\n}\n\nexport interface IFarmV3 {\n  address: string;\n}\n\nexport interface IResFarmList {\n  core_pools: Array<IFarmV3>;\n  pagination: {\n    next_key: null | string;\n    total: string;\n  };\n}\n\nexport interface IResLiquidityPositionList {\n  liquidity_positions: Array<ILiquidityPosition>;\n}\n\nexport class SwapAPI extends BaseAPI {\n  /**\n   * find pool list by address array\n   * @param addresses\n   */\n  public async apiPoolListByAddresses(\n    addresses: Array<string>\n  ): Promise<{ pool_slot0_aggregations: Array<IResPoolInfo> }> {\n    const params = qs.stringify({ addresses }, { indices: false });\n    return this.request.get<{ pool_slot0_aggregations: Array<IResPoolInfo> }>(\n      `/metaos-labs/metaos/swap/pool_slot0_aggregations?${params}`,\n    );\n  }\n\n  public async apiPoolMetadataByAddress(\n    address: string\n  ): Promise<IResPoolMetadataNew> {\n    return this.request.get<IResPoolMetadataNew>(\n      `/metaos-labs/metaos/swap/pools/${address}`\n    );\n  }\n\n  public async apiPoolMetadataPriceByAddress(\n    address: string\n  ): Promise<{ pool_slot0: IPoolPrice }> {\n    return this.request.get<{ pool_slot0: IPoolPrice }>(\n      `/metaos-labs/metaos/swap/pools/${address}/slot0`\n    );\n  }\n\n  public async apiLiquidityPositionById(\n    tokenId: string\n  ): Promise<{ liquidity_position: ILiquidityPosition }> {\n    return this.request.get<{ liquidity_position: ILiquidityPosition }>(\n      `/metaos-labs/metaos/swap/liquidity_positions/${tokenId}`\n    );\n  }\n\n  public async apiLiquidityRewardsByIds(\n    tokenIds: Array<string>\n  ): Promise<{ liquidity_positions: Array<ILiquidityPosition> }> {\n    const params = qs.stringify({ tokenIds }, { indices: false });\n    return this.request.get<{ liquidity_positions: Array<ILiquidityPosition> }>(\n      `/metaos-labs/metaos/swap/liquidity_position_by_ids?${params}`\n    );\n  }\n\n  public async apiTickImagePath(tokenId: string): Promise<{ uri: string }> {\n    return this.request.get<{ uri: string }>(\n      `/metaos-labs/metaos/swap/liquidity_positions/${tokenId}/token_uri`\n    );\n  }\n\n  public async apiActiveFarmList(): Promise<IResFarmList> {\n    return this.request.get<IResFarmList>(\n      `/metaos-labs/metaos/swap/core_pools`\n    );\n  }\n\n  public async apiLiquidityPositionList(\n    accountAddress: string,\n    skip_zero_liquidity: boolean\n  ): Promise<IResLiquidityPositionList> {\n    return this.request.get<IResLiquidityPositionList>(\n      `/metaos-labs/metaos/swap/liquidity_positions_owner/${accountAddress}`,\n      {\n        skip_zero_liquidity\n      }\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport {DenomUnit, Metadata} from \"../proto/cosmos/bank/v1beta1/bank\";\nimport { QueryGetMetadataResponse } from \"../proto/token/query\";\nimport {MetadataExt} from \"../proto/token/token\";\n\nexport interface IMetadata extends Metadata{\n  denom_units: DenomUnit[];\n}\n\nexport interface IMetadataExt extends MetadataExt{\n  max_supply: string;\n}\n\ninterface QueryMetadataResponse {\n  metadata?: IMetadata;\n  metadata_ext?: IMetadataExt;\n  supply: string;\n}\n\nexport class TokenAPI extends BaseAPI {\n\n  public async apiTokenMetadatasByDenom(\n    denom: string\n  ): Promise<QueryMetadataResponse> {\n    return this.request.get<QueryMetadataResponse>(\n      `/metaos-labs/metaos/token/metadatas/by_denom`,\n      {\n        denom\n      }\n    );\n  }\n\n  public async apiTokenMetadatas(): Promise<Array<Metadata>> {\n    return this.request.get<Array<Metadata>>(\n      `/metaos-labs/metaos/token/metadatas`\n    );\n  }\n\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { TxResponse } from \"../proto/cosmos/base/abci/v1beta1/abci\";\nimport {\n  BroadcastMode,\n  BroadcastTxRequest,\n  BroadcastTxResponse,\n} from \"../proto/cosmos/tx/v1beta1/service\";\n\nexport interface IResEstimateGas {\n  gas_info: {\n    gas_wanted: string;\n    gas_used: string;\n  };\n  result: {\n    data: string;\n    log: string;\n    events: { type: string; attributes: { key: string; value: string }[] }[];\n  };\n}\n\nexport class TxAPI extends BaseAPI {\n  public async estimateGas(\n    txBytes: string,\n  ): Promise<IResEstimateGas> {\n    return this.request.post<IResEstimateGas>(`/cosmos/tx/v1beta1/simulate`, {\n      tx_bytes: txBytes\n    });\n  }\n\n  private async _broadcast<T>(\n    tx: BroadcastTxRequest,\n    mode: keyof typeof BroadcastMode\n  ): Promise<T> {\n    return this.request.post<any>(`/cosmos/tx/v1beta1/txs`);\n  }\n\n  public async broadcast(tx: BroadcastTxRequest): Promise<BroadcastTxResponse> {\n    return this._broadcast<BroadcastTxResponse>(tx, \"BROADCAST_MODE_BLOCK\");\n  }\n\n  public async txInfo(txHash: string): Promise<TxResponse> {\n    return this.request.get<TxResponse>(`/cosmos/tx/v1beta1/txs/${txHash}`);\n  }\n}\n","export enum Chain_Id {\n  Mainnet = 'metaos_99237-1',\n  Testnet = 'metaos_99237-2',\n  Devnet = 'metaos_99237-3'\n}\n\nexport const CHAIN_NAMES = {\n  [Chain_Id.Mainnet]: 'Mainnet',\n  [Chain_Id.Testnet]: 'Testnet',\n  [Chain_Id.Devnet]: 'Devnet',\n}\n\nexport const NETWORK_DETAILS = {\n  [Chain_Id.Mainnet]: {\n    chainId: 'metaos_99237-1',\n    chainName: 'Metaos Mainnet',\n    nativeCurrency: {\n      base: 'umtos',\n      name: 'MetaOS',\n      symbol: 'MTOS',\n      display_exponent: 18,\n      logo_uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png',\n    },\n    nodeUrl: 'https://node.metaos.im',\n    rpcUrl: 'https://tendermint.metaos.im',\n    blockExplorerUrl: 'https://scan.metaos.im',\n  },\n  [Chain_Id.Testnet]: {\n    chainId: 'metaos_99237-2',\n    chainName: 'Metaos Mainnet',\n    nativeCurrency: {\n      base: 'umtos',\n      name: 'MetaOS',\n      symbol: 'MTOS',\n      display_exponent: 18,\n      logo_uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png',\n    },\n    nodeUrl: 'https://node.metaos.im',\n    rpcUrl: 'https://tendermint.metaos.im',\n    blockExplorerUrl: 'https://scan.metaos.im',\n  },\n  [Chain_Id.Devnet]: {\n    chainId: 'metaos_99237-3',\n    chainName: 'Metaos Mainnet',\n    nativeCurrency: {\n      base: 'umtos',\n      name: 'MetaOS',\n      symbol: 'MTOS',\n      display_exponent: 18,\n      logo_uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png',\n    },\n    nodeUrl: 'https://node.metaos.im',\n    rpcUrl: 'https://tendermint.metaos.im',\n    blockExplorerUrl: 'https://scan.metaos.im',\n  },\n}\n","import { IToken } from \"./IToken\";\nimport { Fee_Amount } from \"../constants\";\n\nexport interface ITickProcessed {\n  tick: number;\n  liquidityActive: string;\n  liquidityNet: string;\n  price0: string;\n}\n\nexport interface ITickData {\n  tick_idx: number;\n  liquidity_gross: string;\n  liquidity_net: string;\n  price0: string;\n  price1: string;\n}\n\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\nexport enum Bound {\n  LOWER = \"LOWER\",\n  UPPER = \"UPPER\",\n}\n\nexport interface IFeeItem {\n  label: string;\n  value: Fee_Amount;\n  description: string;\n}\n\nexport enum Tip_Level {\n  Info = \"info\",\n  Warning = \"warning\",\n  Error = \"error\",\n}\n\nexport enum Swap_Direction {\n  In = \"exactIn\",\n  Out = \"exactOut\",\n}\n\nexport enum Transaction_Status {\n  Wallet = \"wallet\",\n  Pending = \"pending\",\n  Complete = \"complete\",\n  Success = \"success\",\n  Error = \"error\",\n  Reject = \"reject\",\n}\n\nexport interface ILiquidityPosition {\n  token_id: string;\n  address: string;\n  liquidity: string;\n  fee_growth_inside0_last: string;\n  fee_growth_inside1_last: string;\n  tokens_owed0: string;\n  tokens_owed1: string;\n  tick_lower: number;\n  tick_upper: number;\n  reward_growth_inside_lasts: Array<string>;\n  reward_oweds: Array<string>;\n}\n\nexport interface IPool {\n  address: string;\n  denom0: string;\n  denom1: string;\n  decimal0: number;\n  decimal1: number;\n  fee: number;\n  tick_spacing: number;\n  max_liquidity_per_tick: string;\n}\n\nexport interface IV3RewardConfig {\n  denom: string;\n  mintable: boolean;\n  operator: string;\n  reward_growth_global: string;\n  reward_per_second: string;\n  vault: string;\n  token?: IToken;\n  reward_per_day?: string;\n}\n\nexport interface IV3Reward extends IV3RewardConfig {\n  amount: string;\n  token?: IToken;\n}\n\nexport interface IPoolPrice {\n  address: string;\n  tick: number;\n  sqrt_price: string;\n  liquidity: string;\n  fee_growth_global0: string;\n  fee_growth_global1: string;\n  fee_protocol_owed0: string;\n  fee_protocol_owed1: string;\n  observation_index: number;\n  observation_cardinality: number;\n  observation_cardinality_next: number;\n  reward_configs: Array<IV3RewardConfig>;\n  reward_update_time_last: string;\n}\n\nexport interface IPoolMetaData extends IPool, IPoolPrice {}\n","export const DEFAULT_USER_PRECISION = 6;\n\nexport const DEFAULT_PRECISION = 18;\n\nexport const MAX_PRECISION = 28;\n\nexport const REG_NUMBER = new RegExp(\n  \"^[1-9]+[0-9]*(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n\nexport const REG_DECIMAL_SIMPLE = /^\\d*(\\.\\d*)?$/;\n\nexport const REG_DECIMAL = new RegExp(\n  \"^0(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n","export const TICK_SPACINGS = {\n  100: 1,\n  500: 10,\n  3000: 60,\n  10000: 200,\n};\n\nexport const BASE_UNIT_TICK = 1.0001;\n","import Decimal from \"decimal.js\";\nimport { Decimal as CosmosDecimal } from \"@cosmjs/math\";\nimport {\n  DEFAULT_PRECISION,\n  DEFAULT_USER_PRECISION,\n  MAX_PRECISION,\n} from \"../constants\";\n\nexport function toDecimalPlaces(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION\n) {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_UP)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountString(\n  value: Decimal.Value | undefined = \"\",\n  precision: number = DEFAULT_USER_PRECISION,\n  roundingMode: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  try {\n    return new Decimal(value)\n      .toSignificantDigits(precision, roundingMode)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountFloor(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n): string {\n  return toAmountString(value, precision, Decimal.ROUND_DOWN);\n}\n\nexport function toAmountCeil(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n) {\n  return toAmountString(value, precision, Decimal.ROUND_UP);\n}\n\nexport function toAmountFee(\n  value: string | number,\n  precision: number = DEFAULT_PRECISION\n): string {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_DOWN)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function isEmptyAmount(\n  value: Decimal.Value,\n  precision: number = MAX_PRECISION\n): boolean {\n  const _value = new Decimal(value).mul(Math.pow(10, precision)).floor();\n  return _value.isZero();\n}\n\nexport function toExactAmount(\n  value: string,\n  precision = MAX_PRECISION\n): string {\n  try {\n    return CosmosDecimal.fromUserInput(value, precision).toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport const formatNumber = (\n  value: Decimal.Value,\n  seperator: number = 3,\n  fixed: number = 2\n) => {\n  return `${new Decimal(value)\n    .div(new Decimal(10).pow(seperator))\n    .toFixed(fixed)}k`;\n};\n","import { IToken } from \"../types\";\n\nexport function sortsBefore(baseToken: IToken, quoteToken: IToken) {\n  return baseToken.base.toLowerCase() < quoteToken.base.toLowerCase();\n}\n","import moment from \"moment\";\n\nmoment.locale(\"en-ca\");\n\nexport function formatMoment(value: string, pattern = \"YYYY/MM/DD HH:mm:ss\") {\n  return moment(+value).format(pattern);\n}\n\nexport function formatUnixMoment(value: string, pattern = \"MM/DD HH:mm:ss\") {\n  return moment(+value * 1000).format(pattern);\n}\n\nexport const formatTime = (time: string) => {\n  return moment(time).format(\"YYYY-MM-DD HH:mm:ss\");\n};\n\nexport const formatDiffTime = (time: string) => {\n  return moment(time).fromNow();\n};\n","import { IToken } from \"../types\";\nimport { toDecimalPlaces } from \"../utils\";\nimport Decimal from \"decimal.js\";\n\nexport class LiquidityMath {\n  private static getRightSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(leftRangeValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return numerator.div(denominator);\n  }\n\n  private static getLeftSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(rightRangeValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return numerator.div(denominator);\n  }\n\n  public static getLiquidityFromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n    if (pc.lessThan(leftRangeValue)) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    } else if (pc.greaterThan(rightRangeValue)) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    }\n    const deltaX = new Decimal(amount0);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(priceValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return deltaX.div(denominator);\n  }\n\n  private static _getDiverForDeltaX(\n    lower: Decimal.Value,\n    upper: Decimal.Value\n  ): Decimal {\n    const _value1 = new Decimal(1).div(Decimal.sqrt(lower));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(upper));\n    return Decimal.sub(_value1, _value2);\n  }\n\n  private static _getDiverForDeltaY(\n    lower: Decimal.Value,\n    upper: Decimal.Value\n  ) {\n    return Decimal.sub(Decimal.sqrt(upper), Decimal.sqrt(lower));\n  }\n\n  public static getLiquidityFromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n\n    if (pc.lessThan(leftRangeValue)) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    } else if (pc.greaterThan(rightRangeValue)) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    }\n\n    const deltaY = new Decimal(amount1);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(priceValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return deltaY.div(denominator);\n  }\n\n  public static getAmount1FromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string,\n    token0: IToken\n  ): string {\n    const liquidity = this.getLiquidityFromAmount0(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount0\n    );\n    console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmount0FromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string,\n    token1: IToken\n  ): string {\n    const liquidity = this.getLiquidityFromAmount1(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount1\n    );\n\n    console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmountByLiquidity(\n    leftRangeValue: Decimal.Value,\n    rightRangeValue: Decimal.Value,\n    priceValue: Decimal.Value,\n    liquidity: string,\n    token0: IToken,\n    token1: IToken\n  ): { amount0: Decimal.Value; amount1: Decimal.Value } {\n    const pc = new Decimal(priceValue);\n\n    const _value1 = new Decimal(liquidity);\n\n    if (pc.lessThan(leftRangeValue)) {\n      const _value2 = this._getDiverForDeltaX(leftRangeValue, rightRangeValue);\n      return {\n        amount0: _value1.mul(_value2),\n        amount1: \"0\",\n      };\n    } else if (pc.greaterThan(rightRangeValue)) {\n      const _value2 = this._getDiverForDeltaY(leftRangeValue, rightRangeValue);\n      return {\n        amount0: \"0\",\n        amount1: _value1.mul(_value2),\n      };\n    }\n    const deltaXDiver = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    const deltaYDiver = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return {\n      amount0: _value1.mul(deltaXDiver),\n      amount1: _value1.mul(deltaYDiver)\n    };\n  }\n}\n","import invariant from \"tiny-invariant\";\nimport Decimal from \"decimal.js\";\nimport { Fee_Amount, TICK_SPACINGS, BASE_UNIT_TICK } from \"../constants\";\nimport { IToken } from \"../types\";\nimport { sortsBefore, toAmountString } from \"../utils\";\n\nexport class TickMath {\n  public static INVALID_TICK = -99999999;\n\n  public static MIN_TICK = -887272;\n\n  public static MIN_TICK_VALUE = \"0\";\n\n  public static MAX_TICK: number = -TickMath.MIN_TICK;\n\n  public static MAX_TICK_VALUE = \"∞\";\n\n  public static nearestUsableTick = (\n    tick: number,\n    tickSpacing: number\n  ): number => {\n    const rounded = Math.round(tick / tickSpacing) * tickSpacing;\n    if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;\n    else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;\n    else return rounded;\n  };\n\n  private static priceToClosestTick(price: string): number {\n    const numerator = Decimal.log2(Decimal.sqrt(price));\n    const denominator = Decimal.log2(Decimal.sqrt(BASE_UNIT_TICK));\n    return numerator.div(denominator).toNumber();\n  }\n\n  /**\n   * Compute nearest tick of price for input\n   * @param feeAmount\n   * @param value\n   */\n  public static getNearestTickByPrice(\n    feeAmount: Fee_Amount,\n    value: string\n  ): number {\n    const _value = value.trim();\n    if (_value === \"\") {\n      return this.INVALID_TICK;\n    }\n    if (value === this.MIN_TICK_VALUE) {\n      return this.MIN_TICK;\n    }\n    if (value === this.MAX_TICK_VALUE) {\n      return this.MAX_TICK;\n    }\n    const tick: number = this.priceToClosestTick(value);\n    // console.log(`[priceToClosestTick]: ` + tick);\n    const result = this.nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n    // console.log(`[nearestUsableTick]: ` + result);\n    return result;\n  }\n\n  public static getFormattedPriceByTick(\n    tick: Decimal.Value,\n    fee: Fee_Amount\n  ): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    if (this.isLowestTick(tick, fee)) {\n      return this.MIN_TICK_VALUE;\n    }\n    if (this.isHighestTick(tick, fee)) {\n      return this.MAX_TICK_VALUE;\n    }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getPriceByTick(tick: Decimal.Value): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    // if (this.isLowestTick(tick, fee)) {\n    //   return this.MIN_TICK_VALUE;\n    // }\n    // if (this.isHighestTick(tick, fee)) {\n    //   return this.MAX_TICK_VALUE;\n    // }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getNearestPriceByInput(\n    feeAmount: Fee_Amount,\n    price: string\n  ): string {\n    // console.log('INPUT price: ' + price);\n    const nearestTick = this.getNearestTickByPrice(feeAmount, price);\n    const result = this.getPriceByTick(nearestTick);\n    // console.log('getPriceByTick: ' + result);\n    // console.log('==========');\n    return toAmountString(result);\n  }\n\n  public static getPriceBySqrtPrice(sqrtPrice: string): string {\n    if (!sqrtPrice) {\n      return \"\";\n    }\n    if (sqrtPrice === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(sqrtPrice).pow(2).toString();\n  }\n\n  public static getSqrtPriceByPrice(price: string): string {\n    if (price === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(price).sqrt().toString();\n  }\n\n  public static getBaseTickRange(\n    fromToken: IToken,\n    toToken: IToken,\n    fee: Fee_Amount,\n    leftRange: string,\n    rightRange: string\n  ): { tickLower: number; tickUpper: number } {\n    let tickLower: number;\n    let tickUpper: number;\n    if (sortsBefore(fromToken, toToken)) {\n      tickLower =\n        leftRange === TickMath.MIN_TICK_VALUE\n          ? TickMath.getNearestLowestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, leftRange);\n      tickUpper =\n        rightRange === TickMath.MAX_TICK_VALUE\n          ? TickMath.getNearestHighestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, rightRange);\n    } else {\n      if (leftRange === TickMath.MIN_TICK_VALUE) {\n        tickUpper = TickMath.getNearestHighestTick(fee);\n      } else {\n        tickUpper = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(leftRange).toString()\n        );\n      }\n      if (rightRange === TickMath.MAX_TICK_VALUE) {\n        tickLower = TickMath.getNearestLowestTick(fee);\n      } else {\n        tickLower = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(rightRange).toString()\n        );\n      }\n    }\n    console.log(\"tickLower: \" + tickLower);\n    console.log(\"tickUpper: \" + tickUpper);\n    return {\n      tickLower,\n      tickUpper,\n    };\n  }\n\n  public static getNearestLowestTick(fee: Fee_Amount): number {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestLowestTick: ' + tickLower);\n    return tickLower;\n  }\n\n  public static getNearestHighestTick(fee: Fee_Amount): number {\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestHighestTick: ' + tickUpper);\n    return tickUpper;\n  }\n\n  public static getNearestPricesByFullTick(fee: Fee_Amount): {\n    lowestPrice: string;\n    highestPrice: string;\n  } {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    const lowestPrice = this.getPriceByTick(tickLower);\n    const highestPrice = this.getPriceByTick(tickUpper);\n    return {\n      lowestPrice,\n      highestPrice,\n    };\n  }\n\n  public static isHighestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const highestTick = this.getNearestHighestTick(fee);\n    return tick >= highestTick;\n  }\n\n  public static isLowestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const lowestTick = this.getNearestLowestTick(fee);\n    return tick <= lowestTick;\n  }\n}\n","import { EncodeObject, TxBodyEncodeObject } from \"@cosmjs/proto-signing\";\n\nexport abstract class BaseMsg {\n  constructor() {}\n  public abstract generateMessage(): EncodeObject;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n * ) to obtain a formatter capable of generating timestamps in this format.\n */\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: Long;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseTimestamp(): Timestamp {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Timestamp = {\n  encode(\n    message: Timestamp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Timestamp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Timestamp {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Timestamp): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(\n    object: I\n  ): Timestamp {\n    const message = createBaseTimestamp();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"metaoslabs.metaos.swap\";\n\nexport interface MsgCreatePool {\n  creator: string;\n  /** the denom of denom0 in the pool */\n  denom0: string;\n  /** the denom of denom1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the initial square root price of the poo */\n  sqrtPrice: string;\n}\n\nexport interface MsgCreatePoolResponse {}\n\nexport interface MsgCreatePosition {\n  creator: string;\n  /** the denom of token0 in the pool */\n  denom0: string;\n  /** the denom of token1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the price lower bound of the position */\n  tickLower: number;\n  /** the price higher bound of the position */\n  tickUpper: number;\n  /** the desired amount of denom0 in the position */\n  amount0Desired: string;\n  /** the desired amount of denom1 in the position */\n  amount1Desired: string;\n  /** the minimum amount that denom0 needs to add when slippage occurs */\n  amount0Min: string;\n  /** the minimum amount that denom1 needs to add when slippage occurs */\n  amount1Min: string;\n  /** the minted NFT holder address */\n  recipient: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgCreatePositionResponse {}\n\nexport interface MsgIncreaseLiquidity {\n  /** the message creator, with tokens paid for the message */\n  creator: string;\n  /** then id of the NFT for which liquidity is being increased */\n  tokenId: string;\n  /** the desired amount of denom0 to be spent */\n  amount0Desired: string;\n  /** the desired amount of denom1 to be spent */\n  amount1Desired: string;\n  /** the minimum amount of denom0 to spend, which serves as a slippage check */\n  amount0Min: string;\n  /** the minimum amount of denom1 to spend, which serves as a slippage check */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgIncreaseLiquidityResponse {}\n\nexport interface MsgDecreaseLiquidity {\n  creator: string;\n  /** then id of the NFT for which liquidity is being decreased */\n  tokenId: string;\n  /** the amount by which liquidity will be decreased */\n  liquidity: string;\n  /** the minimum amount of denom0 that should be accounted for the burned liquidity */\n  amount0Min: string;\n  /** the minimum amount of denom1 that should be accounted for the burned liquidity */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgDecreaseLiquidityResponse {}\n\nexport interface MsgCollect {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** the maximum amount of denom0 to collect */\n  amount0Max: string;\n  /** the maximum amount of denom1 to collect */\n  amount1Max: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectResponse {}\n\nexport interface MsgSwapExactIn {\n  creator: string;\n  recipient: string;\n  amountIn: string;\n  amountOutMin: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactInResponse {}\n\nexport interface MsgSwapExactOut {\n  creator: string;\n  recipient: string;\n  amountOut: string;\n  amountInMax: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactOutResponse {}\n\nexport interface MsgCollectReward {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectRewardResponse {}\n\nexport interface MsgCollectFeeProtocol {\n  creator: string;\n  /** the pool address */\n  address: string;\n}\n\nexport interface MsgCollectFeeProtocolResponse {}\n\nexport interface MsgGovCorePool {\n  creator: string;\n  address: string;\n  action: string;\n  triggerTime?: Date;\n}\n\nexport interface MsgGovCorePoolResponse {}\n\nfunction createBaseMsgCreatePool(): MsgCreatePool {\n  return { creator: \"\", denom0: \"\", denom1: \"\", fee: 0, sqrtPrice: \"\" };\n}\n\nexport const MsgCreatePool = {\n  encode(\n    message: MsgCreatePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.sqrtPrice !== \"\") {\n      writer.uint32(42).string(message.sqrtPrice);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.sqrtPrice = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      sqrtPrice: isSet(object.sqrtPrice) ? String(object.sqrtPrice) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCreatePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.sqrtPrice !== undefined && (obj.sqrtPrice = message.sqrtPrice);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePool>, I>>(\n    object: I\n  ): MsgCreatePool {\n    const message = createBaseMsgCreatePool();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.sqrtPrice = object.sqrtPrice ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePoolResponse(): MsgCreatePoolResponse {\n  return {};\n}\n\nexport const MsgCreatePoolResponse = {\n  encode(\n    _: MsgCreatePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePoolResponse>, I>>(\n    _: I\n  ): MsgCreatePoolResponse {\n    const message = createBaseMsgCreatePoolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePosition(): MsgCreatePosition {\n  return {\n    creator: \"\",\n    denom0: \"\",\n    denom1: \"\",\n    fee: 0,\n    tickLower: 0,\n    tickUpper: 0,\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    recipient: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgCreatePosition = {\n  encode(\n    message: MsgCreatePosition,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.tickLower !== 0) {\n      writer.uint32(40).int32(message.tickLower);\n    }\n    if (message.tickUpper !== 0) {\n      writer.uint32(48).int32(message.tickUpper);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(58).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(66).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(74).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(82).string(message.amount1Min);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(90).string(message.recipient);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(98).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePosition {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePosition();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.tickLower = reader.int32();\n          break;\n        case 6:\n          message.tickUpper = reader.int32();\n          break;\n        case 7:\n          message.amount0Desired = reader.string();\n          break;\n        case 8:\n          message.amount1Desired = reader.string();\n          break;\n        case 9:\n          message.amount0Min = reader.string();\n          break;\n        case 10:\n          message.amount1Min = reader.string();\n          break;\n        case 11:\n          message.recipient = reader.string();\n          break;\n        case 12:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePosition {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      tickLower: isSet(object.tickLower) ? Number(object.tickLower) : 0,\n      tickUpper: isSet(object.tickUpper) ? Number(object.tickUpper) : 0,\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreatePosition): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.tickLower !== undefined &&\n      (obj.tickLower = Math.round(message.tickLower));\n    message.tickUpper !== undefined &&\n      (obj.tickUpper = Math.round(message.tickUpper));\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePosition>, I>>(\n    object: I\n  ): MsgCreatePosition {\n    const message = createBaseMsgCreatePosition();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.tickLower = object.tickLower ?? 0;\n    message.tickUpper = object.tickUpper ?? 0;\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePositionResponse(): MsgCreatePositionResponse {\n  return {};\n}\n\nexport const MsgCreatePositionResponse = {\n  encode(\n    _: MsgCreatePositionResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePositionResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePositionResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePositionResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePositionResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePositionResponse>, I>>(\n    _: I\n  ): MsgCreatePositionResponse {\n    const message = createBaseMsgCreatePositionResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidity(): MsgIncreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgIncreaseLiquidity = {\n  encode(\n    message: MsgIncreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(26).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(34).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(42).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(50).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.amount0Desired = reader.string();\n          break;\n        case 4:\n          message.amount1Desired = reader.string();\n          break;\n        case 5:\n          message.amount0Min = reader.string();\n          break;\n        case 6:\n          message.amount1Min = reader.string();\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgIncreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgIncreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidity>, I>>(\n    object: I\n  ): MsgIncreaseLiquidity {\n    const message = createBaseMsgIncreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidityResponse(): MsgIncreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgIncreaseLiquidityResponse = {\n  encode(\n    _: MsgIncreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgIncreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgIncreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgIncreaseLiquidityResponse {\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidity(): MsgDecreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    liquidity: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgDecreaseLiquidity = {\n  encode(\n    message: MsgDecreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.liquidity !== \"\") {\n      writer.uint32(26).string(message.liquidity);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(34).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(42).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.liquidity = reader.string();\n          break;\n        case 4:\n          message.amount0Min = reader.string();\n          break;\n        case 5:\n          message.amount1Min = reader.string();\n          break;\n        case 6:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDecreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      liquidity: isSet(object.liquidity) ? String(object.liquidity) : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgDecreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.liquidity !== undefined && (obj.liquidity = message.liquidity);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidity>, I>>(\n    object: I\n  ): MsgDecreaseLiquidity {\n    const message = createBaseMsgDecreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.liquidity = object.liquidity ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidityResponse(): MsgDecreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgDecreaseLiquidityResponse = {\n  encode(\n    _: MsgDecreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDecreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDecreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgDecreaseLiquidityResponse {\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollect(): MsgCollect {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    recipient: \"\",\n    amount0Max: \"\",\n    amount1Max: \"\",\n    collectOnly: false,\n  };\n}\n\nexport const MsgCollect = {\n  encode(\n    message: MsgCollect,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.amount0Max !== \"\") {\n      writer.uint32(34).string(message.amount0Max);\n    }\n    if (message.amount1Max !== \"\") {\n      writer.uint32(42).string(message.amount1Max);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(48).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollect {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollect();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.amount0Max = reader.string();\n          break;\n        case 5:\n          message.amount1Max = reader.string();\n          break;\n        case 6:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollect {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amount0Max: isSet(object.amount0Max) ? String(object.amount0Max) : \"\",\n      amount1Max: isSet(object.amount1Max) ? String(object.amount1Max) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollect): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amount0Max !== undefined && (obj.amount0Max = message.amount0Max);\n    message.amount1Max !== undefined && (obj.amount1Max = message.amount1Max);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollect>, I>>(\n    object: I\n  ): MsgCollect {\n    const message = createBaseMsgCollect();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amount0Max = object.amount0Max ?? \"\";\n    message.amount1Max = object.amount1Max ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectResponse(): MsgCollectResponse {\n  return {};\n}\n\nexport const MsgCollectResponse = {\n  encode(\n    _: MsgCollectResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectResponse>, I>>(\n    _: I\n  ): MsgCollectResponse {\n    const message = createBaseMsgCollectResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactIn(): MsgSwapExactIn {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountIn: \"\",\n    amountOutMin: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactIn = {\n  encode(\n    message: MsgSwapExactIn,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountIn !== \"\") {\n      writer.uint32(26).string(message.amountIn);\n    }\n    if (message.amountOutMin !== \"\") {\n      writer.uint32(34).string(message.amountOutMin);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactIn {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactIn();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountIn = reader.string();\n          break;\n        case 4:\n          message.amountOutMin = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactIn {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountIn: isSet(object.amountIn) ? String(object.amountIn) : \"\",\n      amountOutMin: isSet(object.amountOutMin)\n        ? String(object.amountOutMin)\n        : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactIn): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountIn !== undefined && (obj.amountIn = message.amountIn);\n    message.amountOutMin !== undefined &&\n      (obj.amountOutMin = message.amountOutMin);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactIn>, I>>(\n    object: I\n  ): MsgSwapExactIn {\n    const message = createBaseMsgSwapExactIn();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountIn = object.amountIn ?? \"\";\n    message.amountOutMin = object.amountOutMin ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactInResponse(): MsgSwapExactInResponse {\n  return {};\n}\n\nexport const MsgSwapExactInResponse = {\n  encode(\n    _: MsgSwapExactInResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactInResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactInResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactInResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactInResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactInResponse>, I>>(\n    _: I\n  ): MsgSwapExactInResponse {\n    const message = createBaseMsgSwapExactInResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOut(): MsgSwapExactOut {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountOut: \"\",\n    amountInMax: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactOut = {\n  encode(\n    message: MsgSwapExactOut,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountOut !== \"\") {\n      writer.uint32(26).string(message.amountOut);\n    }\n    if (message.amountInMax !== \"\") {\n      writer.uint32(34).string(message.amountInMax);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactOut {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOut();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountOut = reader.string();\n          break;\n        case 4:\n          message.amountInMax = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactOut {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountOut: isSet(object.amountOut) ? String(object.amountOut) : \"\",\n      amountInMax: isSet(object.amountInMax) ? String(object.amountInMax) : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactOut): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountOut !== undefined && (obj.amountOut = message.amountOut);\n    message.amountInMax !== undefined &&\n      (obj.amountInMax = message.amountInMax);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOut>, I>>(\n    object: I\n  ): MsgSwapExactOut {\n    const message = createBaseMsgSwapExactOut();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountOut = object.amountOut ?? \"\";\n    message.amountInMax = object.amountInMax ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOutResponse(): MsgSwapExactOutResponse {\n  return {};\n}\n\nexport const MsgSwapExactOutResponse = {\n  encode(\n    _: MsgSwapExactOutResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactOutResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOutResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactOutResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactOutResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOutResponse>, I>>(\n    _: I\n  ): MsgSwapExactOutResponse {\n    const message = createBaseMsgSwapExactOutResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectReward(): MsgCollectReward {\n  return { creator: \"\", tokenId: \"\", recipient: \"\", collectOnly: false };\n}\n\nexport const MsgCollectReward = {\n  encode(\n    message: MsgCollectReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(32).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollectReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectReward>, I>>(\n    object: I\n  ): MsgCollectReward {\n    const message = createBaseMsgCollectReward();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRewardResponse(): MsgCollectRewardResponse {\n  return {};\n}\n\nexport const MsgCollectRewardResponse = {\n  encode(\n    _: MsgCollectRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectRewardResponse>, I>>(\n    _: I\n  ): MsgCollectRewardResponse {\n    const message = createBaseMsgCollectRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocol(): MsgCollectFeeProtocol {\n  return { creator: \"\", address: \"\" };\n}\n\nexport const MsgCollectFeeProtocol = {\n  encode(\n    message: MsgCollectFeeProtocol,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocol {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocol();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectFeeProtocol {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCollectFeeProtocol): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocol>, I>>(\n    object: I\n  ): MsgCollectFeeProtocol {\n    const message = createBaseMsgCollectFeeProtocol();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocolResponse(): MsgCollectFeeProtocolResponse {\n  return {};\n}\n\nexport const MsgCollectFeeProtocolResponse = {\n  encode(\n    _: MsgCollectFeeProtocolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectFeeProtocolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectFeeProtocolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocolResponse>, I>>(\n    _: I\n  ): MsgCollectFeeProtocolResponse {\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePool(): MsgGovCorePool {\n  return { creator: \"\", address: \"\", action: \"\", triggerTime: undefined };\n}\n\nexport const MsgGovCorePool = {\n  encode(\n    message: MsgGovCorePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    if (message.action !== \"\") {\n      writer.uint32(26).string(message.action);\n    }\n    if (message.triggerTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.triggerTime),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGovCorePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        case 3:\n          message.action = reader.string();\n          break;\n        case 4:\n          message.triggerTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGovCorePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n      action: isSet(object.action) ? String(object.action) : \"\",\n      triggerTime: isSet(object.triggerTime)\n        ? fromJsonTimestamp(object.triggerTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgGovCorePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    message.action !== undefined && (obj.action = message.action);\n    message.triggerTime !== undefined &&\n      (obj.triggerTime = message.triggerTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePool>, I>>(\n    object: I\n  ): MsgGovCorePool {\n    const message = createBaseMsgGovCorePool();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    message.action = object.action ?? \"\";\n    message.triggerTime = object.triggerTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePoolResponse(): MsgGovCorePoolResponse {\n  return {};\n}\n\nexport const MsgGovCorePoolResponse = {\n  encode(\n    _: MsgGovCorePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgGovCorePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGovCorePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGovCorePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePoolResponse>, I>>(\n    _: I\n  ): MsgGovCorePoolResponse {\n    const message = createBaseMsgGovCorePoolResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse>;\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse>;\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse>;\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse>;\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse>;\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse>;\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse>;\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse>;\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreatePool = this.CreatePool.bind(this);\n    this.CreatePosition = this.CreatePosition.bind(this);\n    this.IncreaseLiquidity = this.IncreaseLiquidity.bind(this);\n    this.DecreaseLiquidity = this.DecreaseLiquidity.bind(this);\n    this.Collect = this.Collect.bind(this);\n    this.SwapExactIn = this.SwapExactIn.bind(this);\n    this.SwapExactOut = this.SwapExactOut.bind(this);\n    this.CollectReward = this.CollectReward.bind(this);\n    this.CollectFeeProtocol = this.CollectFeeProtocol.bind(this);\n    this.GovCorePool = this.GovCorePool.bind(this);\n  }\n\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse> {\n    return this.rpc.unary(\n      MsgCreatePoolDesc,\n      MsgCreatePool.fromPartial(request),\n      metadata\n    );\n  }\n\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse> {\n    return this.rpc.unary(\n      MsgCreatePositionDesc,\n      MsgCreatePosition.fromPartial(request),\n      metadata\n    );\n  }\n\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgIncreaseLiquidityDesc,\n      MsgIncreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgDecreaseLiquidityDesc,\n      MsgDecreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse> {\n    return this.rpc.unary(\n      MsgCollectDesc,\n      MsgCollect.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse> {\n    return this.rpc.unary(\n      MsgSwapExactInDesc,\n      MsgSwapExactIn.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse> {\n    return this.rpc.unary(\n      MsgSwapExactOutDesc,\n      MsgSwapExactOut.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse> {\n    return this.rpc.unary(\n      MsgCollectRewardDesc,\n      MsgCollectReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse> {\n    return this.rpc.unary(\n      MsgCollectFeeProtocolDesc,\n      MsgCollectFeeProtocol.fromPartial(request),\n      metadata\n    );\n  }\n\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse> {\n    return this.rpc.unary(\n      MsgGovCorePoolDesc,\n      MsgGovCorePool.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.swap.Msg\",\n};\n\nexport const MsgCreatePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCreatePositionDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePosition\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePosition.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePositionResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgIncreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"IncreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgIncreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgIncreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDecreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"DecreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDecreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDecreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectDesc: UnaryMethodDefinitionish = {\n  methodName: \"Collect\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollect.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactInDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactIn\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactIn.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactInResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactOutDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactOut\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactOut.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactOutResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectFeeProtocolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectFeeProtocol\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectFeeProtocol.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectFeeProtocolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgGovCorePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"GovCorePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGovCorePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGovCorePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import {\n  MsgCollect as MsgCollect_pb,\n  MsgCollectReward as MsgCollectReward_pb,\n  MsgCreatePool as MsgCreatePool_pb,\n  MsgCreatePosition as MsgCreatePosition_pb,\n  MsgDecreaseLiquidity as MsgDecreaseLiquidity_pb,\n  MsgIncreaseLiquidity as MsgIncreaseLiquidity_pb,\n  MsgSwapExactIn as MsgSwapExactIn_pb,\n  MsgSwapExactOut as MsgSwapExactOut_pb,\n  protobufPackage,\n} from \"../proto/swap/tx\";\nimport { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\n\nexport class MsgCollectReward extends BaseMsg {\n  public protoMsg: MsgCollectReward_pb;\n  constructor(msg: MsgCollectReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollectReward.typeUrl,\n      value: MsgCollectReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectReward`;\n  export const Proto = MsgCollectReward_pb;\n  export interface Proto extends MsgCollectReward_pb {}\n}\n\nexport class MsgSwapExactOut extends BaseMsg {\n  public protoMsg: MsgSwapExactOut_pb;\n  constructor(msg: MsgSwapExactOut_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactOut.typeUrl,\n      value: MsgSwapExactOut_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactOut {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactOut`;\n  export const Proto = MsgSwapExactOut_pb;\n  export interface Proto extends MsgSwapExactOut_pb {}\n}\n\nexport class MsgSwapExactIn extends BaseMsg {\n  public protoMsg: MsgSwapExactIn_pb;\n  constructor(msg: MsgSwapExactIn_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactIn.typeUrl,\n      value: MsgSwapExactIn_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactIn {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactIn`;\n  export const Proto = MsgSwapExactIn_pb;\n  export interface Proto extends MsgSwapExactIn_pb {}\n}\n\nexport class MsgCreatePool extends BaseMsg {\n  public protoMsg: MsgCreatePool_pb;\n  constructor(msg: MsgCreatePool_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePool.typeUrl,\n      value: MsgCreatePool_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePool {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePool`;\n  export const Proto = MsgCreatePool_pb;\n  export interface Proto extends MsgCreatePool_pb {}\n}\n\nexport class MsgCollect extends BaseMsg {\n  public protoMsg: MsgCollect_pb;\n  constructor(msg: MsgCollect_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollect.typeUrl,\n      value: MsgCollect_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollect {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollect`;\n  export const Proto = MsgCollect_pb;\n  export interface Proto extends MsgCollect_pb {}\n}\n\nexport class MsgCreatePosition extends BaseMsg {\n  public protoMsg: MsgCreatePosition_pb;\n  constructor(msg: MsgCreatePosition_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePosition.typeUrl,\n      value: MsgCreatePosition_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePosition {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePosition`;\n  export const Proto = MsgCreatePosition_pb;\n  export interface Proto extends MsgCreatePosition_pb {}\n}\n\nexport class MsgDecreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgDecreaseLiquidity_pb;\n  constructor(msg: MsgDecreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDecreaseLiquidity.typeUrl,\n      value: MsgDecreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDecreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgDecreaseLiquidity`;\n  export const Proto = MsgDecreaseLiquidity_pb;\n  export interface Proto extends MsgDecreaseLiquidity_pb {}\n}\n\nexport class MsgIncreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgIncreaseLiquidity_pb;\n  constructor(msg: MsgIncreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgIncreaseLiquidity.typeUrl,\n      value: MsgIncreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgIncreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgIncreaseLiquidity`;\n  export const Proto = MsgIncreaseLiquidity_pb;\n  export interface Proto extends MsgIncreaseLiquidity_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := ptypes.MarshalAny(foo)\n *      ...\n *      foo := &pb.Foo{}\n *      if err := ptypes.UnmarshalAny(any, foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n */\nexport interface Any {\n  /**\n   * A URL/resource name that uniquely identifies the type of the serialized\n   * protocol buffer message. This string must contain at least\n   * one \"/\" character. The last segment of the URL's path must represent\n   * the fully qualified name of the type (as in\n   * `path/google.protobuf.Duration`). The name should be in a canonical form\n   * (e.g., leading \".\" is not accepted).\n   *\n   * In practice, teams usually precompile into the binary all types that they\n   * expect it to use in the context of Any. However, for URLs which use the\n   * scheme `http`, `https`, or no scheme, one can optionally set up a type\n   * server that maps type URLs to message definitions as follows:\n   *\n   * * If no scheme is provided, `https` is assumed.\n   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   *   value in binary format, or produce an error.\n   * * Applications are allowed to cache lookup results based on the\n   *   URL, or have them precompiled into a binary to avoid any\n   *   lookup. Therefore, binary compatibility needs to be preserved\n   *   on changes to types. (Use versioned type names to manage\n   *   breaking changes.)\n   *\n   * Note: this functionality is not currently available in the official\n   * protobuf release, and it is not used for type URLs beginning with\n   * type.googleapis.com.\n   *\n   * Schemes other than `http`, `https` (or the empty scheme) might be\n   * used with implementation specific semantics.\n   */\n  typeUrl: string;\n  /** Must be a valid serialized protocol buffer of the above specified type. */\n  value: Uint8Array;\n}\n\nfunction createBaseAny(): Any {\n  return { typeUrl: \"\", value: new Uint8Array() };\n}\n\nexport const Any = {\n  encode(message: Any, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.typeUrl !== \"\") {\n      writer.uint32(10).string(message.typeUrl);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Any {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAny();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.typeUrl = reader.string();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Any {\n    return {\n      typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : \"\",\n      value: isSet(object.value)\n        ? bytesFromBase64(object.value)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Any): unknown {\n    const obj: any = {};\n    message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);\n    message.value !== undefined &&\n      (obj.value = base64FromBytes(\n        message.value !== undefined ? message.value : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Any>, I>>(object: I): Any {\n    const message = createBaseAny();\n    message.typeUrl = object.typeUrl ?? \"\";\n    message.value = object.value ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n *\n * # Examples\n *\n * Example 1: Compute Duration from two Timestamps in pseudo code.\n *\n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n *\n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n *\n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (duration.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n *\n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n *\n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n *\n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n *\n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n *\n * Example 3: Compute Duration from datetime.timedelta in Python.\n *\n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n *\n * # JSON Mapping\n *\n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n */\nexport interface Duration {\n  /**\n   * Signed seconds of the span of time. Must be from -315,576,000,000\n   * to +315,576,000,000 inclusive. Note: these bounds are computed from:\n   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n   */\n  seconds: Long;\n  /**\n   * Signed fractions of a second at nanosecond resolution of the span\n   * of time. Durations less than one second are represented with a 0\n   * `seconds` field and a positive or negative `nanos` field. For durations\n   * of one second or more, a non-zero value for the `nanos` field must be\n   * of the same sign as the `seconds` field. Must be from -999,999,999\n   * to +999,999,999 inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseDuration(): Duration {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Duration = {\n  encode(\n    message: Duration,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Duration {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDuration();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Duration {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Duration): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Duration>, I>>(object: I): Duration {\n    const message = createBaseDuration();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.base.v1beta1\";\n\n/**\n * Coin defines a token with a denomination and an amount.\n *\n * NOTE: The amount field is an Int which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface Coin {\n  denom: string;\n  amount: string;\n}\n\n/**\n * DecCoin defines a token with a denomination and a decimal amount.\n *\n * NOTE: The amount field is an Dec which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface DecCoin {\n  denom: string;\n  amount: string;\n}\n\n/** IntProto defines a Protobuf wrapper around an Int object. */\nexport interface IntProto {\n  int: string;\n}\n\n/** DecProto defines a Protobuf wrapper around a Dec object. */\nexport interface DecProto {\n  dec: string;\n}\n\nfunction createBaseCoin(): Coin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const Coin = {\n  encode(message: Coin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Coin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Coin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: Coin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Coin>, I>>(object: I): Coin {\n    const message = createBaseCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecCoin(): DecCoin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const DecCoin = {\n  encode(\n    message: DecCoin,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecCoin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecCoin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: DecCoin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecCoin>, I>>(object: I): DecCoin {\n    const message = createBaseDecCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseIntProto(): IntProto {\n  return { int: \"\" };\n}\n\nexport const IntProto = {\n  encode(\n    message: IntProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.int !== \"\") {\n      writer.uint32(10).string(message.int);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): IntProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseIntProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.int = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): IntProto {\n    return {\n      int: isSet(object.int) ? String(object.int) : \"\",\n    };\n  },\n\n  toJSON(message: IntProto): unknown {\n    const obj: any = {};\n    message.int !== undefined && (obj.int = message.int);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<IntProto>, I>>(object: I): IntProto {\n    const message = createBaseIntProto();\n    message.int = object.int ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecProto(): DecProto {\n  return { dec: \"\" };\n}\n\nexport const DecProto = {\n  encode(\n    message: DecProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.dec !== \"\") {\n      writer.uint32(10).string(message.dec);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.dec = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecProto {\n    return {\n      dec: isSet(object.dec) ? String(object.dec) : \"\",\n    };\n  },\n\n  toJSON(message: DecProto): unknown {\n    const obj: any = {};\n    message.dec !== undefined && (obj.dec = message.dec);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecProto>, I>>(object: I): DecProto {\n    const message = createBaseDecProto();\n    message.dec = object.dec ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Duration } from \"../../../google/protobuf/duration\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.gov.v1beta1\";\n\n/** VoteOption enumerates the valid vote options for a given governance proposal. */\nexport enum VoteOption {\n  /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */\n  VOTE_OPTION_UNSPECIFIED = 0,\n  /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */\n  VOTE_OPTION_YES = 1,\n  /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */\n  VOTE_OPTION_ABSTAIN = 2,\n  /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */\n  VOTE_OPTION_NO = 3,\n  /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */\n  VOTE_OPTION_NO_WITH_VETO = 4,\n  UNRECOGNIZED = -1,\n}\n\nexport function voteOptionFromJSON(object: any): VoteOption {\n  switch (object) {\n    case 0:\n    case \"VOTE_OPTION_UNSPECIFIED\":\n      return VoteOption.VOTE_OPTION_UNSPECIFIED;\n    case 1:\n    case \"VOTE_OPTION_YES\":\n      return VoteOption.VOTE_OPTION_YES;\n    case 2:\n    case \"VOTE_OPTION_ABSTAIN\":\n      return VoteOption.VOTE_OPTION_ABSTAIN;\n    case 3:\n    case \"VOTE_OPTION_NO\":\n      return VoteOption.VOTE_OPTION_NO;\n    case 4:\n    case \"VOTE_OPTION_NO_WITH_VETO\":\n      return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VoteOption.UNRECOGNIZED;\n  }\n}\n\nexport function voteOptionToJSON(object: VoteOption): string {\n  switch (object) {\n    case VoteOption.VOTE_OPTION_UNSPECIFIED:\n      return \"VOTE_OPTION_UNSPECIFIED\";\n    case VoteOption.VOTE_OPTION_YES:\n      return \"VOTE_OPTION_YES\";\n    case VoteOption.VOTE_OPTION_ABSTAIN:\n      return \"VOTE_OPTION_ABSTAIN\";\n    case VoteOption.VOTE_OPTION_NO:\n      return \"VOTE_OPTION_NO\";\n    case VoteOption.VOTE_OPTION_NO_WITH_VETO:\n      return \"VOTE_OPTION_NO_WITH_VETO\";\n    case VoteOption.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** ProposalStatus enumerates the valid statuses of a proposal. */\nexport enum ProposalStatus {\n  /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status. */\n  PROPOSAL_STATUS_UNSPECIFIED = 0,\n  /**\n   * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\n   * period.\n   */\n  PROPOSAL_STATUS_DEPOSIT_PERIOD = 1,\n  /**\n   * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\n   * period.\n   */\n  PROPOSAL_STATUS_VOTING_PERIOD = 2,\n  /**\n   * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\n   * passed.\n   */\n  PROPOSAL_STATUS_PASSED = 3,\n  /**\n   * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\n   * been rejected.\n   */\n  PROPOSAL_STATUS_REJECTED = 4,\n  /**\n   * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\n   * failed.\n   */\n  PROPOSAL_STATUS_FAILED = 5,\n  UNRECOGNIZED = -1,\n}\n\nexport function proposalStatusFromJSON(object: any): ProposalStatus {\n  switch (object) {\n    case 0:\n    case \"PROPOSAL_STATUS_UNSPECIFIED\":\n      return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;\n    case 1:\n    case \"PROPOSAL_STATUS_DEPOSIT_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;\n    case 2:\n    case \"PROPOSAL_STATUS_VOTING_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;\n    case 3:\n    case \"PROPOSAL_STATUS_PASSED\":\n      return ProposalStatus.PROPOSAL_STATUS_PASSED;\n    case 4:\n    case \"PROPOSAL_STATUS_REJECTED\":\n      return ProposalStatus.PROPOSAL_STATUS_REJECTED;\n    case 5:\n    case \"PROPOSAL_STATUS_FAILED\":\n      return ProposalStatus.PROPOSAL_STATUS_FAILED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ProposalStatus.UNRECOGNIZED;\n  }\n}\n\nexport function proposalStatusToJSON(object: ProposalStatus): string {\n  switch (object) {\n    case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:\n      return \"PROPOSAL_STATUS_UNSPECIFIED\";\n    case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:\n      return \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:\n      return \"PROPOSAL_STATUS_VOTING_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_PASSED:\n      return \"PROPOSAL_STATUS_PASSED\";\n    case ProposalStatus.PROPOSAL_STATUS_REJECTED:\n      return \"PROPOSAL_STATUS_REJECTED\";\n    case ProposalStatus.PROPOSAL_STATUS_FAILED:\n      return \"PROPOSAL_STATUS_FAILED\";\n    case ProposalStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/**\n * WeightedVoteOption defines a unit of vote for vote split.\n *\n * Since: cosmos-sdk 0.43\n */\nexport interface WeightedVoteOption {\n  option: VoteOption;\n  weight: string;\n}\n\n/**\n * TextProposal defines a standard text proposal whose changes need to be\n * manually updated in case of approval.\n */\nexport interface TextProposal {\n  title: string;\n  description: string;\n}\n\n/**\n * Deposit defines an amount deposited by an account address to an active\n * proposal.\n */\nexport interface Deposit {\n  proposalId: Long;\n  depositor: string;\n  amount: Coin[];\n}\n\n/** Proposal defines the core field members of a governance proposal. */\nexport interface Proposal {\n  proposalId: Long;\n  content?: Any;\n  status: ProposalStatus;\n  finalTallyResult?: TallyResult;\n  submitTime?: Date;\n  depositEndTime?: Date;\n  totalDeposit: Coin[];\n  votingStartTime?: Date;\n  votingEndTime?: Date;\n}\n\n/** TallyResult defines a standard tally for a governance proposal. */\nexport interface TallyResult {\n  yes: string;\n  abstain: string;\n  no: string;\n  noWithVeto: string;\n}\n\n/**\n * Vote defines a vote on a governance proposal.\n * A Vote consists of a proposal ID, the voter, and the vote option.\n */\nexport interface Vote {\n  proposalId: Long;\n  voter: string;\n  /**\n   * Deprecated: Prefer to use `options` instead. This field is set in queries\n   * if and only if `len(options) == 1` and that option has weight 1. In all\n   * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.\n   *\n   * @deprecated\n   */\n  option: VoteOption;\n  /** Since: cosmos-sdk 0.43 */\n  options: WeightedVoteOption[];\n}\n\n/** DepositParams defines the params for deposits on governance proposals. */\nexport interface DepositParams {\n  /** Minimum deposit for a proposal to enter voting period. */\n  minDeposit: Coin[];\n  /**\n   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n   *  months.\n   */\n  maxDepositPeriod?: Duration;\n}\n\n/** VotingParams defines the params for voting on governance proposals. */\nexport interface VotingParams {\n  /** Length of the voting period. */\n  votingPeriod?: Duration;\n}\n\n/** TallyParams defines the params for tallying votes on governance proposals. */\nexport interface TallyParams {\n  /**\n   * Minimum percentage of total stake needed to vote for a result to be\n   *  considered valid.\n   */\n  quorum: Uint8Array;\n  /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */\n  threshold: Uint8Array;\n  /**\n   * Minimum value of Veto votes to Total votes ratio for proposal to be\n   *  vetoed. Default value: 1/3.\n   */\n  vetoThreshold: Uint8Array;\n}\n\nfunction createBaseWeightedVoteOption(): WeightedVoteOption {\n  return { option: 0, weight: \"\" };\n}\n\nexport const WeightedVoteOption = {\n  encode(\n    message: WeightedVoteOption,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.option !== 0) {\n      writer.uint32(8).int32(message.option);\n    }\n    if (message.weight !== \"\") {\n      writer.uint32(18).string(message.weight);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): WeightedVoteOption {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseWeightedVoteOption();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.option = reader.int32() as any;\n          break;\n        case 2:\n          message.weight = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): WeightedVoteOption {\n    return {\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n      weight: isSet(object.weight) ? String(object.weight) : \"\",\n    };\n  },\n\n  toJSON(message: WeightedVoteOption): unknown {\n    const obj: any = {};\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    message.weight !== undefined && (obj.weight = message.weight);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<WeightedVoteOption>, I>>(\n    object: I\n  ): WeightedVoteOption {\n    const message = createBaseWeightedVoteOption();\n    message.option = object.option ?? 0;\n    message.weight = object.weight ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextProposal(): TextProposal {\n  return { title: \"\", description: \"\" };\n}\n\nexport const TextProposal = {\n  encode(\n    message: TextProposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TextProposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TextProposal {\n    return {\n      title: isSet(object.title) ? String(object.title) : \"\",\n      description: isSet(object.description) ? String(object.description) : \"\",\n    };\n  },\n\n  toJSON(message: TextProposal): unknown {\n    const obj: any = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined &&\n      (obj.description = message.description);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TextProposal>, I>>(\n    object: I\n  ): TextProposal {\n    const message = createBaseTextProposal();\n    message.title = object.title ?? \"\";\n    message.description = object.description ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDeposit(): Deposit {\n  return { proposalId: Long.UZERO, depositor: \"\", amount: [] };\n}\n\nexport const Deposit = {\n  encode(\n    message: Deposit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Deposit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDeposit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Deposit {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Deposit): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Deposit>, I>>(object: I): Deposit {\n    const message = createBaseDeposit();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.depositor = object.depositor ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseProposal(): Proposal {\n  return {\n    proposalId: Long.UZERO,\n    content: undefined,\n    status: 0,\n    finalTallyResult: undefined,\n    submitTime: undefined,\n    depositEndTime: undefined,\n    totalDeposit: [],\n    votingStartTime: undefined,\n    votingEndTime: undefined,\n  };\n}\n\nexport const Proposal = {\n  encode(\n    message: Proposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.content !== undefined) {\n      Any.encode(message.content, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(24).int32(message.status);\n    }\n    if (message.finalTallyResult !== undefined) {\n      TallyResult.encode(\n        message.finalTallyResult,\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    if (message.submitTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.submitTime),\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.depositEndTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.depositEndTime),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    for (const v of message.totalDeposit) {\n      Coin.encode(v!, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.votingStartTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.votingStartTime),\n        writer.uint32(66).fork()\n      ).ldelim();\n    }\n    if (message.votingEndTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.votingEndTime),\n        writer.uint32(74).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.content = Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.status = reader.int32() as any;\n          break;\n        case 4:\n          message.finalTallyResult = TallyResult.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 5:\n          message.submitTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 6:\n          message.depositEndTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 7:\n          message.totalDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.votingStartTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 9:\n          message.votingEndTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proposal {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      content: isSet(object.content) ? Any.fromJSON(object.content) : undefined,\n      status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,\n      finalTallyResult: isSet(object.finalTallyResult)\n        ? TallyResult.fromJSON(object.finalTallyResult)\n        : undefined,\n      submitTime: isSet(object.submitTime)\n        ? fromJsonTimestamp(object.submitTime)\n        : undefined,\n      depositEndTime: isSet(object.depositEndTime)\n        ? fromJsonTimestamp(object.depositEndTime)\n        : undefined,\n      totalDeposit: Array.isArray(object?.totalDeposit)\n        ? object.totalDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      votingStartTime: isSet(object.votingStartTime)\n        ? fromJsonTimestamp(object.votingStartTime)\n        : undefined,\n      votingEndTime: isSet(object.votingEndTime)\n        ? fromJsonTimestamp(object.votingEndTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Proposal): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.content !== undefined &&\n      (obj.content = message.content ? Any.toJSON(message.content) : undefined);\n    message.status !== undefined &&\n      (obj.status = proposalStatusToJSON(message.status));\n    message.finalTallyResult !== undefined &&\n      (obj.finalTallyResult = message.finalTallyResult\n        ? TallyResult.toJSON(message.finalTallyResult)\n        : undefined);\n    message.submitTime !== undefined &&\n      (obj.submitTime = message.submitTime.toISOString());\n    message.depositEndTime !== undefined &&\n      (obj.depositEndTime = message.depositEndTime.toISOString());\n    if (message.totalDeposit) {\n      obj.totalDeposit = message.totalDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.totalDeposit = [];\n    }\n    message.votingStartTime !== undefined &&\n      (obj.votingStartTime = message.votingStartTime.toISOString());\n    message.votingEndTime !== undefined &&\n      (obj.votingEndTime = message.votingEndTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {\n    const message = createBaseProposal();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.content =\n      object.content !== undefined && object.content !== null\n        ? Any.fromPartial(object.content)\n        : undefined;\n    message.status = object.status ?? 0;\n    message.finalTallyResult =\n      object.finalTallyResult !== undefined && object.finalTallyResult !== null\n        ? TallyResult.fromPartial(object.finalTallyResult)\n        : undefined;\n    message.submitTime = object.submitTime ?? undefined;\n    message.depositEndTime = object.depositEndTime ?? undefined;\n    message.totalDeposit =\n      object.totalDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.votingStartTime = object.votingStartTime ?? undefined;\n    message.votingEndTime = object.votingEndTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTallyResult(): TallyResult {\n  return { yes: \"\", abstain: \"\", no: \"\", noWithVeto: \"\" };\n}\n\nexport const TallyResult = {\n  encode(\n    message: TallyResult,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.yes !== \"\") {\n      writer.uint32(10).string(message.yes);\n    }\n    if (message.abstain !== \"\") {\n      writer.uint32(18).string(message.abstain);\n    }\n    if (message.no !== \"\") {\n      writer.uint32(26).string(message.no);\n    }\n    if (message.noWithVeto !== \"\") {\n      writer.uint32(34).string(message.noWithVeto);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TallyResult {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTallyResult();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.yes = reader.string();\n          break;\n        case 2:\n          message.abstain = reader.string();\n          break;\n        case 3:\n          message.no = reader.string();\n          break;\n        case 4:\n          message.noWithVeto = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TallyResult {\n    return {\n      yes: isSet(object.yes) ? String(object.yes) : \"\",\n      abstain: isSet(object.abstain) ? String(object.abstain) : \"\",\n      no: isSet(object.no) ? String(object.no) : \"\",\n      noWithVeto: isSet(object.noWithVeto) ? String(object.noWithVeto) : \"\",\n    };\n  },\n\n  toJSON(message: TallyResult): unknown {\n    const obj: any = {};\n    message.yes !== undefined && (obj.yes = message.yes);\n    message.abstain !== undefined && (obj.abstain = message.abstain);\n    message.no !== undefined && (obj.no = message.no);\n    message.noWithVeto !== undefined && (obj.noWithVeto = message.noWithVeto);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TallyResult>, I>>(\n    object: I\n  ): TallyResult {\n    const message = createBaseTallyResult();\n    message.yes = object.yes ?? \"\";\n    message.abstain = object.abstain ?? \"\";\n    message.no = object.no ?? \"\";\n    message.noWithVeto = object.noWithVeto ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseVote(): Vote {\n  return { proposalId: Long.UZERO, voter: \"\", option: 0, options: [] };\n}\n\nexport const Vote = {\n  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    for (const v of message.options) {\n      WeightedVoteOption.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32() as any;\n          break;\n        case 4:\n          message.options.push(\n            WeightedVoteOption.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Vote {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n      options: Array.isArray(object?.options)\n        ? object.options.map((e: any) => WeightedVoteOption.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Vote): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    if (message.options) {\n      obj.options = message.options.map((e) =>\n        e ? WeightedVoteOption.toJSON(e) : undefined\n      );\n    } else {\n      obj.options = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {\n    const message = createBaseVote();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.option = object.option ?? 0;\n    message.options =\n      object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDepositParams(): DepositParams {\n  return { minDeposit: [], maxDepositPeriod: undefined };\n}\n\nexport const DepositParams = {\n  encode(\n    message: DepositParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.minDeposit) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxDepositPeriod !== undefined) {\n      Duration.encode(\n        message.maxDepositPeriod,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DepositParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDepositParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.minDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.maxDepositPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DepositParams {\n    return {\n      minDeposit: Array.isArray(object?.minDeposit)\n        ? object.minDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      maxDepositPeriod: isSet(object.maxDepositPeriod)\n        ? Duration.fromJSON(object.maxDepositPeriod)\n        : undefined,\n    };\n  },\n\n  toJSON(message: DepositParams): unknown {\n    const obj: any = {};\n    if (message.minDeposit) {\n      obj.minDeposit = message.minDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.minDeposit = [];\n    }\n    message.maxDepositPeriod !== undefined &&\n      (obj.maxDepositPeriod = message.maxDepositPeriod\n        ? Duration.toJSON(message.maxDepositPeriod)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DepositParams>, I>>(\n    object: I\n  ): DepositParams {\n    const message = createBaseDepositParams();\n    message.minDeposit =\n      object.minDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.maxDepositPeriod =\n      object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null\n        ? Duration.fromPartial(object.maxDepositPeriod)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseVotingParams(): VotingParams {\n  return { votingPeriod: undefined };\n}\n\nexport const VotingParams = {\n  encode(\n    message: VotingParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.votingPeriod !== undefined) {\n      Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): VotingParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVotingParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.votingPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): VotingParams {\n    return {\n      votingPeriod: isSet(object.votingPeriod)\n        ? Duration.fromJSON(object.votingPeriod)\n        : undefined,\n    };\n  },\n\n  toJSON(message: VotingParams): unknown {\n    const obj: any = {};\n    message.votingPeriod !== undefined &&\n      (obj.votingPeriod = message.votingPeriod\n        ? Duration.toJSON(message.votingPeriod)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<VotingParams>, I>>(\n    object: I\n  ): VotingParams {\n    const message = createBaseVotingParams();\n    message.votingPeriod =\n      object.votingPeriod !== undefined && object.votingPeriod !== null\n        ? Duration.fromPartial(object.votingPeriod)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseTallyParams(): TallyParams {\n  return {\n    quorum: new Uint8Array(),\n    threshold: new Uint8Array(),\n    vetoThreshold: new Uint8Array(),\n  };\n}\n\nexport const TallyParams = {\n  encode(\n    message: TallyParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.quorum.length !== 0) {\n      writer.uint32(10).bytes(message.quorum);\n    }\n    if (message.threshold.length !== 0) {\n      writer.uint32(18).bytes(message.threshold);\n    }\n    if (message.vetoThreshold.length !== 0) {\n      writer.uint32(26).bytes(message.vetoThreshold);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TallyParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTallyParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.quorum = reader.bytes();\n          break;\n        case 2:\n          message.threshold = reader.bytes();\n          break;\n        case 3:\n          message.vetoThreshold = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TallyParams {\n    return {\n      quorum: isSet(object.quorum)\n        ? bytesFromBase64(object.quorum)\n        : new Uint8Array(),\n      threshold: isSet(object.threshold)\n        ? bytesFromBase64(object.threshold)\n        : new Uint8Array(),\n      vetoThreshold: isSet(object.vetoThreshold)\n        ? bytesFromBase64(object.vetoThreshold)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: TallyParams): unknown {\n    const obj: any = {};\n    message.quorum !== undefined &&\n      (obj.quorum = base64FromBytes(\n        message.quorum !== undefined ? message.quorum : new Uint8Array()\n      ));\n    message.threshold !== undefined &&\n      (obj.threshold = base64FromBytes(\n        message.threshold !== undefined ? message.threshold : new Uint8Array()\n      ));\n    message.vetoThreshold !== undefined &&\n      (obj.vetoThreshold = base64FromBytes(\n        message.vetoThreshold !== undefined\n          ? message.vetoThreshold\n          : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TallyParams>, I>>(\n    object: I\n  ): TallyParams {\n    const message = createBaseTallyParams();\n    message.quorum = object.quorum ?? new Uint8Array();\n    message.threshold = object.threshold ?? new Uint8Array();\n    message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  VoteOption,\n  WeightedVoteOption,\n  voteOptionFromJSON,\n  voteOptionToJSON,\n} from \"./gov\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.gov.v1beta1\";\n\n/**\n * MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary\n * proposal Content.\n */\nexport interface MsgSubmitProposal {\n  content?: Any;\n  initialDeposit: Coin[];\n  proposer: string;\n}\n\n/** MsgSubmitProposalResponse defines the Msg/SubmitProposal response type. */\nexport interface MsgSubmitProposalResponse {\n  proposalId: Long;\n}\n\n/** MsgVote defines a message to cast a vote. */\nexport interface MsgVote {\n  proposalId: Long;\n  voter: string;\n  option: VoteOption;\n}\n\n/** MsgVoteResponse defines the Msg/Vote response type. */\nexport interface MsgVoteResponse {}\n\n/**\n * MsgVoteWeighted defines a message to cast a vote.\n *\n * Since: cosmos-sdk 0.43\n */\nexport interface MsgVoteWeighted {\n  proposalId: Long;\n  voter: string;\n  options: WeightedVoteOption[];\n}\n\n/**\n * MsgVoteWeightedResponse defines the Msg/VoteWeighted response type.\n *\n * Since: cosmos-sdk 0.43\n */\nexport interface MsgVoteWeightedResponse {}\n\n/** MsgDeposit defines a message to submit a deposit to an existing proposal. */\nexport interface MsgDeposit {\n  proposalId: Long;\n  depositor: string;\n  amount: Coin[];\n}\n\n/** MsgDepositResponse defines the Msg/Deposit response type. */\nexport interface MsgDepositResponse {}\n\nfunction createBaseMsgSubmitProposal(): MsgSubmitProposal {\n  return { content: undefined, initialDeposit: [], proposer: \"\" };\n}\n\nexport const MsgSubmitProposal = {\n  encode(\n    message: MsgSubmitProposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.content !== undefined) {\n      Any.encode(message.content, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.initialDeposit) {\n      Coin.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.proposer !== \"\") {\n      writer.uint32(26).string(message.proposer);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubmitProposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.content = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.initialDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.proposer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitProposal {\n    return {\n      content: isSet(object.content) ? Any.fromJSON(object.content) : undefined,\n      initialDeposit: Array.isArray(object?.initialDeposit)\n        ? object.initialDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      proposer: isSet(object.proposer) ? String(object.proposer) : \"\",\n    };\n  },\n\n  toJSON(message: MsgSubmitProposal): unknown {\n    const obj: any = {};\n    message.content !== undefined &&\n      (obj.content = message.content ? Any.toJSON(message.content) : undefined);\n    if (message.initialDeposit) {\n      obj.initialDeposit = message.initialDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.initialDeposit = [];\n    }\n    message.proposer !== undefined && (obj.proposer = message.proposer);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitProposal>, I>>(\n    object: I\n  ): MsgSubmitProposal {\n    const message = createBaseMsgSubmitProposal();\n    message.content =\n      object.content !== undefined && object.content !== null\n        ? Any.fromPartial(object.content)\n        : undefined;\n    message.initialDeposit =\n      object.initialDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.proposer = object.proposer ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgSubmitProposalResponse(): MsgSubmitProposalResponse {\n  return { proposalId: Long.UZERO };\n}\n\nexport const MsgSubmitProposalResponse = {\n  encode(\n    message: MsgSubmitProposalResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSubmitProposalResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitProposalResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitProposalResponse {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgSubmitProposalResponse): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitProposalResponse>, I>>(\n    object: I\n  ): MsgSubmitProposalResponse {\n    const message = createBaseMsgSubmitProposalResponse();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgVote(): MsgVote {\n  return { proposalId: Long.UZERO, voter: \"\", option: 0 };\n}\n\nexport const MsgVote = {\n  encode(\n    message: MsgVote,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVote {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n    };\n  },\n\n  toJSON(message: MsgVote): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVote>, I>>(object: I): MsgVote {\n    const message = createBaseMsgVote();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.option = object.option ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteResponse(): MsgVoteResponse {\n  return {};\n}\n\nexport const MsgVoteResponse = {\n  encode(\n    _: MsgVoteResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVoteResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVoteResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVoteResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteResponse>, I>>(\n    _: I\n  ): MsgVoteResponse {\n    const message = createBaseMsgVoteResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteWeighted(): MsgVoteWeighted {\n  return { proposalId: Long.UZERO, voter: \"\", options: [] };\n}\n\nexport const MsgVoteWeighted = {\n  encode(\n    message: MsgVoteWeighted,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    for (const v of message.options) {\n      WeightedVoteOption.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVoteWeighted {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteWeighted();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.options.push(\n            WeightedVoteOption.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVoteWeighted {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      options: Array.isArray(object?.options)\n        ? object.options.map((e: any) => WeightedVoteOption.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgVoteWeighted): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    if (message.options) {\n      obj.options = message.options.map((e) =>\n        e ? WeightedVoteOption.toJSON(e) : undefined\n      );\n    } else {\n      obj.options = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteWeighted>, I>>(\n    object: I\n  ): MsgVoteWeighted {\n    const message = createBaseMsgVoteWeighted();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.options =\n      object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteWeightedResponse(): MsgVoteWeightedResponse {\n  return {};\n}\n\nexport const MsgVoteWeightedResponse = {\n  encode(\n    _: MsgVoteWeightedResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgVoteWeightedResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteWeightedResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVoteWeightedResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVoteWeightedResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteWeightedResponse>, I>>(\n    _: I\n  ): MsgVoteWeightedResponse {\n    const message = createBaseMsgVoteWeightedResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDeposit(): MsgDeposit {\n  return { proposalId: Long.UZERO, depositor: \"\", amount: [] };\n}\n\nexport const MsgDeposit = {\n  encode(\n    message: MsgDeposit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeposit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDeposit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDeposit {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgDeposit): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDeposit>, I>>(\n    object: I\n  ): MsgDeposit {\n    const message = createBaseMsgDeposit();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.depositor = object.depositor ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgDepositResponse(): MsgDepositResponse {\n  return {};\n}\n\nexport const MsgDepositResponse = {\n  encode(\n    _: MsgDepositResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDepositResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDepositResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDepositResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDepositResponse>, I>>(\n    _: I\n  ): MsgDepositResponse {\n    const message = createBaseMsgDepositResponse();\n    return message;\n  },\n};\n\n/** Msg defines the bank Msg service. */\nexport interface Msg {\n  /** SubmitProposal defines a method to create new proposal given a content. */\n  SubmitProposal(\n    request: DeepPartial<MsgSubmitProposal>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitProposalResponse>;\n  /** Vote defines a method to add a vote on a specific proposal. */\n  Vote(\n    request: DeepPartial<MsgVote>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteResponse>;\n  /**\n   * VoteWeighted defines a method to add a weighted vote on a specific proposal.\n   *\n   * Since: cosmos-sdk 0.43\n   */\n  VoteWeighted(\n    request: DeepPartial<MsgVoteWeighted>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteWeightedResponse>;\n  /** Deposit defines a method to add deposit on a specific proposal. */\n  Deposit(\n    request: DeepPartial<MsgDeposit>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDepositResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.SubmitProposal = this.SubmitProposal.bind(this);\n    this.Vote = this.Vote.bind(this);\n    this.VoteWeighted = this.VoteWeighted.bind(this);\n    this.Deposit = this.Deposit.bind(this);\n  }\n\n  SubmitProposal(\n    request: DeepPartial<MsgSubmitProposal>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitProposalResponse> {\n    return this.rpc.unary(\n      MsgSubmitProposalDesc,\n      MsgSubmitProposal.fromPartial(request),\n      metadata\n    );\n  }\n\n  Vote(\n    request: DeepPartial<MsgVote>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteResponse> {\n    return this.rpc.unary(MsgVoteDesc, MsgVote.fromPartial(request), metadata);\n  }\n\n  VoteWeighted(\n    request: DeepPartial<MsgVoteWeighted>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteWeightedResponse> {\n    return this.rpc.unary(\n      MsgVoteWeightedDesc,\n      MsgVoteWeighted.fromPartial(request),\n      metadata\n    );\n  }\n\n  Deposit(\n    request: DeepPartial<MsgDeposit>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDepositResponse> {\n    return this.rpc.unary(\n      MsgDepositDesc,\n      MsgDeposit.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.gov.v1beta1.Msg\",\n};\n\nexport const MsgSubmitProposalDesc: UnaryMethodDefinitionish = {\n  methodName: \"SubmitProposal\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSubmitProposal.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSubmitProposalResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgVoteDesc: UnaryMethodDefinitionish = {\n  methodName: \"Vote\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVote.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVoteResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgVoteWeightedDesc: UnaryMethodDefinitionish = {\n  methodName: \"VoteWeighted\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVoteWeighted.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVoteWeightedResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDepositDesc: UnaryMethodDefinitionish = {\n  methodName: \"Deposit\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDeposit.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDepositResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from './BaseMsg';\nimport {\n  protobufPackage,\n  MsgSubmitProposal as MsgSubmitProposal_pb,\n  MsgVote as MsgVote_pb,\n  MsgVoteWeighted as MsgVoteWeighted_pb,\n  MsgDeposit as MsgDeposit_pb,\n} from \"../proto/cosmos/gov/v1beta1/tx\";\nimport {EncodeObject} from \"@cosmjs/proto-signing\";\n\nexport class MsgSubmitProposal extends BaseMsg {\n  public protoMsg: MsgSubmitProposal_pb;\n  constructor(msg: MsgSubmitProposal_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSubmitProposal.typeUrl,\n      value: MsgSubmitProposal_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSubmitProposal {\n  export const typeUrl: string = `/${protobufPackage}.MsgSubmitProposal`;\n  export const Proto = MsgSubmitProposal_pb;\n  export interface Proto extends MsgSubmitProposal_pb {}\n}\n\nexport class MsgDeposit extends BaseMsg {\n  public protoMsg: MsgDeposit_pb;\n  constructor(msg: MsgDeposit_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDeposit.typeUrl,\n      value: MsgDeposit_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDeposit {\n  export const typeUrl: string = `/${protobufPackage}.MsgDeposit`;\n  export const Proto = MsgDeposit_pb;\n  export interface Proto extends MsgDeposit_pb {}\n}\n\nexport class MsgVote extends BaseMsg {\n  public protoMsg: MsgVote_pb;\n  constructor(msg: MsgVote_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVote.typeUrl,\n      value: MsgVote_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVote {\n  export const typeUrl: string = `/${protobufPackage}.MsgVote`;\n  export const Proto = MsgVote_pb;\n  export interface Proto extends MsgVote_pb {}\n}\n\nexport class MsgVoteWeighted extends BaseMsg {\n  public protoMsg: MsgVoteWeighted_pb;\n  constructor(msg: MsgVoteWeighted_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVoteWeighted.typeUrl,\n      value: MsgVoteWeighted_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVoteWeighted {\n  export const typeUrl: string = `/${protobufPackage}.MsgVoteWeighted`;\n  export const Proto = MsgVoteWeighted_pb;\n  export interface Proto extends MsgVoteWeighted_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Duration } from \"../google/protobuf/duration\";\n\nexport const protobufPackage = \"metaoslabs.metaos.poolincentives\";\n\nexport interface RandSwapRewardSubConfig {\n  title: string;\n  /** the total reward of weight in hundredths of a bip, i.e. 1e-6 */\n  weight: number;\n  numberOfReveal: number;\n}\n\nexport interface RandSwapRewardConfig {\n  id: Long;\n  enabled: boolean;\n  intervalPeriod?: Duration;\n  mintable: boolean;\n  owner: string;\n  denom: string;\n  decimal: number;\n  totalReward: string;\n  subConfigs: RandSwapRewardSubConfig[];\n  pools: string[];\n}\n\nexport interface RandSwapRewardDenom {\n  denom: string;\n  configId: Long;\n}\n\nexport interface RandSwapRewardRound {\n  configId: Long;\n  round: Long;\n}\n\nexport interface RandSwapRewardRoundWithConfig {\n  configId: Long;\n  round: Long;\n  rewardConfig?: RandSwapRewardConfig;\n}\n\nexport interface RandSwapRewardRoundSequencer {\n  configId: Long;\n  round: Long;\n  sequence: Long;\n}\n\nexport interface RandSwapRewardRoundSequence {\n  configId: Long;\n  round: Long;\n  sequence: Long;\n  address: string;\n}\n\nexport interface RandSwapPoolReward {\n  address: string;\n  configIds: Long[];\n}\n\nexport interface RandSwapRewardReveal {\n  configId: Long;\n  round: Long;\n  config?: RandSwapRewardConfig;\n  subConfigEachReward: string[];\n  winnerSequences: Long[];\n}\n\nexport interface RandSwapAccountReward {\n  account: string;\n  denom: string;\n  amount: string;\n}\n\nexport interface RandSwapSequenceClear {\n  configId: Long;\n  round: Long;\n}\n\nfunction createBaseRandSwapRewardSubConfig(): RandSwapRewardSubConfig {\n  return { title: \"\", weight: 0, numberOfReveal: 0 };\n}\n\nexport const RandSwapRewardSubConfig = {\n  encode(\n    message: RandSwapRewardSubConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.weight !== 0) {\n      writer.uint32(16).int32(message.weight);\n    }\n    if (message.numberOfReveal !== 0) {\n      writer.uint32(24).uint32(message.numberOfReveal);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardSubConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardSubConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.weight = reader.int32();\n          break;\n        case 3:\n          message.numberOfReveal = reader.uint32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardSubConfig {\n    return {\n      title: isSet(object.title) ? String(object.title) : \"\",\n      weight: isSet(object.weight) ? Number(object.weight) : 0,\n      numberOfReveal: isSet(object.numberOfReveal)\n        ? Number(object.numberOfReveal)\n        : 0,\n    };\n  },\n\n  toJSON(message: RandSwapRewardSubConfig): unknown {\n    const obj: any = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.weight !== undefined && (obj.weight = Math.round(message.weight));\n    message.numberOfReveal !== undefined &&\n      (obj.numberOfReveal = Math.round(message.numberOfReveal));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardSubConfig>, I>>(\n    object: I\n  ): RandSwapRewardSubConfig {\n    const message = createBaseRandSwapRewardSubConfig();\n    message.title = object.title ?? \"\";\n    message.weight = object.weight ?? 0;\n    message.numberOfReveal = object.numberOfReveal ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardConfig(): RandSwapRewardConfig {\n  return {\n    id: Long.UZERO,\n    enabled: false,\n    intervalPeriod: undefined,\n    mintable: false,\n    owner: \"\",\n    denom: \"\",\n    decimal: 0,\n    totalReward: \"\",\n    subConfigs: [],\n    pools: [],\n  };\n}\n\nexport const RandSwapRewardConfig = {\n  encode(\n    message: RandSwapRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.id.isZero()) {\n      writer.uint32(8).uint64(message.id);\n    }\n    if (message.enabled === true) {\n      writer.uint32(16).bool(message.enabled);\n    }\n    if (message.intervalPeriod !== undefined) {\n      Duration.encode(\n        message.intervalPeriod,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    if (message.mintable === true) {\n      writer.uint32(32).bool(message.mintable);\n    }\n    if (message.owner !== \"\") {\n      writer.uint32(42).string(message.owner);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(50).string(message.denom);\n    }\n    if (message.decimal !== 0) {\n      writer.uint32(56).int32(message.decimal);\n    }\n    if (message.totalReward !== \"\") {\n      writer.uint32(66).string(message.totalReward);\n    }\n    for (const v of message.subConfigs) {\n      RandSwapRewardSubConfig.encode(v!, writer.uint32(74).fork()).ldelim();\n    }\n    for (const v of message.pools) {\n      writer.uint32(82).string(v!);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.uint64() as Long;\n          break;\n        case 2:\n          message.enabled = reader.bool();\n          break;\n        case 3:\n          message.intervalPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.mintable = reader.bool();\n          break;\n        case 5:\n          message.owner = reader.string();\n          break;\n        case 6:\n          message.denom = reader.string();\n          break;\n        case 7:\n          message.decimal = reader.int32();\n          break;\n        case 8:\n          message.totalReward = reader.string();\n          break;\n        case 9:\n          message.subConfigs.push(\n            RandSwapRewardSubConfig.decode(reader, reader.uint32())\n          );\n          break;\n        case 10:\n          message.pools.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardConfig {\n    return {\n      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,\n      intervalPeriod: isSet(object.intervalPeriod)\n        ? Duration.fromJSON(object.intervalPeriod)\n        : undefined,\n      mintable: isSet(object.mintable) ? Boolean(object.mintable) : false,\n      owner: isSet(object.owner) ? String(object.owner) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      decimal: isSet(object.decimal) ? Number(object.decimal) : 0,\n      totalReward: isSet(object.totalReward) ? String(object.totalReward) : \"\",\n      subConfigs: Array.isArray(object?.subConfigs)\n        ? object.subConfigs.map((e: any) => RandSwapRewardSubConfig.fromJSON(e))\n        : [],\n      pools: Array.isArray(object?.pools)\n        ? object.pools.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RandSwapRewardConfig): unknown {\n    const obj: any = {};\n    message.id !== undefined &&\n      (obj.id = (message.id || Long.UZERO).toString());\n    message.enabled !== undefined && (obj.enabled = message.enabled);\n    message.intervalPeriod !== undefined &&\n      (obj.intervalPeriod = message.intervalPeriod\n        ? Duration.toJSON(message.intervalPeriod)\n        : undefined);\n    message.mintable !== undefined && (obj.mintable = message.mintable);\n    message.owner !== undefined && (obj.owner = message.owner);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.decimal !== undefined &&\n      (obj.decimal = Math.round(message.decimal));\n    message.totalReward !== undefined &&\n      (obj.totalReward = message.totalReward);\n    if (message.subConfigs) {\n      obj.subConfigs = message.subConfigs.map((e) =>\n        e ? RandSwapRewardSubConfig.toJSON(e) : undefined\n      );\n    } else {\n      obj.subConfigs = [];\n    }\n    if (message.pools) {\n      obj.pools = message.pools.map((e) => e);\n    } else {\n      obj.pools = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardConfig>, I>>(\n    object: I\n  ): RandSwapRewardConfig {\n    const message = createBaseRandSwapRewardConfig();\n    message.id =\n      object.id !== undefined && object.id !== null\n        ? Long.fromValue(object.id)\n        : Long.UZERO;\n    message.enabled = object.enabled ?? false;\n    message.intervalPeriod =\n      object.intervalPeriod !== undefined && object.intervalPeriod !== null\n        ? Duration.fromPartial(object.intervalPeriod)\n        : undefined;\n    message.mintable = object.mintable ?? false;\n    message.owner = object.owner ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.decimal = object.decimal ?? 0;\n    message.totalReward = object.totalReward ?? \"\";\n    message.subConfigs =\n      object.subConfigs?.map((e) => RandSwapRewardSubConfig.fromPartial(e)) ||\n      [];\n    message.pools = object.pools?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardDenom(): RandSwapRewardDenom {\n  return { denom: \"\", configId: Long.UZERO };\n}\n\nexport const RandSwapRewardDenom = {\n  encode(\n    message: RandSwapRewardDenom,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RandSwapRewardDenom {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardDenom();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardDenom {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapRewardDenom): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardDenom>, I>>(\n    object: I\n  ): RandSwapRewardDenom {\n    const message = createBaseRandSwapRewardDenom();\n    message.denom = object.denom ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRound(): RandSwapRewardRound {\n  return { configId: Long.UZERO, round: Long.UZERO };\n}\n\nexport const RandSwapRewardRound = {\n  encode(\n    message: RandSwapRewardRound,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RandSwapRewardRound {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRound();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRound {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapRewardRound): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRound>, I>>(\n    object: I\n  ): RandSwapRewardRound {\n    const message = createBaseRandSwapRewardRound();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRoundWithConfig(): RandSwapRewardRoundWithConfig {\n  return { configId: Long.UZERO, round: Long.UZERO, rewardConfig: undefined };\n}\n\nexport const RandSwapRewardRoundWithConfig = {\n  encode(\n    message: RandSwapRewardRoundWithConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (message.rewardConfig !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.rewardConfig,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardRoundWithConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRoundWithConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.rewardConfig = RandSwapRewardConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRoundWithConfig {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      rewardConfig: isSet(object.rewardConfig)\n        ? RandSwapRewardConfig.fromJSON(object.rewardConfig)\n        : undefined,\n    };\n  },\n\n  toJSON(message: RandSwapRewardRoundWithConfig): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.rewardConfig !== undefined &&\n      (obj.rewardConfig = message.rewardConfig\n        ? RandSwapRewardConfig.toJSON(message.rewardConfig)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRoundWithConfig>, I>>(\n    object: I\n  ): RandSwapRewardRoundWithConfig {\n    const message = createBaseRandSwapRewardRoundWithConfig();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.rewardConfig =\n      object.rewardConfig !== undefined && object.rewardConfig !== null\n        ? RandSwapRewardConfig.fromPartial(object.rewardConfig)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRoundSequencer(): RandSwapRewardRoundSequencer {\n  return { configId: Long.UZERO, round: Long.UZERO, sequence: Long.UZERO };\n}\n\nexport const RandSwapRewardRoundSequencer = {\n  encode(\n    message: RandSwapRewardRoundSequencer,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardRoundSequencer {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRoundSequencer();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRoundSequencer {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapRewardRoundSequencer): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRoundSequencer>, I>>(\n    object: I\n  ): RandSwapRewardRoundSequencer {\n    const message = createBaseRandSwapRewardRoundSequencer();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardRoundSequence(): RandSwapRewardRoundSequence {\n  return {\n    configId: Long.UZERO,\n    round: Long.UZERO,\n    sequence: Long.UZERO,\n    address: \"\",\n  };\n}\n\nexport const RandSwapRewardRoundSequence = {\n  encode(\n    message: RandSwapRewardRoundSequence,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(34).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardRoundSequence {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardRoundSequence();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        case 4:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardRoundSequence {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: RandSwapRewardRoundSequence): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardRoundSequence>, I>>(\n    object: I\n  ): RandSwapRewardRoundSequence {\n    const message = createBaseRandSwapRewardRoundSequence();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRandSwapPoolReward(): RandSwapPoolReward {\n  return { address: \"\", configIds: [] };\n}\n\nexport const RandSwapPoolReward = {\n  encode(\n    message: RandSwapPoolReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    writer.uint32(18).fork();\n    for (const v of message.configIds) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RandSwapPoolReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapPoolReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.configIds.push(reader.uint64() as Long);\n            }\n          } else {\n            message.configIds.push(reader.uint64() as Long);\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapPoolReward {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      configIds: Array.isArray(object?.configIds)\n        ? object.configIds.map((e: any) => Long.fromValue(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RandSwapPoolReward): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.configIds) {\n      obj.configIds = message.configIds.map((e) =>\n        (e || Long.UZERO).toString()\n      );\n    } else {\n      obj.configIds = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapPoolReward>, I>>(\n    object: I\n  ): RandSwapPoolReward {\n    const message = createBaseRandSwapPoolReward();\n    message.address = object.address ?? \"\";\n    message.configIds = object.configIds?.map((e) => Long.fromValue(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseRandSwapRewardReveal(): RandSwapRewardReveal {\n  return {\n    configId: Long.UZERO,\n    round: Long.UZERO,\n    config: undefined,\n    subConfigEachReward: [],\n    winnerSequences: [],\n  };\n}\n\nexport const RandSwapRewardReveal = {\n  encode(\n    message: RandSwapRewardReveal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    if (message.config !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.config,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    for (const v of message.subConfigEachReward) {\n      writer.uint32(34).string(v!);\n    }\n    writer.uint32(42).fork();\n    for (const v of message.winnerSequences) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapRewardReveal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapRewardReveal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        case 3:\n          message.config = RandSwapRewardConfig.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.subConfigEachReward.push(reader.string());\n          break;\n        case 5:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.winnerSequences.push(reader.uint64() as Long);\n            }\n          } else {\n            message.winnerSequences.push(reader.uint64() as Long);\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapRewardReveal {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n      config: isSet(object.config)\n        ? RandSwapRewardConfig.fromJSON(object.config)\n        : undefined,\n      subConfigEachReward: Array.isArray(object?.subConfigEachReward)\n        ? object.subConfigEachReward.map((e: any) => String(e))\n        : [],\n      winnerSequences: Array.isArray(object?.winnerSequences)\n        ? object.winnerSequences.map((e: any) => Long.fromValue(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RandSwapRewardReveal): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? RandSwapRewardConfig.toJSON(message.config)\n        : undefined);\n    if (message.subConfigEachReward) {\n      obj.subConfigEachReward = message.subConfigEachReward.map((e) => e);\n    } else {\n      obj.subConfigEachReward = [];\n    }\n    if (message.winnerSequences) {\n      obj.winnerSequences = message.winnerSequences.map((e) =>\n        (e || Long.UZERO).toString()\n      );\n    } else {\n      obj.winnerSequences = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapRewardReveal>, I>>(\n    object: I\n  ): RandSwapRewardReveal {\n    const message = createBaseRandSwapRewardReveal();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? RandSwapRewardConfig.fromPartial(object.config)\n        : undefined;\n    message.subConfigEachReward =\n      object.subConfigEachReward?.map((e) => e) || [];\n    message.winnerSequences =\n      object.winnerSequences?.map((e) => Long.fromValue(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseRandSwapAccountReward(): RandSwapAccountReward {\n  return { account: \"\", denom: \"\", amount: \"\" };\n}\n\nexport const RandSwapAccountReward = {\n  encode(\n    message: RandSwapAccountReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.account !== \"\") {\n      writer.uint32(10).string(message.account);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(18).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(26).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapAccountReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapAccountReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.account = reader.string();\n          break;\n        case 2:\n          message.denom = reader.string();\n          break;\n        case 3:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapAccountReward {\n    return {\n      account: isSet(object.account) ? String(object.account) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: RandSwapAccountReward): unknown {\n    const obj: any = {};\n    message.account !== undefined && (obj.account = message.account);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapAccountReward>, I>>(\n    object: I\n  ): RandSwapAccountReward {\n    const message = createBaseRandSwapAccountReward();\n    message.account = object.account ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRandSwapSequenceClear(): RandSwapSequenceClear {\n  return { configId: Long.UZERO, round: Long.UZERO };\n}\n\nexport const RandSwapSequenceClear = {\n  encode(\n    message: RandSwapSequenceClear,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.configId.isZero()) {\n      writer.uint32(8).uint64(message.configId);\n    }\n    if (!message.round.isZero()) {\n      writer.uint32(16).uint64(message.round);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RandSwapSequenceClear {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRandSwapSequenceClear();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.round = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RandSwapSequenceClear {\n    return {\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      round: isSet(object.round) ? Long.fromValue(object.round) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: RandSwapSequenceClear): unknown {\n    const obj: any = {};\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.round !== undefined &&\n      (obj.round = (message.round || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RandSwapSequenceClear>, I>>(\n    object: I\n  ): RandSwapSequenceClear {\n    const message = createBaseRandSwapSequenceClear();\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.round =\n      object.round !== undefined && object.round !== null\n        ? Long.fromValue(object.round)\n        : Long.UZERO;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"metaoslabs.metaos.poolincentives\";\n\nexport interface LiquidityRewardSubConfig {\n  /** the pool address */\n  address: string;\n  /** the total reward of weight in hundredths of a bip, i.e. 1e-6 */\n  weight: number;\n  /** the index of reward configs */\n  index: number;\n}\n\nexport interface LiquidityRewardConfig {\n  id: Long;\n  enabled: boolean;\n  mintable: boolean;\n  owner: string;\n  denom: string;\n  decimal: number;\n  totalRewardPerDay: string;\n  subConfigs: LiquidityRewardSubConfig[];\n}\n\nexport interface LiquidityRewardDenom {\n  denom: string;\n  configId: Long;\n}\n\nexport interface LiquidityPoolReward {\n  address: string;\n  configIds: Long[];\n}\n\nfunction createBaseLiquidityRewardSubConfig(): LiquidityRewardSubConfig {\n  return { address: \"\", weight: 0, index: 0 };\n}\n\nexport const LiquidityRewardSubConfig = {\n  encode(\n    message: LiquidityRewardSubConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    if (message.weight !== 0) {\n      writer.uint32(16).int32(message.weight);\n    }\n    if (message.index !== 0) {\n      writer.uint32(24).uint32(message.index);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): LiquidityRewardSubConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityRewardSubConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.weight = reader.int32();\n          break;\n        case 3:\n          message.index = reader.uint32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityRewardSubConfig {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      weight: isSet(object.weight) ? Number(object.weight) : 0,\n      index: isSet(object.index) ? Number(object.index) : 0,\n    };\n  },\n\n  toJSON(message: LiquidityRewardSubConfig): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    message.weight !== undefined && (obj.weight = Math.round(message.weight));\n    message.index !== undefined && (obj.index = Math.round(message.index));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityRewardSubConfig>, I>>(\n    object: I\n  ): LiquidityRewardSubConfig {\n    const message = createBaseLiquidityRewardSubConfig();\n    message.address = object.address ?? \"\";\n    message.weight = object.weight ?? 0;\n    message.index = object.index ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseLiquidityRewardConfig(): LiquidityRewardConfig {\n  return {\n    id: Long.UZERO,\n    enabled: false,\n    mintable: false,\n    owner: \"\",\n    denom: \"\",\n    decimal: 0,\n    totalRewardPerDay: \"\",\n    subConfigs: [],\n  };\n}\n\nexport const LiquidityRewardConfig = {\n  encode(\n    message: LiquidityRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.id.isZero()) {\n      writer.uint32(8).uint64(message.id);\n    }\n    if (message.enabled === true) {\n      writer.uint32(16).bool(message.enabled);\n    }\n    if (message.mintable === true) {\n      writer.uint32(24).bool(message.mintable);\n    }\n    if (message.owner !== \"\") {\n      writer.uint32(34).string(message.owner);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(42).string(message.denom);\n    }\n    if (message.decimal !== 0) {\n      writer.uint32(48).int32(message.decimal);\n    }\n    if (message.totalRewardPerDay !== \"\") {\n      writer.uint32(58).string(message.totalRewardPerDay);\n    }\n    for (const v of message.subConfigs) {\n      LiquidityRewardSubConfig.encode(v!, writer.uint32(66).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): LiquidityRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.uint64() as Long;\n          break;\n        case 2:\n          message.enabled = reader.bool();\n          break;\n        case 3:\n          message.mintable = reader.bool();\n          break;\n        case 4:\n          message.owner = reader.string();\n          break;\n        case 5:\n          message.denom = reader.string();\n          break;\n        case 6:\n          message.decimal = reader.int32();\n          break;\n        case 7:\n          message.totalRewardPerDay = reader.string();\n          break;\n        case 8:\n          message.subConfigs.push(\n            LiquidityRewardSubConfig.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityRewardConfig {\n    return {\n      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,\n      mintable: isSet(object.mintable) ? Boolean(object.mintable) : false,\n      owner: isSet(object.owner) ? String(object.owner) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      decimal: isSet(object.decimal) ? Number(object.decimal) : 0,\n      totalRewardPerDay: isSet(object.totalRewardPerDay)\n        ? String(object.totalRewardPerDay)\n        : \"\",\n      subConfigs: Array.isArray(object?.subConfigs)\n        ? object.subConfigs.map((e: any) =>\n            LiquidityRewardSubConfig.fromJSON(e)\n          )\n        : [],\n    };\n  },\n\n  toJSON(message: LiquidityRewardConfig): unknown {\n    const obj: any = {};\n    message.id !== undefined &&\n      (obj.id = (message.id || Long.UZERO).toString());\n    message.enabled !== undefined && (obj.enabled = message.enabled);\n    message.mintable !== undefined && (obj.mintable = message.mintable);\n    message.owner !== undefined && (obj.owner = message.owner);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.decimal !== undefined &&\n      (obj.decimal = Math.round(message.decimal));\n    message.totalRewardPerDay !== undefined &&\n      (obj.totalRewardPerDay = message.totalRewardPerDay);\n    if (message.subConfigs) {\n      obj.subConfigs = message.subConfigs.map((e) =>\n        e ? LiquidityRewardSubConfig.toJSON(e) : undefined\n      );\n    } else {\n      obj.subConfigs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityRewardConfig>, I>>(\n    object: I\n  ): LiquidityRewardConfig {\n    const message = createBaseLiquidityRewardConfig();\n    message.id =\n      object.id !== undefined && object.id !== null\n        ? Long.fromValue(object.id)\n        : Long.UZERO;\n    message.enabled = object.enabled ?? false;\n    message.mintable = object.mintable ?? false;\n    message.owner = object.owner ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.decimal = object.decimal ?? 0;\n    message.totalRewardPerDay = object.totalRewardPerDay ?? \"\";\n    message.subConfigs =\n      object.subConfigs?.map((e) => LiquidityRewardSubConfig.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\nfunction createBaseLiquidityRewardDenom(): LiquidityRewardDenom {\n  return { denom: \"\", configId: Long.UZERO };\n}\n\nexport const LiquidityRewardDenom = {\n  encode(\n    message: LiquidityRewardDenom,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): LiquidityRewardDenom {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityRewardDenom();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityRewardDenom {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: LiquidityRewardDenom): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityRewardDenom>, I>>(\n    object: I\n  ): LiquidityRewardDenom {\n    const message = createBaseLiquidityRewardDenom();\n    message.denom = object.denom ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseLiquidityPoolReward(): LiquidityPoolReward {\n  return { address: \"\", configIds: [] };\n}\n\nexport const LiquidityPoolReward = {\n  encode(\n    message: LiquidityPoolReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    writer.uint32(18).fork();\n    for (const v of message.configIds) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): LiquidityPoolReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLiquidityPoolReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.configIds.push(reader.uint64() as Long);\n            }\n          } else {\n            message.configIds.push(reader.uint64() as Long);\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LiquidityPoolReward {\n    return {\n      address: isSet(object.address) ? String(object.address) : \"\",\n      configIds: Array.isArray(object?.configIds)\n        ? object.configIds.map((e: any) => Long.fromValue(e))\n        : [],\n    };\n  },\n\n  toJSON(message: LiquidityPoolReward): unknown {\n    const obj: any = {};\n    message.address !== undefined && (obj.address = message.address);\n    if (message.configIds) {\n      obj.configIds = message.configIds.map((e) =>\n        (e || Long.UZERO).toString()\n      );\n    } else {\n      obj.configIds = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LiquidityPoolReward>, I>>(\n    object: I\n  ): LiquidityPoolReward {\n    const message = createBaseLiquidityPoolReward();\n    message.address = object.address ?? \"\";\n    message.configIds = object.configIds?.map((e) => Long.fromValue(e)) || [];\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { RandSwapRewardConfig } from \"./rand_swap_reward\";\nimport { LiquidityRewardConfig } from \"./liquidity_reward\";\nimport { BrowserHeaders } from \"browser-headers\";\n\nexport const protobufPackage = \"metaoslabs.metaos.poolincentives\";\n\nexport interface MsgCreateRandSwapRewardConfig {\n  creator: string;\n  config?: RandSwapRewardConfig;\n}\n\nexport interface MsgCreateRandSwapRewardConfigResponse {}\n\nexport interface MsgOpenRandSwapReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgOpenRandSwapRewardResponse {}\n\nexport interface MsgCloseRandSwapReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgCloseRandSwapRewardResponse {}\n\nexport interface MsgUpdateRandSwapRewardConfig {\n  creator: string;\n  configId: Long;\n  config?: RandSwapRewardConfig;\n}\n\nexport interface MsgUpdateRandSwapRewardConfigResponse {}\n\nexport interface MsgCollectRandSwapReward {\n  creator: string;\n  denom: string;\n  recipient: string;\n}\n\nexport interface MsgCollectRandSwapRewardResponse {}\n\nexport interface MsgCreateLiquidityRewardConfig {\n  creator: string;\n  config?: LiquidityRewardConfig;\n}\n\nexport interface MsgCreateLiquidityRewardConfigResponse {}\n\nexport interface MsgUpdateLiquidityRewardConfig {\n  creator: string;\n  configId: Long;\n  config?: LiquidityRewardConfig;\n}\n\nexport interface MsgUpdateLiquidityRewardConfigResponse {}\n\nexport interface MsgOpenLiquidityReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgOpenLiquidityRewardResponse {}\n\nexport interface MsgCloseLiquidityReward {\n  creator: string;\n  configId: Long;\n}\n\nexport interface MsgCloseLiquidityRewardResponse {}\n\nfunction createBaseMsgCreateRandSwapRewardConfig(): MsgCreateRandSwapRewardConfig {\n  return { creator: \"\", config: undefined };\n}\n\nexport const MsgCreateRandSwapRewardConfig = {\n  encode(\n    message: MsgCreateRandSwapRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.config !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.config,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateRandSwapRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateRandSwapRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.config = RandSwapRewardConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateRandSwapRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      config: isSet(object.config)\n        ? RandSwapRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateRandSwapRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? RandSwapRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateRandSwapRewardConfig>, I>>(\n    object: I\n  ): MsgCreateRandSwapRewardConfig {\n    const message = createBaseMsgCreateRandSwapRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? RandSwapRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateRandSwapRewardConfigResponse(): MsgCreateRandSwapRewardConfigResponse {\n  return {};\n}\n\nexport const MsgCreateRandSwapRewardConfigResponse = {\n  encode(\n    _: MsgCreateRandSwapRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateRandSwapRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateRandSwapRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateRandSwapRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateRandSwapRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgCreateRandSwapRewardConfigResponse>, I>\n  >(_: I): MsgCreateRandSwapRewardConfigResponse {\n    const message = createBaseMsgCreateRandSwapRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenRandSwapReward(): MsgOpenRandSwapReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgOpenRandSwapReward = {\n  encode(\n    message: MsgOpenRandSwapReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenRandSwapReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenRandSwapReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgOpenRandSwapReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgOpenRandSwapReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenRandSwapReward>, I>>(\n    object: I\n  ): MsgOpenRandSwapReward {\n    const message = createBaseMsgOpenRandSwapReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenRandSwapRewardResponse(): MsgOpenRandSwapRewardResponse {\n  return {};\n}\n\nexport const MsgOpenRandSwapRewardResponse = {\n  encode(\n    _: MsgOpenRandSwapRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenRandSwapRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenRandSwapRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgOpenRandSwapRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgOpenRandSwapRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenRandSwapRewardResponse>, I>>(\n    _: I\n  ): MsgOpenRandSwapRewardResponse {\n    const message = createBaseMsgOpenRandSwapRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseRandSwapReward(): MsgCloseRandSwapReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgCloseRandSwapReward = {\n  encode(\n    message: MsgCloseRandSwapReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseRandSwapReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseRandSwapReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCloseRandSwapReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgCloseRandSwapReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseRandSwapReward>, I>>(\n    object: I\n  ): MsgCloseRandSwapReward {\n    const message = createBaseMsgCloseRandSwapReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseRandSwapRewardResponse(): MsgCloseRandSwapRewardResponse {\n  return {};\n}\n\nexport const MsgCloseRandSwapRewardResponse = {\n  encode(\n    _: MsgCloseRandSwapRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseRandSwapRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseRandSwapRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCloseRandSwapRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCloseRandSwapRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseRandSwapRewardResponse>, I>>(\n    _: I\n  ): MsgCloseRandSwapRewardResponse {\n    const message = createBaseMsgCloseRandSwapRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateRandSwapRewardConfig(): MsgUpdateRandSwapRewardConfig {\n  return { creator: \"\", configId: Long.UZERO, config: undefined };\n}\n\nexport const MsgUpdateRandSwapRewardConfig = {\n  encode(\n    message: MsgUpdateRandSwapRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    if (message.config !== undefined) {\n      RandSwapRewardConfig.encode(\n        message.config,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateRandSwapRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateRandSwapRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 3:\n          message.config = RandSwapRewardConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUpdateRandSwapRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      config: isSet(object.config)\n        ? RandSwapRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUpdateRandSwapRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? RandSwapRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUpdateRandSwapRewardConfig>, I>>(\n    object: I\n  ): MsgUpdateRandSwapRewardConfig {\n    const message = createBaseMsgUpdateRandSwapRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? RandSwapRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateRandSwapRewardConfigResponse(): MsgUpdateRandSwapRewardConfigResponse {\n  return {};\n}\n\nexport const MsgUpdateRandSwapRewardConfigResponse = {\n  encode(\n    _: MsgUpdateRandSwapRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateRandSwapRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateRandSwapRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgUpdateRandSwapRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgUpdateRandSwapRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgUpdateRandSwapRewardConfigResponse>, I>\n  >(_: I): MsgUpdateRandSwapRewardConfigResponse {\n    const message = createBaseMsgUpdateRandSwapRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRandSwapReward(): MsgCollectRandSwapReward {\n  return { creator: \"\", denom: \"\", recipient: \"\" };\n}\n\nexport const MsgCollectRandSwapReward = {\n  encode(\n    message: MsgCollectRandSwapReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom !== \"\") {\n      writer.uint32(18).string(message.denom);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRandSwapReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRandSwapReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectRandSwapReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCollectRandSwapReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectRandSwapReward>, I>>(\n    object: I\n  ): MsgCollectRandSwapReward {\n    const message = createBaseMsgCollectRandSwapReward();\n    message.creator = object.creator ?? \"\";\n    message.denom = object.denom ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRandSwapRewardResponse(): MsgCollectRandSwapRewardResponse {\n  return {};\n}\n\nexport const MsgCollectRandSwapRewardResponse = {\n  encode(\n    _: MsgCollectRandSwapRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRandSwapRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRandSwapRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectRandSwapRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectRandSwapRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgCollectRandSwapRewardResponse>, I>\n  >(_: I): MsgCollectRandSwapRewardResponse {\n    const message = createBaseMsgCollectRandSwapRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateLiquidityRewardConfig(): MsgCreateLiquidityRewardConfig {\n  return { creator: \"\", config: undefined };\n}\n\nexport const MsgCreateLiquidityRewardConfig = {\n  encode(\n    message: MsgCreateLiquidityRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.config !== undefined) {\n      LiquidityRewardConfig.encode(\n        message.config,\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateLiquidityRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateLiquidityRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 3:\n          message.config = LiquidityRewardConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateLiquidityRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      config: isSet(object.config)\n        ? LiquidityRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateLiquidityRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? LiquidityRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateLiquidityRewardConfig>, I>>(\n    object: I\n  ): MsgCreateLiquidityRewardConfig {\n    const message = createBaseMsgCreateLiquidityRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? LiquidityRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateLiquidityRewardConfigResponse(): MsgCreateLiquidityRewardConfigResponse {\n  return {};\n}\n\nexport const MsgCreateLiquidityRewardConfigResponse = {\n  encode(\n    _: MsgCreateLiquidityRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateLiquidityRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateLiquidityRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateLiquidityRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateLiquidityRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgCreateLiquidityRewardConfigResponse>, I>\n  >(_: I): MsgCreateLiquidityRewardConfigResponse {\n    const message = createBaseMsgCreateLiquidityRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateLiquidityRewardConfig(): MsgUpdateLiquidityRewardConfig {\n  return { creator: \"\", configId: Long.UZERO, config: undefined };\n}\n\nexport const MsgUpdateLiquidityRewardConfig = {\n  encode(\n    message: MsgUpdateLiquidityRewardConfig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    if (message.config !== undefined) {\n      LiquidityRewardConfig.encode(\n        message.config,\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateLiquidityRewardConfig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateLiquidityRewardConfig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        case 4:\n          message.config = LiquidityRewardConfig.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUpdateLiquidityRewardConfig {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n      config: isSet(object.config)\n        ? LiquidityRewardConfig.fromJSON(object.config)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUpdateLiquidityRewardConfig): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    message.config !== undefined &&\n      (obj.config = message.config\n        ? LiquidityRewardConfig.toJSON(message.config)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUpdateLiquidityRewardConfig>, I>>(\n    object: I\n  ): MsgUpdateLiquidityRewardConfig {\n    const message = createBaseMsgUpdateLiquidityRewardConfig();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    message.config =\n      object.config !== undefined && object.config !== null\n        ? LiquidityRewardConfig.fromPartial(object.config)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUpdateLiquidityRewardConfigResponse(): MsgUpdateLiquidityRewardConfigResponse {\n  return {};\n}\n\nexport const MsgUpdateLiquidityRewardConfigResponse = {\n  encode(\n    _: MsgUpdateLiquidityRewardConfigResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUpdateLiquidityRewardConfigResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUpdateLiquidityRewardConfigResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgUpdateLiquidityRewardConfigResponse {\n    return {};\n  },\n\n  toJSON(_: MsgUpdateLiquidityRewardConfigResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<\n    I extends Exact<DeepPartial<MsgUpdateLiquidityRewardConfigResponse>, I>\n  >(_: I): MsgUpdateLiquidityRewardConfigResponse {\n    const message = createBaseMsgUpdateLiquidityRewardConfigResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenLiquidityReward(): MsgOpenLiquidityReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgOpenLiquidityReward = {\n  encode(\n    message: MsgOpenLiquidityReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenLiquidityReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenLiquidityReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgOpenLiquidityReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgOpenLiquidityReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenLiquidityReward>, I>>(\n    object: I\n  ): MsgOpenLiquidityReward {\n    const message = createBaseMsgOpenLiquidityReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgOpenLiquidityRewardResponse(): MsgOpenLiquidityRewardResponse {\n  return {};\n}\n\nexport const MsgOpenLiquidityRewardResponse = {\n  encode(\n    _: MsgOpenLiquidityRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgOpenLiquidityRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgOpenLiquidityRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgOpenLiquidityRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgOpenLiquidityRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgOpenLiquidityRewardResponse>, I>>(\n    _: I\n  ): MsgOpenLiquidityRewardResponse {\n    const message = createBaseMsgOpenLiquidityRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseLiquidityReward(): MsgCloseLiquidityReward {\n  return { creator: \"\", configId: Long.UZERO };\n}\n\nexport const MsgCloseLiquidityReward = {\n  encode(\n    message: MsgCloseLiquidityReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (!message.configId.isZero()) {\n      writer.uint32(16).uint64(message.configId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseLiquidityReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseLiquidityReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.configId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCloseLiquidityReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      configId: isSet(object.configId)\n        ? Long.fromValue(object.configId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgCloseLiquidityReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.configId !== undefined &&\n      (obj.configId = (message.configId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseLiquidityReward>, I>>(\n    object: I\n  ): MsgCloseLiquidityReward {\n    const message = createBaseMsgCloseLiquidityReward();\n    message.creator = object.creator ?? \"\";\n    message.configId =\n      object.configId !== undefined && object.configId !== null\n        ? Long.fromValue(object.configId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgCloseLiquidityRewardResponse(): MsgCloseLiquidityRewardResponse {\n  return {};\n}\n\nexport const MsgCloseLiquidityRewardResponse = {\n  encode(\n    _: MsgCloseLiquidityRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCloseLiquidityRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCloseLiquidityRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCloseLiquidityRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCloseLiquidityRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCloseLiquidityRewardResponse>, I>>(\n    _: I\n  ): MsgCloseLiquidityRewardResponse {\n    const message = createBaseMsgCloseLiquidityRewardResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  CreateRandSwapRewardConfig(\n    request: DeepPartial<MsgCreateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateRandSwapRewardConfigResponse>;\n  UpdateRandSwapRewardConfig(\n    request: DeepPartial<MsgUpdateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateRandSwapRewardConfigResponse>;\n  OpenRandSwapReward(\n    request: DeepPartial<MsgOpenRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenRandSwapRewardResponse>;\n  CloseRandSwapReward(\n    request: DeepPartial<MsgCloseRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseRandSwapRewardResponse>;\n  CollectRandSwapReward(\n    request: DeepPartial<MsgCollectRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRandSwapRewardResponse>;\n  CreateLiquidityRewardConfig(\n    request: DeepPartial<MsgCreateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateLiquidityRewardConfigResponse>;\n  UpdateLiquidityRewardConfig(\n    request: DeepPartial<MsgUpdateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateLiquidityRewardConfigResponse>;\n  OpenLiquidityReward(\n    request: DeepPartial<MsgOpenLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenLiquidityRewardResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  CloseLiquidityReward(\n    request: DeepPartial<MsgCloseLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseLiquidityRewardResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreateRandSwapRewardConfig =\n      this.CreateRandSwapRewardConfig.bind(this);\n    this.UpdateRandSwapRewardConfig =\n      this.UpdateRandSwapRewardConfig.bind(this);\n    this.OpenRandSwapReward = this.OpenRandSwapReward.bind(this);\n    this.CloseRandSwapReward = this.CloseRandSwapReward.bind(this);\n    this.CollectRandSwapReward = this.CollectRandSwapReward.bind(this);\n    this.CreateLiquidityRewardConfig =\n      this.CreateLiquidityRewardConfig.bind(this);\n    this.UpdateLiquidityRewardConfig =\n      this.UpdateLiquidityRewardConfig.bind(this);\n    this.OpenLiquidityReward = this.OpenLiquidityReward.bind(this);\n    this.CloseLiquidityReward = this.CloseLiquidityReward.bind(this);\n  }\n\n  CreateRandSwapRewardConfig(\n    request: DeepPartial<MsgCreateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateRandSwapRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgCreateRandSwapRewardConfigDesc,\n      MsgCreateRandSwapRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  UpdateRandSwapRewardConfig(\n    request: DeepPartial<MsgUpdateRandSwapRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateRandSwapRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgUpdateRandSwapRewardConfigDesc,\n      MsgUpdateRandSwapRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  OpenRandSwapReward(\n    request: DeepPartial<MsgOpenRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenRandSwapRewardResponse> {\n    return this.rpc.unary(\n      MsgOpenRandSwapRewardDesc,\n      MsgOpenRandSwapReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CloseRandSwapReward(\n    request: DeepPartial<MsgCloseRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseRandSwapRewardResponse> {\n    return this.rpc.unary(\n      MsgCloseRandSwapRewardDesc,\n      MsgCloseRandSwapReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectRandSwapReward(\n    request: DeepPartial<MsgCollectRandSwapReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRandSwapRewardResponse> {\n    return this.rpc.unary(\n      MsgCollectRandSwapRewardDesc,\n      MsgCollectRandSwapReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CreateLiquidityRewardConfig(\n    request: DeepPartial<MsgCreateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateLiquidityRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgCreateLiquidityRewardConfigDesc,\n      MsgCreateLiquidityRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  UpdateLiquidityRewardConfig(\n    request: DeepPartial<MsgUpdateLiquidityRewardConfig>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUpdateLiquidityRewardConfigResponse> {\n    return this.rpc.unary(\n      MsgUpdateLiquidityRewardConfigDesc,\n      MsgUpdateLiquidityRewardConfig.fromPartial(request),\n      metadata\n    );\n  }\n\n  OpenLiquidityReward(\n    request: DeepPartial<MsgOpenLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgOpenLiquidityRewardResponse> {\n    return this.rpc.unary(\n      MsgOpenLiquidityRewardDesc,\n      MsgOpenLiquidityReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CloseLiquidityReward(\n    request: DeepPartial<MsgCloseLiquidityReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCloseLiquidityRewardResponse> {\n    return this.rpc.unary(\n      MsgCloseLiquidityRewardDesc,\n      MsgCloseLiquidityReward.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"metaoslabs.metaos.poolincentives.Msg\",\n};\n\nexport const MsgCreateRandSwapRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateRandSwapRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateRandSwapRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateRandSwapRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUpdateRandSwapRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"UpdateRandSwapRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUpdateRandSwapRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUpdateRandSwapRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgOpenRandSwapRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"OpenRandSwapReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgOpenRandSwapReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgOpenRandSwapRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCloseRandSwapRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CloseRandSwapReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCloseRandSwapReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCloseRandSwapRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectRandSwapRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectRandSwapReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectRandSwapReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectRandSwapRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCreateLiquidityRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateLiquidityRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateLiquidityRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateLiquidityRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUpdateLiquidityRewardConfigDesc: UnaryMethodDefinitionish = {\n  methodName: \"UpdateLiquidityRewardConfig\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUpdateLiquidityRewardConfig.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUpdateLiquidityRewardConfigResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgOpenLiquidityRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"OpenLiquidityReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgOpenLiquidityReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgOpenLiquidityRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCloseLiquidityRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CloseLiquidityReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCloseLiquidityReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCloseLiquidityRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import {\n  MsgCreateRandSwapRewardConfig as MsgCreateRandSwapRewardConfig_pb,\n  MsgCloseRandSwapReward as MsgCloseRandSwapReward_pb,\n  MsgUpdateRandSwapRewardConfig as MsgUpdateRandSwapRewardConfig_pb,\n  MsgCollectRandSwapReward as MsgCollectRandSwapReward_pb,\n  MsgUpdateLiquidityRewardConfig as MsgUpdateLiquidityRewardConfig_pb,\n  MsgCloseLiquidityReward as MsgCloseLiquidityReward_pb,\n  protobufPackage,\n} from \"../proto/pool-incentives/tx\";\nimport { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\n\nexport class MsgCreateRandSwapRewardConfig extends BaseMsg {\n  public protoMsg: MsgCreateRandSwapRewardConfig_pb;\n  constructor(msg: MsgCreateRandSwapRewardConfig_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateRandSwapRewardConfig.typeUrl,\n      value: MsgCreateRandSwapRewardConfig_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreateRandSwapRewardConfig {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreateRandSwapRewardConfig`;\n  export const Proto = MsgCreateRandSwapRewardConfig_pb;\n  export interface Proto extends MsgCreateRandSwapRewardConfig_pb {}\n}\n\nexport class MsgCollectRandSwapReward extends BaseMsg {\n  public protoMsg: MsgCollectRandSwapReward_pb;\n  constructor(msg: MsgCollectRandSwapReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollectRandSwapReward.typeUrl,\n      value: MsgCollectRandSwapReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectRandSwapReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectRandSwapReward`;\n  export const Proto = MsgCollectRandSwapReward_pb;\n  export interface Proto extends MsgCollectRandSwapReward_pb {}\n}\n\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Proof } from \"../crypto/proof\";\nimport { Consensus } from \"../version/types\";\nimport { ValidatorSet } from \"./validator\";\nimport { Timestamp } from \"../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"tendermint.types\";\n\n/** BlockIdFlag indicates which BlcokID the signature is for */\nexport enum BlockIDFlag {\n  BLOCK_ID_FLAG_UNKNOWN = 0,\n  BLOCK_ID_FLAG_ABSENT = 1,\n  BLOCK_ID_FLAG_COMMIT = 2,\n  BLOCK_ID_FLAG_NIL = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function blockIDFlagFromJSON(object: any): BlockIDFlag {\n  switch (object) {\n    case 0:\n    case \"BLOCK_ID_FLAG_UNKNOWN\":\n      return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n    case 1:\n    case \"BLOCK_ID_FLAG_ABSENT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n    case 2:\n    case \"BLOCK_ID_FLAG_COMMIT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n    case 3:\n    case \"BLOCK_ID_FLAG_NIL\":\n      return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BlockIDFlag.UNRECOGNIZED;\n  }\n}\n\nexport function blockIDFlagToJSON(object: BlockIDFlag): string {\n  switch (object) {\n    case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:\n      return \"BLOCK_ID_FLAG_UNKNOWN\";\n    case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:\n      return \"BLOCK_ID_FLAG_ABSENT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:\n      return \"BLOCK_ID_FLAG_COMMIT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_NIL:\n      return \"BLOCK_ID_FLAG_NIL\";\n    case BlockIDFlag.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignedMsgType is a type of signed message in the consensus. */\nexport enum SignedMsgType {\n  SIGNED_MSG_TYPE_UNKNOWN = 0,\n  /** SIGNED_MSG_TYPE_PREVOTE - Votes */\n  SIGNED_MSG_TYPE_PREVOTE = 1,\n  SIGNED_MSG_TYPE_PRECOMMIT = 2,\n  /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */\n  SIGNED_MSG_TYPE_PROPOSAL = 32,\n  UNRECOGNIZED = -1,\n}\n\nexport function signedMsgTypeFromJSON(object: any): SignedMsgType {\n  switch (object) {\n    case 0:\n    case \"SIGNED_MSG_TYPE_UNKNOWN\":\n      return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n    case 1:\n    case \"SIGNED_MSG_TYPE_PREVOTE\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n    case 2:\n    case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n    case 32:\n    case \"SIGNED_MSG_TYPE_PROPOSAL\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignedMsgType.UNRECOGNIZED;\n  }\n}\n\nexport function signedMsgTypeToJSON(object: SignedMsgType): string {\n  switch (object) {\n    case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:\n      return \"SIGNED_MSG_TYPE_UNKNOWN\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:\n      return \"SIGNED_MSG_TYPE_PREVOTE\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:\n      return \"SIGNED_MSG_TYPE_PRECOMMIT\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:\n      return \"SIGNED_MSG_TYPE_PROPOSAL\";\n    case SignedMsgType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** PartsetHeader */\nexport interface PartSetHeader {\n  total: number;\n  hash: Uint8Array;\n}\n\nexport interface Part {\n  index: number;\n  bytes: Uint8Array;\n  proof?: Proof;\n}\n\n/** BlockID */\nexport interface BlockID {\n  hash: Uint8Array;\n  partSetHeader?: PartSetHeader;\n}\n\n/** Header defines the structure of a Tendermint block header. */\nexport interface Header {\n  /** basic block info */\n  version?: Consensus;\n  chainId: string;\n  height: Long;\n  time?: Date;\n  /** prev block info */\n  lastBlockId?: BlockID;\n  /** hashes of block data */\n  lastCommitHash: Uint8Array;\n  /** transactions */\n  dataHash: Uint8Array;\n  /** hashes from the app output from the prev block */\n  validatorsHash: Uint8Array;\n  /** validators for the next block */\n  nextValidatorsHash: Uint8Array;\n  /** consensus params for current block */\n  consensusHash: Uint8Array;\n  /** state after txs from the previous block */\n  appHash: Uint8Array;\n  /** root hash of all results from the txs from the previous block */\n  lastResultsHash: Uint8Array;\n  /** consensus info */\n  evidenceHash: Uint8Array;\n  /** original proposer of the block */\n  proposerAddress: Uint8Array;\n}\n\n/** Data contains the set of transactions included in the block */\nexport interface Data {\n  /**\n   * Txs that will be applied by state @ block.Height+1.\n   * NOTE: not all txs here are valid.  We're just agreeing on the order first.\n   * This means that block.AppHash does not include these txs.\n   */\n  txs: Uint8Array[];\n}\n\n/**\n * Vote represents a prevote, precommit, or commit vote from validators for\n * consensus.\n */\nexport interface Vote {\n  type: SignedMsgType;\n  height: Long;\n  round: number;\n  /** zero if vote is nil. */\n  blockId?: BlockID;\n  timestamp?: Date;\n  validatorAddress: Uint8Array;\n  validatorIndex: number;\n  signature: Uint8Array;\n}\n\n/**\n * Commit contains the evidence that a block was committed by a set of\n * validators.\n */\nexport interface Commit {\n  height: Long;\n  round: number;\n  blockId?: BlockID;\n  signatures: CommitSig[];\n}\n\n/** CommitSig is a part of the Vote included in a Commit. */\nexport interface CommitSig {\n  blockIdFlag: BlockIDFlag;\n  validatorAddress: Uint8Array;\n  timestamp?: Date;\n  signature: Uint8Array;\n}\n\nexport interface Proposal {\n  type: SignedMsgType;\n  height: Long;\n  round: number;\n  polRound: number;\n  blockId?: BlockID;\n  timestamp?: Date;\n  signature: Uint8Array;\n}\n\nexport interface SignedHeader {\n  header?: Header;\n  commit?: Commit;\n}\n\nexport interface LightBlock {\n  signedHeader?: SignedHeader;\n  validatorSet?: ValidatorSet;\n}\n\nexport interface BlockMeta {\n  blockId?: BlockID;\n  blockSize: Long;\n  header?: Header;\n  numTxs: Long;\n}\n\n/**\n * TxProof represents a Merkle proof of the presence of a transaction in the\n * Merkle tree.\n */\nexport interface TxProof {\n  rootHash: Uint8Array;\n  data: Uint8Array;\n  proof?: Proof;\n}\n\nfunction createBasePartSetHeader(): PartSetHeader {\n  return { total: 0, hash: new Uint8Array() };\n}\n\nexport const PartSetHeader = {\n  encode(\n    message: PartSetHeader,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.total !== 0) {\n      writer.uint32(8).uint32(message.total);\n    }\n    if (message.hash.length !== 0) {\n      writer.uint32(18).bytes(message.hash);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PartSetHeader {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePartSetHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.uint32();\n          break;\n        case 2:\n          message.hash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PartSetHeader {\n    return {\n      total: isSet(object.total) ? Number(object.total) : 0,\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PartSetHeader): unknown {\n    const obj: any = {};\n    message.total !== undefined && (obj.total = Math.round(message.total));\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PartSetHeader>, I>>(\n    object: I\n  ): PartSetHeader {\n    const message = createBasePartSetHeader();\n    message.total = object.total ?? 0;\n    message.hash = object.hash ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePart(): Part {\n  return { index: 0, bytes: new Uint8Array(), proof: undefined };\n}\n\nexport const Part = {\n  encode(message: Part, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.index !== 0) {\n      writer.uint32(8).uint32(message.index);\n    }\n    if (message.bytes.length !== 0) {\n      writer.uint32(18).bytes(message.bytes);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Part {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePart();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.uint32();\n          break;\n        case 2:\n          message.bytes = reader.bytes();\n          break;\n        case 3:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Part {\n    return {\n      index: isSet(object.index) ? Number(object.index) : 0,\n      bytes: isSet(object.bytes)\n        ? bytesFromBase64(object.bytes)\n        : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: Part): unknown {\n    const obj: any = {};\n    message.index !== undefined && (obj.index = Math.round(message.index));\n    message.bytes !== undefined &&\n      (obj.bytes = base64FromBytes(\n        message.bytes !== undefined ? message.bytes : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Part>, I>>(object: I): Part {\n    const message = createBasePart();\n    message.index = object.index ?? 0;\n    message.bytes = object.bytes ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseBlockID(): BlockID {\n  return { hash: new Uint8Array(), partSetHeader: undefined };\n}\n\nexport const BlockID = {\n  encode(\n    message: BlockID,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    if (message.partSetHeader !== undefined) {\n      PartSetHeader.encode(\n        message.partSetHeader,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): BlockID {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBlockID();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        case 2:\n          message.partSetHeader = PartSetHeader.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): BlockID {\n    return {\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n      partSetHeader: isSet(object.partSetHeader)\n        ? PartSetHeader.fromJSON(object.partSetHeader)\n        : undefined,\n    };\n  },\n\n  toJSON(message: BlockID): unknown {\n    const obj: any = {};\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    message.partSetHeader !== undefined &&\n      (obj.partSetHeader = message.partSetHeader\n        ? PartSetHeader.toJSON(message.partSetHeader)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<BlockID>, I>>(object: I): BlockID {\n    const message = createBaseBlockID();\n    message.hash = object.hash ?? new Uint8Array();\n    message.partSetHeader =\n      object.partSetHeader !== undefined && object.partSetHeader !== null\n        ? PartSetHeader.fromPartial(object.partSetHeader)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseHeader(): Header {\n  return {\n    version: undefined,\n    chainId: \"\",\n    height: Long.ZERO,\n    time: undefined,\n    lastBlockId: undefined,\n    lastCommitHash: new Uint8Array(),\n    dataHash: new Uint8Array(),\n    validatorsHash: new Uint8Array(),\n    nextValidatorsHash: new Uint8Array(),\n    consensusHash: new Uint8Array(),\n    appHash: new Uint8Array(),\n    lastResultsHash: new Uint8Array(),\n    evidenceHash: new Uint8Array(),\n    proposerAddress: new Uint8Array(),\n  };\n}\n\nexport const Header = {\n  encode(\n    message: Header,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.version !== undefined) {\n      Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.time !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.time),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    if (message.lastBlockId !== undefined) {\n      BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.lastCommitHash.length !== 0) {\n      writer.uint32(50).bytes(message.lastCommitHash);\n    }\n    if (message.dataHash.length !== 0) {\n      writer.uint32(58).bytes(message.dataHash);\n    }\n    if (message.validatorsHash.length !== 0) {\n      writer.uint32(66).bytes(message.validatorsHash);\n    }\n    if (message.nextValidatorsHash.length !== 0) {\n      writer.uint32(74).bytes(message.nextValidatorsHash);\n    }\n    if (message.consensusHash.length !== 0) {\n      writer.uint32(82).bytes(message.consensusHash);\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(90).bytes(message.appHash);\n    }\n    if (message.lastResultsHash.length !== 0) {\n      writer.uint32(98).bytes(message.lastResultsHash);\n    }\n    if (message.evidenceHash.length !== 0) {\n      writer.uint32(106).bytes(message.evidenceHash);\n    }\n    if (message.proposerAddress.length !== 0) {\n      writer.uint32(114).bytes(message.proposerAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Header {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.version = Consensus.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.chainId = reader.string();\n          break;\n        case 3:\n          message.height = reader.int64() as Long;\n          break;\n        case 4:\n          message.time = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 5:\n          message.lastBlockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.lastCommitHash = reader.bytes();\n          break;\n        case 7:\n          message.dataHash = reader.bytes();\n          break;\n        case 8:\n          message.validatorsHash = reader.bytes();\n          break;\n        case 9:\n          message.nextValidatorsHash = reader.bytes();\n          break;\n        case 10:\n          message.consensusHash = reader.bytes();\n          break;\n        case 11:\n          message.appHash = reader.bytes();\n          break;\n        case 12:\n          message.lastResultsHash = reader.bytes();\n          break;\n        case 13:\n          message.evidenceHash = reader.bytes();\n          break;\n        case 14:\n          message.proposerAddress = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Header {\n    return {\n      version: isSet(object.version)\n        ? Consensus.fromJSON(object.version)\n        : undefined,\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,\n      lastBlockId: isSet(object.lastBlockId)\n        ? BlockID.fromJSON(object.lastBlockId)\n        : undefined,\n      lastCommitHash: isSet(object.lastCommitHash)\n        ? bytesFromBase64(object.lastCommitHash)\n        : new Uint8Array(),\n      dataHash: isSet(object.dataHash)\n        ? bytesFromBase64(object.dataHash)\n        : new Uint8Array(),\n      validatorsHash: isSet(object.validatorsHash)\n        ? bytesFromBase64(object.validatorsHash)\n        : new Uint8Array(),\n      nextValidatorsHash: isSet(object.nextValidatorsHash)\n        ? bytesFromBase64(object.nextValidatorsHash)\n        : new Uint8Array(),\n      consensusHash: isSet(object.consensusHash)\n        ? bytesFromBase64(object.consensusHash)\n        : new Uint8Array(),\n      appHash: isSet(object.appHash)\n        ? bytesFromBase64(object.appHash)\n        : new Uint8Array(),\n      lastResultsHash: isSet(object.lastResultsHash)\n        ? bytesFromBase64(object.lastResultsHash)\n        : new Uint8Array(),\n      evidenceHash: isSet(object.evidenceHash)\n        ? bytesFromBase64(object.evidenceHash)\n        : new Uint8Array(),\n      proposerAddress: isSet(object.proposerAddress)\n        ? bytesFromBase64(object.proposerAddress)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Header): unknown {\n    const obj: any = {};\n    message.version !== undefined &&\n      (obj.version = message.version\n        ? Consensus.toJSON(message.version)\n        : undefined);\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.time !== undefined && (obj.time = message.time.toISOString());\n    message.lastBlockId !== undefined &&\n      (obj.lastBlockId = message.lastBlockId\n        ? BlockID.toJSON(message.lastBlockId)\n        : undefined);\n    message.lastCommitHash !== undefined &&\n      (obj.lastCommitHash = base64FromBytes(\n        message.lastCommitHash !== undefined\n          ? message.lastCommitHash\n          : new Uint8Array()\n      ));\n    message.dataHash !== undefined &&\n      (obj.dataHash = base64FromBytes(\n        message.dataHash !== undefined ? message.dataHash : new Uint8Array()\n      ));\n    message.validatorsHash !== undefined &&\n      (obj.validatorsHash = base64FromBytes(\n        message.validatorsHash !== undefined\n          ? message.validatorsHash\n          : new Uint8Array()\n      ));\n    message.nextValidatorsHash !== undefined &&\n      (obj.nextValidatorsHash = base64FromBytes(\n        message.nextValidatorsHash !== undefined\n          ? message.nextValidatorsHash\n          : new Uint8Array()\n      ));\n    message.consensusHash !== undefined &&\n      (obj.consensusHash = base64FromBytes(\n        message.consensusHash !== undefined\n          ? message.consensusHash\n          : new Uint8Array()\n      ));\n    message.appHash !== undefined &&\n      (obj.appHash = base64FromBytes(\n        message.appHash !== undefined ? message.appHash : new Uint8Array()\n      ));\n    message.lastResultsHash !== undefined &&\n      (obj.lastResultsHash = base64FromBytes(\n        message.lastResultsHash !== undefined\n          ? message.lastResultsHash\n          : new Uint8Array()\n      ));\n    message.evidenceHash !== undefined &&\n      (obj.evidenceHash = base64FromBytes(\n        message.evidenceHash !== undefined\n          ? message.evidenceHash\n          : new Uint8Array()\n      ));\n    message.proposerAddress !== undefined &&\n      (obj.proposerAddress = base64FromBytes(\n        message.proposerAddress !== undefined\n          ? message.proposerAddress\n          : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {\n    const message = createBaseHeader();\n    message.version =\n      object.version !== undefined && object.version !== null\n        ? Consensus.fromPartial(object.version)\n        : undefined;\n    message.chainId = object.chainId ?? \"\";\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.time = object.time ?? undefined;\n    message.lastBlockId =\n      object.lastBlockId !== undefined && object.lastBlockId !== null\n        ? BlockID.fromPartial(object.lastBlockId)\n        : undefined;\n    message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();\n    message.dataHash = object.dataHash ?? new Uint8Array();\n    message.validatorsHash = object.validatorsHash ?? new Uint8Array();\n    message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();\n    message.consensusHash = object.consensusHash ?? new Uint8Array();\n    message.appHash = object.appHash ?? new Uint8Array();\n    message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();\n    message.evidenceHash = object.evidenceHash ?? new Uint8Array();\n    message.proposerAddress = object.proposerAddress ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseData(): Data {\n  return { txs: [] };\n}\n\nexport const Data = {\n  encode(message: Data, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.txs) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.txs.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Data {\n    return {\n      txs: Array.isArray(object?.txs)\n        ? object.txs.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Data): unknown {\n    const obj: any = {};\n    if (message.txs) {\n      obj.txs = message.txs.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.txs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Data>, I>>(object: I): Data {\n    const message = createBaseData();\n    message.txs = object.txs?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseVote(): Vote {\n  return {\n    type: 0,\n    height: Long.ZERO,\n    round: 0,\n    blockId: undefined,\n    timestamp: undefined,\n    validatorAddress: new Uint8Array(),\n    validatorIndex: 0,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const Vote = {\n  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(50).bytes(message.validatorAddress);\n    }\n    if (message.validatorIndex !== 0) {\n      writer.uint32(56).int32(message.validatorIndex);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(66).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32() as any;\n          break;\n        case 2:\n          message.height = reader.int64() as Long;\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 6:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 7:\n          message.validatorIndex = reader.int32();\n          break;\n        case 8:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Vote {\n    return {\n      type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      validatorAddress: isSet(object.validatorAddress)\n        ? bytesFromBase64(object.validatorAddress)\n        : new Uint8Array(),\n      validatorIndex: isSet(object.validatorIndex)\n        ? Number(object.validatorIndex)\n        : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Vote): unknown {\n    const obj: any = {};\n    message.type !== undefined &&\n      (obj.type = signedMsgTypeToJSON(message.type));\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = base64FromBytes(\n        message.validatorAddress !== undefined\n          ? message.validatorAddress\n          : new Uint8Array()\n      ));\n    message.validatorIndex !== undefined &&\n      (obj.validatorIndex = Math.round(message.validatorIndex));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {\n    const message = createBaseVote();\n    message.type = object.type ?? 0;\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.timestamp = object.timestamp ?? undefined;\n    message.validatorAddress = object.validatorAddress ?? new Uint8Array();\n    message.validatorIndex = object.validatorIndex ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseCommit(): Commit {\n  return { height: Long.ZERO, round: 0, blockId: undefined, signatures: [] };\n}\n\nexport const Commit = {\n  encode(\n    message: Commit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(16).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      CommitSig.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Commit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64() as Long;\n          break;\n        case 2:\n          message.round = reader.int32();\n          break;\n        case 3:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signatures.push(CommitSig.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Commit {\n    return {\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => CommitSig.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Commit): unknown {\n    const obj: any = {};\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? CommitSig.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Commit>, I>>(object: I): Commit {\n    const message = createBaseCommit();\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => CommitSig.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCommitSig(): CommitSig {\n  return {\n    blockIdFlag: 0,\n    validatorAddress: new Uint8Array(),\n    timestamp: undefined,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const CommitSig = {\n  encode(\n    message: CommitSig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.blockIdFlag !== 0) {\n      writer.uint32(8).int32(message.blockIdFlag);\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(18).bytes(message.validatorAddress);\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(34).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CommitSig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommitSig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockIdFlag = reader.int32() as any;\n          break;\n        case 2:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 3:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 4:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CommitSig {\n    return {\n      blockIdFlag: isSet(object.blockIdFlag)\n        ? blockIDFlagFromJSON(object.blockIdFlag)\n        : 0,\n      validatorAddress: isSet(object.validatorAddress)\n        ? bytesFromBase64(object.validatorAddress)\n        : new Uint8Array(),\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CommitSig): unknown {\n    const obj: any = {};\n    message.blockIdFlag !== undefined &&\n      (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = base64FromBytes(\n        message.validatorAddress !== undefined\n          ? message.validatorAddress\n          : new Uint8Array()\n      ));\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CommitSig>, I>>(\n    object: I\n  ): CommitSig {\n    const message = createBaseCommitSig();\n    message.blockIdFlag = object.blockIdFlag ?? 0;\n    message.validatorAddress = object.validatorAddress ?? new Uint8Array();\n    message.timestamp = object.timestamp ?? undefined;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseProposal(): Proposal {\n  return {\n    type: 0,\n    height: Long.ZERO,\n    round: 0,\n    polRound: 0,\n    blockId: undefined,\n    timestamp: undefined,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const Proposal = {\n  encode(\n    message: Proposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.polRound !== 0) {\n      writer.uint32(32).int32(message.polRound);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(58).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32() as any;\n          break;\n        case 2:\n          message.height = reader.int64() as Long;\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.polRound = reader.int32();\n          break;\n        case 5:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 7:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proposal {\n    return {\n      type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      polRound: isSet(object.polRound) ? Number(object.polRound) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Proposal): unknown {\n    const obj: any = {};\n    message.type !== undefined &&\n      (obj.type = signedMsgTypeToJSON(message.type));\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.polRound !== undefined &&\n      (obj.polRound = Math.round(message.polRound));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {\n    const message = createBaseProposal();\n    message.type = object.type ?? 0;\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.polRound = object.polRound ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.timestamp = object.timestamp ?? undefined;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignedHeader(): SignedHeader {\n  return { header: undefined, commit: undefined };\n}\n\nexport const SignedHeader = {\n  encode(\n    message: SignedHeader,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignedHeader {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignedHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commit = Commit.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignedHeader {\n    return {\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      commit: isSet(object.commit) ? Commit.fromJSON(object.commit) : undefined,\n    };\n  },\n\n  toJSON(message: SignedHeader): unknown {\n    const obj: any = {};\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    message.commit !== undefined &&\n      (obj.commit = message.commit ? Commit.toJSON(message.commit) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignedHeader>, I>>(\n    object: I\n  ): SignedHeader {\n    const message = createBaseSignedHeader();\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.commit =\n      object.commit !== undefined && object.commit !== null\n        ? Commit.fromPartial(object.commit)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseLightBlock(): LightBlock {\n  return { signedHeader: undefined, validatorSet: undefined };\n}\n\nexport const LightBlock = {\n  encode(\n    message: LightBlock,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.signedHeader !== undefined) {\n      SignedHeader.encode(\n        message.signedHeader,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.validatorSet !== undefined) {\n      ValidatorSet.encode(\n        message.validatorSet,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): LightBlock {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLightBlock();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signedHeader = SignedHeader.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorSet = ValidatorSet.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LightBlock {\n    return {\n      signedHeader: isSet(object.signedHeader)\n        ? SignedHeader.fromJSON(object.signedHeader)\n        : undefined,\n      validatorSet: isSet(object.validatorSet)\n        ? ValidatorSet.fromJSON(object.validatorSet)\n        : undefined,\n    };\n  },\n\n  toJSON(message: LightBlock): unknown {\n    const obj: any = {};\n    message.signedHeader !== undefined &&\n      (obj.signedHeader = message.signedHeader\n        ? SignedHeader.toJSON(message.signedHeader)\n        : undefined);\n    message.validatorSet !== undefined &&\n      (obj.validatorSet = message.validatorSet\n        ? ValidatorSet.toJSON(message.validatorSet)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LightBlock>, I>>(\n    object: I\n  ): LightBlock {\n    const message = createBaseLightBlock();\n    message.signedHeader =\n      object.signedHeader !== undefined && object.signedHeader !== null\n        ? SignedHeader.fromPartial(object.signedHeader)\n        : undefined;\n    message.validatorSet =\n      object.validatorSet !== undefined && object.validatorSet !== null\n        ? ValidatorSet.fromPartial(object.validatorSet)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseBlockMeta(): BlockMeta {\n  return {\n    blockId: undefined,\n    blockSize: Long.ZERO,\n    header: undefined,\n    numTxs: Long.ZERO,\n  };\n}\n\nexport const BlockMeta = {\n  encode(\n    message: BlockMeta,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.blockSize.isZero()) {\n      writer.uint32(16).int64(message.blockSize);\n    }\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.numTxs.isZero()) {\n      writer.uint32(32).int64(message.numTxs);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): BlockMeta {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBlockMeta();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.blockSize = reader.int64() as Long;\n          break;\n        case 3:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.numTxs = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): BlockMeta {\n    return {\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      blockSize: isSet(object.blockSize)\n        ? Long.fromValue(object.blockSize)\n        : Long.ZERO,\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      numTxs: isSet(object.numTxs) ? Long.fromValue(object.numTxs) : Long.ZERO,\n    };\n  },\n\n  toJSON(message: BlockMeta): unknown {\n    const obj: any = {};\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.blockSize !== undefined &&\n      (obj.blockSize = (message.blockSize || Long.ZERO).toString());\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    message.numTxs !== undefined &&\n      (obj.numTxs = (message.numTxs || Long.ZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<BlockMeta>, I>>(\n    object: I\n  ): BlockMeta {\n    const message = createBaseBlockMeta();\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.blockSize =\n      object.blockSize !== undefined && object.blockSize !== null\n        ? Long.fromValue(object.blockSize)\n        : Long.ZERO;\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.numTxs =\n      object.numTxs !== undefined && object.numTxs !== null\n        ? Long.fromValue(object.numTxs)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxProof(): TxProof {\n  return {\n    rootHash: new Uint8Array(),\n    data: new Uint8Array(),\n    proof: undefined,\n  };\n}\n\nexport const TxProof = {\n  encode(\n    message: TxProof,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.rootHash.length !== 0) {\n      writer.uint32(10).bytes(message.rootHash);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxProof {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rootHash = reader.bytes();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxProof {\n    return {\n      rootHash: isSet(object.rootHash)\n        ? bytesFromBase64(object.rootHash)\n        : new Uint8Array(),\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: TxProof): unknown {\n    const obj: any = {};\n    message.rootHash !== undefined &&\n      (obj.rootHash = base64FromBytes(\n        message.rootHash !== undefined ? message.rootHash : new Uint8Array()\n      ));\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxProof>, I>>(object: I): TxProof {\n    const message = createBaseTxProof();\n    message.rootHash = object.rootHash ?? new Uint8Array();\n    message.data = object.data ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Header } from \"../../../tendermint/types/types\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Duration } from \"../../../google/protobuf/duration\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.staking.v1beta1\";\n\n/** BondStatus is the status of a validator. */\nexport enum BondStatus {\n  /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */\n  BOND_STATUS_UNSPECIFIED = 0,\n  /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */\n  BOND_STATUS_UNBONDED = 1,\n  /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */\n  BOND_STATUS_UNBONDING = 2,\n  /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */\n  BOND_STATUS_BONDED = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function bondStatusFromJSON(object: any): BondStatus {\n  switch (object) {\n    case 0:\n    case \"BOND_STATUS_UNSPECIFIED\":\n      return BondStatus.BOND_STATUS_UNSPECIFIED;\n    case 1:\n    case \"BOND_STATUS_UNBONDED\":\n      return BondStatus.BOND_STATUS_UNBONDED;\n    case 2:\n    case \"BOND_STATUS_UNBONDING\":\n      return BondStatus.BOND_STATUS_UNBONDING;\n    case 3:\n    case \"BOND_STATUS_BONDED\":\n      return BondStatus.BOND_STATUS_BONDED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BondStatus.UNRECOGNIZED;\n  }\n}\n\nexport function bondStatusToJSON(object: BondStatus): string {\n  switch (object) {\n    case BondStatus.BOND_STATUS_UNSPECIFIED:\n      return \"BOND_STATUS_UNSPECIFIED\";\n    case BondStatus.BOND_STATUS_UNBONDED:\n      return \"BOND_STATUS_UNBONDED\";\n    case BondStatus.BOND_STATUS_UNBONDING:\n      return \"BOND_STATUS_UNBONDING\";\n    case BondStatus.BOND_STATUS_BONDED:\n      return \"BOND_STATUS_BONDED\";\n    case BondStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/**\n * HistoricalInfo contains header and validator information for a given block.\n * It is stored as part of staking module's state, which persists the `n` most\n * recent HistoricalInfo\n * (`n` is set by the staking module's `historical_entries` parameter).\n */\nexport interface HistoricalInfo {\n  header?: Header;\n  valset: Validator[];\n}\n\n/**\n * CommissionRates defines the initial commission rates to be used for creating\n * a validator.\n */\nexport interface CommissionRates {\n  /** rate is the commission rate charged to delegators, as a fraction. */\n  rate: string;\n  /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */\n  maxRate: string;\n  /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */\n  maxChangeRate: string;\n}\n\n/** Commission defines commission parameters for a given validator. */\nexport interface Commission {\n  /** commission_rates defines the initial commission rates to be used for creating a validator. */\n  commissionRates?: CommissionRates;\n  /** update_time is the last time the commission rate was changed. */\n  updateTime?: Date;\n}\n\n/** Description defines a validator description. */\nexport interface Description {\n  /** moniker defines a human-readable name for the validator. */\n  moniker: string;\n  /** identity defines an optional identity signature (ex. UPort or Keybase). */\n  identity: string;\n  /** website defines an optional website link. */\n  website: string;\n  /** security_contact defines an optional email for security contact. */\n  securityContact: string;\n  /** details define other optional details. */\n  details: string;\n}\n\n/**\n * Validator defines a validator, together with the total amount of the\n * Validator's bond shares and their exchange rate to coins. Slashing results in\n * a decrease in the exchange rate, allowing correct calculation of future\n * undelegations without iterating over delegators. When coins are delegated to\n * this validator, the validator is credited with a delegation whose number of\n * bond shares is based on the amount of coins delegated divided by the current\n * exchange rate. Voting power can be calculated as total bonded shares\n * multiplied by exchange rate.\n */\nexport interface Validator {\n  /** operator_address defines the address of the validator's operator; bech encoded in JSON. */\n  operatorAddress: string;\n  /** consensus_pubkey is the consensus public key of the validator, as a Protobuf Any. */\n  consensusPubkey?: Any;\n  /** jailed defined whether the validator has been jailed from bonded status or not. */\n  jailed: boolean;\n  /** status is the validator status (bonded/unbonding/unbonded). */\n  status: BondStatus;\n  /** tokens define the delegated tokens (incl. self-delegation). */\n  tokens: string;\n  /** delegator_shares defines total shares issued to a validator's delegators. */\n  delegatorShares: string;\n  /** description defines the description terms for the validator. */\n  description?: Description;\n  /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */\n  unbondingHeight: Long;\n  /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */\n  unbondingTime?: Date;\n  /** commission defines the commission parameters. */\n  commission?: Commission;\n  /** min_self_delegation is the validator's self declared minimum self delegation. */\n  minSelfDelegation: string;\n}\n\n/** ValAddresses defines a repeated set of validator addresses. */\nexport interface ValAddresses {\n  addresses: string[];\n}\n\n/**\n * DVPair is struct that just has a delegator-validator pair with no other data.\n * It is intended to be used as a marshalable pointer. For example, a DVPair can\n * be used to construct the key to getting an UnbondingDelegation from state.\n */\nexport interface DVPair {\n  delegatorAddress: string;\n  validatorAddress: string;\n}\n\n/** DVPairs defines an array of DVPair objects. */\nexport interface DVPairs {\n  pairs: DVPair[];\n}\n\n/**\n * DVVTriplet is struct that just has a delegator-validator-validator triplet\n * with no other data. It is intended to be used as a marshalable pointer. For\n * example, a DVVTriplet can be used to construct the key to getting a\n * Redelegation from state.\n */\nexport interface DVVTriplet {\n  delegatorAddress: string;\n  validatorSrcAddress: string;\n  validatorDstAddress: string;\n}\n\n/** DVVTriplets defines an array of DVVTriplet objects. */\nexport interface DVVTriplets {\n  triplets: DVVTriplet[];\n}\n\n/**\n * Delegation represents the bond with tokens held by an account. It is\n * owned by one delegator, and is associated with the voting power of one\n * validator.\n */\nexport interface Delegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_address is the bech32-encoded address of the validator. */\n  validatorAddress: string;\n  /** shares define the delegation shares received. */\n  shares: string;\n}\n\n/**\n * UnbondingDelegation stores all of a single delegator's unbonding bonds\n * for a single validator in an time-ordered list.\n */\nexport interface UnbondingDelegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_address is the bech32-encoded address of the validator. */\n  validatorAddress: string;\n  /** entries are the unbonding delegation entries. */\n  entries: UnbondingDelegationEntry[];\n}\n\n/** UnbondingDelegationEntry defines an unbonding object with relevant metadata. */\nexport interface UnbondingDelegationEntry {\n  /** creation_height is the height which the unbonding took place. */\n  creationHeight: Long;\n  /** completion_time is the unix time for unbonding completion. */\n  completionTime?: Date;\n  /** initial_balance defines the tokens initially scheduled to receive at completion. */\n  initialBalance: string;\n  /** balance defines the tokens to receive at completion. */\n  balance: string;\n}\n\n/** RedelegationEntry defines a redelegation object with relevant metadata. */\nexport interface RedelegationEntry {\n  /** creation_height  defines the height which the redelegation took place. */\n  creationHeight: Long;\n  /** completion_time defines the unix time for redelegation completion. */\n  completionTime?: Date;\n  /** initial_balance defines the initial balance when redelegation started. */\n  initialBalance: string;\n  /** shares_dst is the amount of destination-validator shares created by redelegation. */\n  sharesDst: string;\n}\n\n/**\n * Redelegation contains the list of a particular delegator's redelegating bonds\n * from a particular source validator to a particular destination validator.\n */\nexport interface Redelegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_src_address is the validator redelegation source operator address. */\n  validatorSrcAddress: string;\n  /** validator_dst_address is the validator redelegation destination operator address. */\n  validatorDstAddress: string;\n  /** entries are the redelegation entries. */\n  entries: RedelegationEntry[];\n}\n\n/** Params defines the parameters for the staking module. */\nexport interface Params {\n  /** unbonding_time is the time duration of unbonding. */\n  unbondingTime?: Duration;\n  /** max_validators is the maximum number of validators. */\n  maxValidators: number;\n  /** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */\n  maxEntries: number;\n  /** historical_entries is the number of historical entries to persist. */\n  historicalEntries: number;\n  /** bond_denom defines the bondable coin denomination. */\n  bondDenom: string;\n}\n\n/**\n * DelegationResponse is equivalent to Delegation except that it contains a\n * balance in addition to shares which is more suitable for client responses.\n */\nexport interface DelegationResponse {\n  delegation?: Delegation;\n  balance?: Coin;\n}\n\n/**\n * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\n * contains a balance in addition to shares which is more suitable for client\n * responses.\n */\nexport interface RedelegationEntryResponse {\n  redelegationEntry?: RedelegationEntry;\n  balance: string;\n}\n\n/**\n * RedelegationResponse is equivalent to a Redelegation except that its entries\n * contain a balance in addition to shares which is more suitable for client\n * responses.\n */\nexport interface RedelegationResponse {\n  redelegation?: Redelegation;\n  entries: RedelegationEntryResponse[];\n}\n\n/**\n * Pool is used for tracking bonded and not-bonded token supply of the bond\n * denomination.\n */\nexport interface Pool {\n  notBondedTokens: string;\n  bondedTokens: string;\n}\n\nfunction createBaseHistoricalInfo(): HistoricalInfo {\n  return { header: undefined, valset: [] };\n}\n\nexport const HistoricalInfo = {\n  encode(\n    message: HistoricalInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.valset) {\n      Validator.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): HistoricalInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHistoricalInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.valset.push(Validator.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): HistoricalInfo {\n    return {\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      valset: Array.isArray(object?.valset)\n        ? object.valset.map((e: any) => Validator.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: HistoricalInfo): unknown {\n    const obj: any = {};\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    if (message.valset) {\n      obj.valset = message.valset.map((e) =>\n        e ? Validator.toJSON(e) : undefined\n      );\n    } else {\n      obj.valset = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<HistoricalInfo>, I>>(\n    object: I\n  ): HistoricalInfo {\n    const message = createBaseHistoricalInfo();\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.valset = object.valset?.map((e) => Validator.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCommissionRates(): CommissionRates {\n  return { rate: \"\", maxRate: \"\", maxChangeRate: \"\" };\n}\n\nexport const CommissionRates = {\n  encode(\n    message: CommissionRates,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.rate !== \"\") {\n      writer.uint32(10).string(message.rate);\n    }\n    if (message.maxRate !== \"\") {\n      writer.uint32(18).string(message.maxRate);\n    }\n    if (message.maxChangeRate !== \"\") {\n      writer.uint32(26).string(message.maxChangeRate);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CommissionRates {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommissionRates();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rate = reader.string();\n          break;\n        case 2:\n          message.maxRate = reader.string();\n          break;\n        case 3:\n          message.maxChangeRate = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CommissionRates {\n    return {\n      rate: isSet(object.rate) ? String(object.rate) : \"\",\n      maxRate: isSet(object.maxRate) ? String(object.maxRate) : \"\",\n      maxChangeRate: isSet(object.maxChangeRate)\n        ? String(object.maxChangeRate)\n        : \"\",\n    };\n  },\n\n  toJSON(message: CommissionRates): unknown {\n    const obj: any = {};\n    message.rate !== undefined && (obj.rate = message.rate);\n    message.maxRate !== undefined && (obj.maxRate = message.maxRate);\n    message.maxChangeRate !== undefined &&\n      (obj.maxChangeRate = message.maxChangeRate);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CommissionRates>, I>>(\n    object: I\n  ): CommissionRates {\n    const message = createBaseCommissionRates();\n    message.rate = object.rate ?? \"\";\n    message.maxRate = object.maxRate ?? \"\";\n    message.maxChangeRate = object.maxChangeRate ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseCommission(): Commission {\n  return { commissionRates: undefined, updateTime: undefined };\n}\n\nexport const Commission = {\n  encode(\n    message: Commission,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.commissionRates !== undefined) {\n      CommissionRates.encode(\n        message.commissionRates,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.updateTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.updateTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Commission {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommission();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.commissionRates = CommissionRates.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.updateTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Commission {\n    return {\n      commissionRates: isSet(object.commissionRates)\n        ? CommissionRates.fromJSON(object.commissionRates)\n        : undefined,\n      updateTime: isSet(object.updateTime)\n        ? fromJsonTimestamp(object.updateTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Commission): unknown {\n    const obj: any = {};\n    message.commissionRates !== undefined &&\n      (obj.commissionRates = message.commissionRates\n        ? CommissionRates.toJSON(message.commissionRates)\n        : undefined);\n    message.updateTime !== undefined &&\n      (obj.updateTime = message.updateTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Commission>, I>>(\n    object: I\n  ): Commission {\n    const message = createBaseCommission();\n    message.commissionRates =\n      object.commissionRates !== undefined && object.commissionRates !== null\n        ? CommissionRates.fromPartial(object.commissionRates)\n        : undefined;\n    message.updateTime = object.updateTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseDescription(): Description {\n  return {\n    moniker: \"\",\n    identity: \"\",\n    website: \"\",\n    securityContact: \"\",\n    details: \"\",\n  };\n}\n\nexport const Description = {\n  encode(\n    message: Description,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.moniker !== \"\") {\n      writer.uint32(10).string(message.moniker);\n    }\n    if (message.identity !== \"\") {\n      writer.uint32(18).string(message.identity);\n    }\n    if (message.website !== \"\") {\n      writer.uint32(26).string(message.website);\n    }\n    if (message.securityContact !== \"\") {\n      writer.uint32(34).string(message.securityContact);\n    }\n    if (message.details !== \"\") {\n      writer.uint32(42).string(message.details);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Description {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDescription();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.moniker = reader.string();\n          break;\n        case 2:\n          message.identity = reader.string();\n          break;\n        case 3:\n          message.website = reader.string();\n          break;\n        case 4:\n          message.securityContact = reader.string();\n          break;\n        case 5:\n          message.details = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Description {\n    return {\n      moniker: isSet(object.moniker) ? String(object.moniker) : \"\",\n      identity: isSet(object.identity) ? String(object.identity) : \"\",\n      website: isSet(object.website) ? String(object.website) : \"\",\n      securityContact: isSet(object.securityContact)\n        ? String(object.securityContact)\n        : \"\",\n      details: isSet(object.details) ? String(object.details) : \"\",\n    };\n  },\n\n  toJSON(message: Description): unknown {\n    const obj: any = {};\n    message.moniker !== undefined && (obj.moniker = message.moniker);\n    message.identity !== undefined && (obj.identity = message.identity);\n    message.website !== undefined && (obj.website = message.website);\n    message.securityContact !== undefined &&\n      (obj.securityContact = message.securityContact);\n    message.details !== undefined && (obj.details = message.details);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Description>, I>>(\n    object: I\n  ): Description {\n    const message = createBaseDescription();\n    message.moniker = object.moniker ?? \"\";\n    message.identity = object.identity ?? \"\";\n    message.website = object.website ?? \"\";\n    message.securityContact = object.securityContact ?? \"\";\n    message.details = object.details ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseValidator(): Validator {\n  return {\n    operatorAddress: \"\",\n    consensusPubkey: undefined,\n    jailed: false,\n    status: 0,\n    tokens: \"\",\n    delegatorShares: \"\",\n    description: undefined,\n    unbondingHeight: Long.ZERO,\n    unbondingTime: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n  };\n}\n\nexport const Validator = {\n  encode(\n    message: Validator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.operatorAddress !== \"\") {\n      writer.uint32(10).string(message.operatorAddress);\n    }\n    if (message.consensusPubkey !== undefined) {\n      Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.jailed === true) {\n      writer.uint32(24).bool(message.jailed);\n    }\n    if (message.status !== 0) {\n      writer.uint32(32).int32(message.status);\n    }\n    if (message.tokens !== \"\") {\n      writer.uint32(42).string(message.tokens);\n    }\n    if (message.delegatorShares !== \"\") {\n      writer.uint32(50).string(message.delegatorShares);\n    }\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    if (!message.unbondingHeight.isZero()) {\n      writer.uint32(64).int64(message.unbondingHeight);\n    }\n    if (message.unbondingTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.unbondingTime),\n        writer.uint32(74).fork()\n      ).ldelim();\n    }\n    if (message.commission !== undefined) {\n      Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(90).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.operatorAddress = reader.string();\n          break;\n        case 2:\n          message.consensusPubkey = Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.jailed = reader.bool();\n          break;\n        case 4:\n          message.status = reader.int32() as any;\n          break;\n        case 5:\n          message.tokens = reader.string();\n          break;\n        case 6:\n          message.delegatorShares = reader.string();\n          break;\n        case 7:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.unbondingHeight = reader.int64() as Long;\n          break;\n        case 9:\n          message.unbondingTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 10:\n          message.commission = Commission.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Validator {\n    return {\n      operatorAddress: isSet(object.operatorAddress)\n        ? String(object.operatorAddress)\n        : \"\",\n      consensusPubkey: isSet(object.consensusPubkey)\n        ? Any.fromJSON(object.consensusPubkey)\n        : undefined,\n      jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,\n      status: isSet(object.status) ? bondStatusFromJSON(object.status) : 0,\n      tokens: isSet(object.tokens) ? String(object.tokens) : \"\",\n      delegatorShares: isSet(object.delegatorShares)\n        ? String(object.delegatorShares)\n        : \"\",\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      unbondingHeight: isSet(object.unbondingHeight)\n        ? Long.fromValue(object.unbondingHeight)\n        : Long.ZERO,\n      unbondingTime: isSet(object.unbondingTime)\n        ? fromJsonTimestamp(object.unbondingTime)\n        : undefined,\n      commission: isSet(object.commission)\n        ? Commission.fromJSON(object.commission)\n        : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n    };\n  },\n\n  toJSON(message: Validator): unknown {\n    const obj: any = {};\n    message.operatorAddress !== undefined &&\n      (obj.operatorAddress = message.operatorAddress);\n    message.consensusPubkey !== undefined &&\n      (obj.consensusPubkey = message.consensusPubkey\n        ? Any.toJSON(message.consensusPubkey)\n        : undefined);\n    message.jailed !== undefined && (obj.jailed = message.jailed);\n    message.status !== undefined &&\n      (obj.status = bondStatusToJSON(message.status));\n    message.tokens !== undefined && (obj.tokens = message.tokens);\n    message.delegatorShares !== undefined &&\n      (obj.delegatorShares = message.delegatorShares);\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.unbondingHeight !== undefined &&\n      (obj.unbondingHeight = (message.unbondingHeight || Long.ZERO).toString());\n    message.unbondingTime !== undefined &&\n      (obj.unbondingTime = message.unbondingTime.toISOString());\n    message.commission !== undefined &&\n      (obj.commission = message.commission\n        ? Commission.toJSON(message.commission)\n        : undefined);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Validator>, I>>(\n    object: I\n  ): Validator {\n    const message = createBaseValidator();\n    message.operatorAddress = object.operatorAddress ?? \"\";\n    message.consensusPubkey =\n      object.consensusPubkey !== undefined && object.consensusPubkey !== null\n        ? Any.fromPartial(object.consensusPubkey)\n        : undefined;\n    message.jailed = object.jailed ?? false;\n    message.status = object.status ?? 0;\n    message.tokens = object.tokens ?? \"\";\n    message.delegatorShares = object.delegatorShares ?? \"\";\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.unbondingHeight =\n      object.unbondingHeight !== undefined && object.unbondingHeight !== null\n        ? Long.fromValue(object.unbondingHeight)\n        : Long.ZERO;\n    message.unbondingTime = object.unbondingTime ?? undefined;\n    message.commission =\n      object.commission !== undefined && object.commission !== null\n        ? Commission.fromPartial(object.commission)\n        : undefined;\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseValAddresses(): ValAddresses {\n  return { addresses: [] };\n}\n\nexport const ValAddresses = {\n  encode(\n    message: ValAddresses,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.addresses) {\n      writer.uint32(10).string(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValAddresses {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValAddresses();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.addresses.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValAddresses {\n    return {\n      addresses: Array.isArray(object?.addresses)\n        ? object.addresses.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ValAddresses): unknown {\n    const obj: any = {};\n    if (message.addresses) {\n      obj.addresses = message.addresses.map((e) => e);\n    } else {\n      obj.addresses = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValAddresses>, I>>(\n    object: I\n  ): ValAddresses {\n    const message = createBaseValAddresses();\n    message.addresses = object.addresses?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseDVPair(): DVPair {\n  return { delegatorAddress: \"\", validatorAddress: \"\" };\n}\n\nexport const DVPair = {\n  encode(\n    message: DVPair,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVPair {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVPair();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVPair {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: DVPair): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVPair>, I>>(object: I): DVPair {\n    const message = createBaseDVPair();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDVPairs(): DVPairs {\n  return { pairs: [] };\n}\n\nexport const DVPairs = {\n  encode(\n    message: DVPairs,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.pairs) {\n      DVPair.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVPairs {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVPairs();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pairs.push(DVPair.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVPairs {\n    return {\n      pairs: Array.isArray(object?.pairs)\n        ? object.pairs.map((e: any) => DVPair.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DVPairs): unknown {\n    const obj: any = {};\n    if (message.pairs) {\n      obj.pairs = message.pairs.map((e) => (e ? DVPair.toJSON(e) : undefined));\n    } else {\n      obj.pairs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVPairs>, I>>(object: I): DVPairs {\n    const message = createBaseDVPairs();\n    message.pairs = object.pairs?.map((e) => DVPair.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDVVTriplet(): DVVTriplet {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n  };\n}\n\nexport const DVVTriplet = {\n  encode(\n    message: DVVTriplet,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVVTriplet {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVVTriplet();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVVTriplet {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: DVVTriplet): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVVTriplet>, I>>(\n    object: I\n  ): DVVTriplet {\n    const message = createBaseDVVTriplet();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDVVTriplets(): DVVTriplets {\n  return { triplets: [] };\n}\n\nexport const DVVTriplets = {\n  encode(\n    message: DVVTriplets,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.triplets) {\n      DVVTriplet.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVVTriplets {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVVTriplets();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.triplets.push(DVVTriplet.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVVTriplets {\n    return {\n      triplets: Array.isArray(object?.triplets)\n        ? object.triplets.map((e: any) => DVVTriplet.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DVVTriplets): unknown {\n    const obj: any = {};\n    if (message.triplets) {\n      obj.triplets = message.triplets.map((e) =>\n        e ? DVVTriplet.toJSON(e) : undefined\n      );\n    } else {\n      obj.triplets = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVVTriplets>, I>>(\n    object: I\n  ): DVVTriplets {\n    const message = createBaseDVVTriplets();\n    message.triplets =\n      object.triplets?.map((e) => DVVTriplet.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDelegation(): Delegation {\n  return { delegatorAddress: \"\", validatorAddress: \"\", shares: \"\" };\n}\n\nexport const Delegation = {\n  encode(\n    message: Delegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.shares !== \"\") {\n      writer.uint32(26).string(message.shares);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Delegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.shares = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Delegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      shares: isSet(object.shares) ? String(object.shares) : \"\",\n    };\n  },\n\n  toJSON(message: Delegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.shares !== undefined && (obj.shares = message.shares);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Delegation>, I>>(\n    object: I\n  ): Delegation {\n    const message = createBaseDelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.shares = object.shares ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseUnbondingDelegation(): UnbondingDelegation {\n  return { delegatorAddress: \"\", validatorAddress: \"\", entries: [] };\n}\n\nexport const UnbondingDelegation = {\n  encode(\n    message: UnbondingDelegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    for (const v of message.entries) {\n      UnbondingDelegationEntry.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): UnbondingDelegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUnbondingDelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.entries.push(\n            UnbondingDelegationEntry.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UnbondingDelegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => UnbondingDelegationEntry.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: UnbondingDelegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? UnbondingDelegationEntry.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<UnbondingDelegation>, I>>(\n    object: I\n  ): UnbondingDelegation {\n    const message = createBaseUnbondingDelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.entries =\n      object.entries?.map((e) => UnbondingDelegationEntry.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseUnbondingDelegationEntry(): UnbondingDelegationEntry {\n  return {\n    creationHeight: Long.ZERO,\n    completionTime: undefined,\n    initialBalance: \"\",\n    balance: \"\",\n  };\n}\n\nexport const UnbondingDelegationEntry = {\n  encode(\n    message: UnbondingDelegationEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): UnbondingDelegationEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUnbondingDelegationEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64() as Long;\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UnbondingDelegationEntry {\n    return {\n      creationHeight: isSet(object.creationHeight)\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO,\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n      initialBalance: isSet(object.initialBalance)\n        ? String(object.initialBalance)\n        : \"\",\n      balance: isSet(object.balance) ? String(object.balance) : \"\",\n    };\n  },\n\n  toJSON(message: UnbondingDelegationEntry): unknown {\n    const obj: any = {};\n    message.creationHeight !== undefined &&\n      (obj.creationHeight = (message.creationHeight || Long.ZERO).toString());\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined &&\n      (obj.initialBalance = message.initialBalance);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<UnbondingDelegationEntry>, I>>(\n    object: I\n  ): UnbondingDelegationEntry {\n    const message = createBaseUnbondingDelegationEntry();\n    message.creationHeight =\n      object.creationHeight !== undefined && object.creationHeight !== null\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO;\n    message.completionTime = object.completionTime ?? undefined;\n    message.initialBalance = object.initialBalance ?? \"\";\n    message.balance = object.balance ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegationEntry(): RedelegationEntry {\n  return {\n    creationHeight: Long.ZERO,\n    completionTime: undefined,\n    initialBalance: \"\",\n    sharesDst: \"\",\n  };\n}\n\nexport const RedelegationEntry = {\n  encode(\n    message: RedelegationEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.sharesDst !== \"\") {\n      writer.uint32(34).string(message.sharesDst);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RedelegationEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64() as Long;\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.sharesDst = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationEntry {\n    return {\n      creationHeight: isSet(object.creationHeight)\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO,\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n      initialBalance: isSet(object.initialBalance)\n        ? String(object.initialBalance)\n        : \"\",\n      sharesDst: isSet(object.sharesDst) ? String(object.sharesDst) : \"\",\n    };\n  },\n\n  toJSON(message: RedelegationEntry): unknown {\n    const obj: any = {};\n    message.creationHeight !== undefined &&\n      (obj.creationHeight = (message.creationHeight || Long.ZERO).toString());\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined &&\n      (obj.initialBalance = message.initialBalance);\n    message.sharesDst !== undefined && (obj.sharesDst = message.sharesDst);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationEntry>, I>>(\n    object: I\n  ): RedelegationEntry {\n    const message = createBaseRedelegationEntry();\n    message.creationHeight =\n      object.creationHeight !== undefined && object.creationHeight !== null\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO;\n    message.completionTime = object.completionTime ?? undefined;\n    message.initialBalance = object.initialBalance ?? \"\";\n    message.sharesDst = object.sharesDst ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegation(): Redelegation {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    entries: [],\n  };\n}\n\nexport const Redelegation = {\n  encode(\n    message: Redelegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    for (const v of message.entries) {\n      RedelegationEntry.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Redelegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.entries.push(\n            RedelegationEntry.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Redelegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => RedelegationEntry.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Redelegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? RedelegationEntry.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Redelegation>, I>>(\n    object: I\n  ): Redelegation {\n    const message = createBaseRedelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    message.entries =\n      object.entries?.map((e) => RedelegationEntry.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseParams(): Params {\n  return {\n    unbondingTime: undefined,\n    maxValidators: 0,\n    maxEntries: 0,\n    historicalEntries: 0,\n    bondDenom: \"\",\n  };\n}\n\nexport const Params = {\n  encode(\n    message: Params,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.unbondingTime !== undefined) {\n      Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxValidators !== 0) {\n      writer.uint32(16).uint32(message.maxValidators);\n    }\n    if (message.maxEntries !== 0) {\n      writer.uint32(24).uint32(message.maxEntries);\n    }\n    if (message.historicalEntries !== 0) {\n      writer.uint32(32).uint32(message.historicalEntries);\n    }\n    if (message.bondDenom !== \"\") {\n      writer.uint32(42).string(message.bondDenom);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Params {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.unbondingTime = Duration.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.maxValidators = reader.uint32();\n          break;\n        case 3:\n          message.maxEntries = reader.uint32();\n          break;\n        case 4:\n          message.historicalEntries = reader.uint32();\n          break;\n        case 5:\n          message.bondDenom = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Params {\n    return {\n      unbondingTime: isSet(object.unbondingTime)\n        ? Duration.fromJSON(object.unbondingTime)\n        : undefined,\n      maxValidators: isSet(object.maxValidators)\n        ? Number(object.maxValidators)\n        : 0,\n      maxEntries: isSet(object.maxEntries) ? Number(object.maxEntries) : 0,\n      historicalEntries: isSet(object.historicalEntries)\n        ? Number(object.historicalEntries)\n        : 0,\n      bondDenom: isSet(object.bondDenom) ? String(object.bondDenom) : \"\",\n    };\n  },\n\n  toJSON(message: Params): unknown {\n    const obj: any = {};\n    message.unbondingTime !== undefined &&\n      (obj.unbondingTime = message.unbondingTime\n        ? Duration.toJSON(message.unbondingTime)\n        : undefined);\n    message.maxValidators !== undefined &&\n      (obj.maxValidators = Math.round(message.maxValidators));\n    message.maxEntries !== undefined &&\n      (obj.maxEntries = Math.round(message.maxEntries));\n    message.historicalEntries !== undefined &&\n      (obj.historicalEntries = Math.round(message.historicalEntries));\n    message.bondDenom !== undefined && (obj.bondDenom = message.bondDenom);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {\n    const message = createBaseParams();\n    message.unbondingTime =\n      object.unbondingTime !== undefined && object.unbondingTime !== null\n        ? Duration.fromPartial(object.unbondingTime)\n        : undefined;\n    message.maxValidators = object.maxValidators ?? 0;\n    message.maxEntries = object.maxEntries ?? 0;\n    message.historicalEntries = object.historicalEntries ?? 0;\n    message.bondDenom = object.bondDenom ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDelegationResponse(): DelegationResponse {\n  return { delegation: undefined, balance: undefined };\n}\n\nexport const DelegationResponse = {\n  encode(\n    message: DelegationResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegation !== undefined) {\n      Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.balance !== undefined) {\n      Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DelegationResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDelegationResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegation = Delegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.balance = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DelegationResponse {\n    return {\n      delegation: isSet(object.delegation)\n        ? Delegation.fromJSON(object.delegation)\n        : undefined,\n      balance: isSet(object.balance)\n        ? Coin.fromJSON(object.balance)\n        : undefined,\n    };\n  },\n\n  toJSON(message: DelegationResponse): unknown {\n    const obj: any = {};\n    message.delegation !== undefined &&\n      (obj.delegation = message.delegation\n        ? Delegation.toJSON(message.delegation)\n        : undefined);\n    message.balance !== undefined &&\n      (obj.balance = message.balance\n        ? Coin.toJSON(message.balance)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DelegationResponse>, I>>(\n    object: I\n  ): DelegationResponse {\n    const message = createBaseDelegationResponse();\n    message.delegation =\n      object.delegation !== undefined && object.delegation !== null\n        ? Delegation.fromPartial(object.delegation)\n        : undefined;\n    message.balance =\n      object.balance !== undefined && object.balance !== null\n        ? Coin.fromPartial(object.balance)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseRedelegationEntryResponse(): RedelegationEntryResponse {\n  return { redelegationEntry: undefined, balance: \"\" };\n}\n\nexport const RedelegationEntryResponse = {\n  encode(\n    message: RedelegationEntryResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.redelegationEntry !== undefined) {\n      RedelegationEntry.encode(\n        message.redelegationEntry,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RedelegationEntryResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationEntryResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegationEntry = RedelegationEntry.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationEntryResponse {\n    return {\n      redelegationEntry: isSet(object.redelegationEntry)\n        ? RedelegationEntry.fromJSON(object.redelegationEntry)\n        : undefined,\n      balance: isSet(object.balance) ? String(object.balance) : \"\",\n    };\n  },\n\n  toJSON(message: RedelegationEntryResponse): unknown {\n    const obj: any = {};\n    message.redelegationEntry !== undefined &&\n      (obj.redelegationEntry = message.redelegationEntry\n        ? RedelegationEntry.toJSON(message.redelegationEntry)\n        : undefined);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationEntryResponse>, I>>(\n    object: I\n  ): RedelegationEntryResponse {\n    const message = createBaseRedelegationEntryResponse();\n    message.redelegationEntry =\n      object.redelegationEntry !== undefined &&\n      object.redelegationEntry !== null\n        ? RedelegationEntry.fromPartial(object.redelegationEntry)\n        : undefined;\n    message.balance = object.balance ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegationResponse(): RedelegationResponse {\n  return { redelegation: undefined, entries: [] };\n}\n\nexport const RedelegationResponse = {\n  encode(\n    message: RedelegationResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.redelegation !== undefined) {\n      Redelegation.encode(\n        message.redelegation,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.entries) {\n      RedelegationEntryResponse.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RedelegationResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegation = Redelegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.entries.push(\n            RedelegationEntryResponse.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationResponse {\n    return {\n      redelegation: isSet(object.redelegation)\n        ? Redelegation.fromJSON(object.redelegation)\n        : undefined,\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => RedelegationEntryResponse.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RedelegationResponse): unknown {\n    const obj: any = {};\n    message.redelegation !== undefined &&\n      (obj.redelegation = message.redelegation\n        ? Redelegation.toJSON(message.redelegation)\n        : undefined);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? RedelegationEntryResponse.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationResponse>, I>>(\n    object: I\n  ): RedelegationResponse {\n    const message = createBaseRedelegationResponse();\n    message.redelegation =\n      object.redelegation !== undefined && object.redelegation !== null\n        ? Redelegation.fromPartial(object.redelegation)\n        : undefined;\n    message.entries =\n      object.entries?.map((e) => RedelegationEntryResponse.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\nfunction createBasePool(): Pool {\n  return { notBondedTokens: \"\", bondedTokens: \"\" };\n}\n\nexport const Pool = {\n  encode(message: Pool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.notBondedTokens !== \"\") {\n      writer.uint32(10).string(message.notBondedTokens);\n    }\n    if (message.bondedTokens !== \"\") {\n      writer.uint32(18).string(message.bondedTokens);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Pool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.notBondedTokens = reader.string();\n          break;\n        case 2:\n          message.bondedTokens = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Pool {\n    return {\n      notBondedTokens: isSet(object.notBondedTokens)\n        ? String(object.notBondedTokens)\n        : \"\",\n      bondedTokens: isSet(object.bondedTokens)\n        ? String(object.bondedTokens)\n        : \"\",\n    };\n  },\n\n  toJSON(message: Pool): unknown {\n    const obj: any = {};\n    message.notBondedTokens !== undefined &&\n      (obj.notBondedTokens = message.notBondedTokens);\n    message.bondedTokens !== undefined &&\n      (obj.bondedTokens = message.bondedTokens);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Pool>, I>>(object: I): Pool {\n    const message = createBasePool();\n    message.notBondedTokens = object.notBondedTokens ?? \"\";\n    message.bondedTokens = object.bondedTokens ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.crypto\";\n\nexport interface Proof {\n  total: Long;\n  index: Long;\n  leafHash: Uint8Array;\n  aunts: Uint8Array[];\n}\n\nexport interface ValueOp {\n  /** Encoded in ProofOp.Key. */\n  key: Uint8Array;\n  /** To encode in ProofOp.Data */\n  proof?: Proof;\n}\n\nexport interface DominoOp {\n  key: string;\n  input: string;\n  output: string;\n}\n\n/**\n * ProofOp defines an operation used for calculating Merkle root\n * The data could be arbitrary format, providing nessecary data\n * for example neighbouring node hash\n */\nexport interface ProofOp {\n  type: string;\n  key: Uint8Array;\n  data: Uint8Array;\n}\n\n/** ProofOps is Merkle proof defined by the list of ProofOps */\nexport interface ProofOps {\n  ops: ProofOp[];\n}\n\nfunction createBaseProof(): Proof {\n  return {\n    total: Long.ZERO,\n    index: Long.ZERO,\n    leafHash: new Uint8Array(),\n    aunts: [],\n  };\n}\n\nexport const Proof = {\n  encode(message: Proof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.total.isZero()) {\n      writer.uint32(8).int64(message.total);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(16).int64(message.index);\n    }\n    if (message.leafHash.length !== 0) {\n      writer.uint32(26).bytes(message.leafHash);\n    }\n    for (const v of message.aunts) {\n      writer.uint32(34).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proof {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.int64() as Long;\n          break;\n        case 2:\n          message.index = reader.int64() as Long;\n          break;\n        case 3:\n          message.leafHash = reader.bytes();\n          break;\n        case 4:\n          message.aunts.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proof {\n    return {\n      total: isSet(object.total) ? Long.fromValue(object.total) : Long.ZERO,\n      index: isSet(object.index) ? Long.fromValue(object.index) : Long.ZERO,\n      leafHash: isSet(object.leafHash)\n        ? bytesFromBase64(object.leafHash)\n        : new Uint8Array(),\n      aunts: Array.isArray(object?.aunts)\n        ? object.aunts.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Proof): unknown {\n    const obj: any = {};\n    message.total !== undefined &&\n      (obj.total = (message.total || Long.ZERO).toString());\n    message.index !== undefined &&\n      (obj.index = (message.index || Long.ZERO).toString());\n    message.leafHash !== undefined &&\n      (obj.leafHash = base64FromBytes(\n        message.leafHash !== undefined ? message.leafHash : new Uint8Array()\n      ));\n    if (message.aunts) {\n      obj.aunts = message.aunts.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.aunts = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proof>, I>>(object: I): Proof {\n    const message = createBaseProof();\n    message.total =\n      object.total !== undefined && object.total !== null\n        ? Long.fromValue(object.total)\n        : Long.ZERO;\n    message.index =\n      object.index !== undefined && object.index !== null\n        ? Long.fromValue(object.index)\n        : Long.ZERO;\n    message.leafHash = object.leafHash ?? new Uint8Array();\n    message.aunts = object.aunts?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseValueOp(): ValueOp {\n  return { key: new Uint8Array(), proof: undefined };\n}\n\nexport const ValueOp = {\n  encode(\n    message: ValueOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValueOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValueOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValueOp {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: ValueOp): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValueOp>, I>>(object: I): ValueOp {\n    const message = createBaseValueOp();\n    message.key = object.key ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseDominoOp(): DominoOp {\n  return { key: \"\", input: \"\", output: \"\" };\n}\n\nexport const DominoOp = {\n  encode(\n    message: DominoOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.input !== \"\") {\n      writer.uint32(18).string(message.input);\n    }\n    if (message.output !== \"\") {\n      writer.uint32(26).string(message.output);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DominoOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDominoOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.input = reader.string();\n          break;\n        case 3:\n          message.output = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DominoOp {\n    return {\n      key: isSet(object.key) ? String(object.key) : \"\",\n      input: isSet(object.input) ? String(object.input) : \"\",\n      output: isSet(object.output) ? String(object.output) : \"\",\n    };\n  },\n\n  toJSON(message: DominoOp): unknown {\n    const obj: any = {};\n    message.key !== undefined && (obj.key = message.key);\n    message.input !== undefined && (obj.input = message.input);\n    message.output !== undefined && (obj.output = message.output);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DominoOp>, I>>(object: I): DominoOp {\n    const message = createBaseDominoOp();\n    message.key = object.key ?? \"\";\n    message.input = object.input ?? \"\";\n    message.output = object.output ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseProofOp(): ProofOp {\n  return { type: \"\", key: new Uint8Array(), data: new Uint8Array() };\n}\n\nexport const ProofOp = {\n  encode(\n    message: ProofOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.key.length !== 0) {\n      writer.uint32(18).bytes(message.key);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(26).bytes(message.data);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.key = reader.bytes();\n          break;\n        case 3:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ProofOp {\n    return {\n      type: isSet(object.type) ? String(object.type) : \"\",\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: ProofOp): unknown {\n    const obj: any = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ProofOp>, I>>(object: I): ProofOp {\n    const message = createBaseProofOp();\n    message.type = object.type ?? \"\";\n    message.key = object.key ?? new Uint8Array();\n    message.data = object.data ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseProofOps(): ProofOps {\n  return { ops: [] };\n}\n\nexport const ProofOps = {\n  encode(\n    message: ProofOps,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.ops) {\n      ProofOp.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOps {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofOps();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ops.push(ProofOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ProofOps {\n    return {\n      ops: Array.isArray(object?.ops)\n        ? object.ops.map((e: any) => ProofOp.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ProofOps): unknown {\n    const obj: any = {};\n    if (message.ops) {\n      obj.ops = message.ops.map((e) => (e ? ProofOp.toJSON(e) : undefined));\n    } else {\n      obj.ops = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ProofOps>, I>>(object: I): ProofOps {\n    const message = createBaseProofOps();\n    message.ops = object.ops?.map((e) => ProofOp.fromPartial(e)) || [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.version\";\n\n/**\n * App includes the protocol and software version for the application.\n * This information is included in ResponseInfo. The App.Protocol can be\n * updated in ResponseEndBlock.\n */\nexport interface App {\n  protocol: Long;\n  software: string;\n}\n\n/**\n * Consensus captures the consensus rules for processing a block in the\n * blockchain, including all blockchain data structures and the rules of the\n * application's state transition machine.\n */\nexport interface Consensus {\n  block: Long;\n  app: Long;\n}\n\nfunction createBaseApp(): App {\n  return { protocol: Long.UZERO, software: \"\" };\n}\n\nexport const App = {\n  encode(message: App, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.protocol.isZero()) {\n      writer.uint32(8).uint64(message.protocol);\n    }\n    if (message.software !== \"\") {\n      writer.uint32(18).string(message.software);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): App {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseApp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.protocol = reader.uint64() as Long;\n          break;\n        case 2:\n          message.software = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): App {\n    return {\n      protocol: isSet(object.protocol)\n        ? Long.fromValue(object.protocol)\n        : Long.UZERO,\n      software: isSet(object.software) ? String(object.software) : \"\",\n    };\n  },\n\n  toJSON(message: App): unknown {\n    const obj: any = {};\n    message.protocol !== undefined &&\n      (obj.protocol = (message.protocol || Long.UZERO).toString());\n    message.software !== undefined && (obj.software = message.software);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<App>, I>>(object: I): App {\n    const message = createBaseApp();\n    message.protocol =\n      object.protocol !== undefined && object.protocol !== null\n        ? Long.fromValue(object.protocol)\n        : Long.UZERO;\n    message.software = object.software ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseConsensus(): Consensus {\n  return { block: Long.UZERO, app: Long.UZERO };\n}\n\nexport const Consensus = {\n  encode(\n    message: Consensus,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.block.isZero()) {\n      writer.uint32(8).uint64(message.block);\n    }\n    if (!message.app.isZero()) {\n      writer.uint32(16).uint64(message.app);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Consensus {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseConsensus();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.block = reader.uint64() as Long;\n          break;\n        case 2:\n          message.app = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Consensus {\n    return {\n      block: isSet(object.block) ? Long.fromValue(object.block) : Long.UZERO,\n      app: isSet(object.app) ? Long.fromValue(object.app) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: Consensus): unknown {\n    const obj: any = {};\n    message.block !== undefined &&\n      (obj.block = (message.block || Long.UZERO).toString());\n    message.app !== undefined &&\n      (obj.app = (message.app || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Consensus>, I>>(\n    object: I\n  ): Consensus {\n    const message = createBaseConsensus();\n    message.block =\n      object.block !== undefined && object.block !== null\n        ? Long.fromValue(object.block)\n        : Long.UZERO;\n    message.app =\n      object.app !== undefined && object.app !== null\n        ? Long.fromValue(object.app)\n        : Long.UZERO;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.crypto\";\n\n/** PublicKey defines the keys available for use with Tendermint Validators */\nexport interface PublicKey {\n  ed25519: Uint8Array | undefined;\n  secp256k1: Uint8Array | undefined;\n}\n\nfunction createBasePublicKey(): PublicKey {\n  return { ed25519: undefined, secp256k1: undefined };\n}\n\nexport const PublicKey = {\n  encode(\n    message: PublicKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.ed25519 !== undefined) {\n      writer.uint32(10).bytes(message.ed25519);\n    }\n    if (message.secp256k1 !== undefined) {\n      writer.uint32(18).bytes(message.secp256k1);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PublicKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePublicKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ed25519 = reader.bytes();\n          break;\n        case 2:\n          message.secp256k1 = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PublicKey {\n    return {\n      ed25519: isSet(object.ed25519)\n        ? bytesFromBase64(object.ed25519)\n        : undefined,\n      secp256k1: isSet(object.secp256k1)\n        ? bytesFromBase64(object.secp256k1)\n        : undefined,\n    };\n  },\n\n  toJSON(message: PublicKey): unknown {\n    const obj: any = {};\n    message.ed25519 !== undefined &&\n      (obj.ed25519 =\n        message.ed25519 !== undefined\n          ? base64FromBytes(message.ed25519)\n          : undefined);\n    message.secp256k1 !== undefined &&\n      (obj.secp256k1 =\n        message.secp256k1 !== undefined\n          ? base64FromBytes(message.secp256k1)\n          : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PublicKey>, I>>(\n    object: I\n  ): PublicKey {\n    const message = createBasePublicKey();\n    message.ed25519 = object.ed25519 ?? undefined;\n    message.secp256k1 = object.secp256k1 ?? undefined;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { PublicKey } from \"../crypto/keys\";\n\nexport const protobufPackage = \"tendermint.types\";\n\nexport interface ValidatorSet {\n  validators: Validator[];\n  proposer?: Validator;\n  totalVotingPower: Long;\n}\n\nexport interface Validator {\n  address: Uint8Array;\n  pubKey?: PublicKey;\n  votingPower: Long;\n  proposerPriority: Long;\n}\n\nexport interface SimpleValidator {\n  pubKey?: PublicKey;\n  votingPower: Long;\n}\n\nfunction createBaseValidatorSet(): ValidatorSet {\n  return { validators: [], proposer: undefined, totalVotingPower: Long.ZERO };\n}\n\nexport const ValidatorSet = {\n  encode(\n    message: ValidatorSet,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.validators) {\n      Validator.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proposer !== undefined) {\n      Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.totalVotingPower.isZero()) {\n      writer.uint32(24).int64(message.totalVotingPower);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValidatorSet {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidatorSet();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validators.push(Validator.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.proposer = Validator.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.totalVotingPower = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValidatorSet {\n    return {\n      validators: Array.isArray(object?.validators)\n        ? object.validators.map((e: any) => Validator.fromJSON(e))\n        : [],\n      proposer: isSet(object.proposer)\n        ? Validator.fromJSON(object.proposer)\n        : undefined,\n      totalVotingPower: isSet(object.totalVotingPower)\n        ? Long.fromValue(object.totalVotingPower)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: ValidatorSet): unknown {\n    const obj: any = {};\n    if (message.validators) {\n      obj.validators = message.validators.map((e) =>\n        e ? Validator.toJSON(e) : undefined\n      );\n    } else {\n      obj.validators = [];\n    }\n    message.proposer !== undefined &&\n      (obj.proposer = message.proposer\n        ? Validator.toJSON(message.proposer)\n        : undefined);\n    message.totalVotingPower !== undefined &&\n      (obj.totalVotingPower = (\n        message.totalVotingPower || Long.ZERO\n      ).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValidatorSet>, I>>(\n    object: I\n  ): ValidatorSet {\n    const message = createBaseValidatorSet();\n    message.validators =\n      object.validators?.map((e) => Validator.fromPartial(e)) || [];\n    message.proposer =\n      object.proposer !== undefined && object.proposer !== null\n        ? Validator.fromPartial(object.proposer)\n        : undefined;\n    message.totalVotingPower =\n      object.totalVotingPower !== undefined && object.totalVotingPower !== null\n        ? Long.fromValue(object.totalVotingPower)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseValidator(): Validator {\n  return {\n    address: new Uint8Array(),\n    pubKey: undefined,\n    votingPower: Long.ZERO,\n    proposerPriority: Long.ZERO,\n  };\n}\n\nexport const Validator = {\n  encode(\n    message: Validator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address.length !== 0) {\n      writer.uint32(10).bytes(message.address);\n    }\n    if (message.pubKey !== undefined) {\n      PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.votingPower.isZero()) {\n      writer.uint32(24).int64(message.votingPower);\n    }\n    if (!message.proposerPriority.isZero()) {\n      writer.uint32(32).int64(message.proposerPriority);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.bytes();\n          break;\n        case 2:\n          message.pubKey = PublicKey.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.votingPower = reader.int64() as Long;\n          break;\n        case 4:\n          message.proposerPriority = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Validator {\n    return {\n      address: isSet(object.address)\n        ? bytesFromBase64(object.address)\n        : new Uint8Array(),\n      pubKey: isSet(object.pubKey)\n        ? PublicKey.fromJSON(object.pubKey)\n        : undefined,\n      votingPower: isSet(object.votingPower)\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO,\n      proposerPriority: isSet(object.proposerPriority)\n        ? Long.fromValue(object.proposerPriority)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: Validator): unknown {\n    const obj: any = {};\n    message.address !== undefined &&\n      (obj.address = base64FromBytes(\n        message.address !== undefined ? message.address : new Uint8Array()\n      ));\n    message.pubKey !== undefined &&\n      (obj.pubKey = message.pubKey\n        ? PublicKey.toJSON(message.pubKey)\n        : undefined);\n    message.votingPower !== undefined &&\n      (obj.votingPower = (message.votingPower || Long.ZERO).toString());\n    message.proposerPriority !== undefined &&\n      (obj.proposerPriority = (\n        message.proposerPriority || Long.ZERO\n      ).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Validator>, I>>(\n    object: I\n  ): Validator {\n    const message = createBaseValidator();\n    message.address = object.address ?? new Uint8Array();\n    message.pubKey =\n      object.pubKey !== undefined && object.pubKey !== null\n        ? PublicKey.fromPartial(object.pubKey)\n        : undefined;\n    message.votingPower =\n      object.votingPower !== undefined && object.votingPower !== null\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO;\n    message.proposerPriority =\n      object.proposerPriority !== undefined && object.proposerPriority !== null\n        ? Long.fromValue(object.proposerPriority)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseSimpleValidator(): SimpleValidator {\n  return { pubKey: undefined, votingPower: Long.ZERO };\n}\n\nexport const SimpleValidator = {\n  encode(\n    message: SimpleValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.pubKey !== undefined) {\n      PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.votingPower.isZero()) {\n      writer.uint32(16).int64(message.votingPower);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SimpleValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSimpleValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pubKey = PublicKey.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.votingPower = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SimpleValidator {\n    return {\n      pubKey: isSet(object.pubKey)\n        ? PublicKey.fromJSON(object.pubKey)\n        : undefined,\n      votingPower: isSet(object.votingPower)\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: SimpleValidator): unknown {\n    const obj: any = {};\n    message.pubKey !== undefined &&\n      (obj.pubKey = message.pubKey\n        ? PublicKey.toJSON(message.pubKey)\n        : undefined);\n    message.votingPower !== undefined &&\n      (obj.votingPower = (message.votingPower || Long.ZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SimpleValidator>, I>>(\n    object: I\n  ): SimpleValidator {\n    const message = createBaseSimpleValidator();\n    message.pubKey =\n      object.pubKey !== undefined && object.pubKey !== null\n        ? PublicKey.fromPartial(object.pubKey)\n        : undefined;\n    message.votingPower =\n      object.votingPower !== undefined && object.votingPower !== null\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Description, CommissionRates } from \"./staking\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.staking.v1beta1\";\n\n/** MsgCreateValidator defines a SDK message for creating a new validator. */\nexport interface MsgCreateValidator {\n  description?: Description;\n  commission?: CommissionRates;\n  minSelfDelegation: string;\n  delegatorAddress: string;\n  validatorAddress: string;\n  pubkey?: Any;\n  value?: Coin;\n}\n\n/** MsgCreateValidatorResponse defines the Msg/CreateValidator response type. */\nexport interface MsgCreateValidatorResponse {}\n\n/** MsgEditValidator defines a SDK message for editing an existing validator. */\nexport interface MsgEditValidator {\n  description?: Description;\n  validatorAddress: string;\n  /**\n   * We pass a reference to the new commission rate and min self delegation as\n   * it's not mandatory to update. If not updated, the deserialized rate will be\n   * zero with no way to distinguish if an update was intended.\n   * REF: #2373\n   */\n  commissionRate: string;\n  minSelfDelegation: string;\n}\n\n/** MsgEditValidatorResponse defines the Msg/EditValidator response type. */\nexport interface MsgEditValidatorResponse {}\n\n/**\n * MsgDelegate defines a SDK message for performing a delegation of coins\n * from a delegator to a validator.\n */\nexport interface MsgDelegate {\n  delegatorAddress: string;\n  validatorAddress: string;\n  amount?: Coin;\n}\n\n/** MsgDelegateResponse defines the Msg/Delegate response type. */\nexport interface MsgDelegateResponse {}\n\n/**\n * MsgBeginRedelegate defines a SDK message for performing a redelegation\n * of coins from a delegator and source validator to a destination validator.\n */\nexport interface MsgBeginRedelegate {\n  delegatorAddress: string;\n  validatorSrcAddress: string;\n  validatorDstAddress: string;\n  amount?: Coin;\n}\n\n/** MsgBeginRedelegateResponse defines the Msg/BeginRedelegate response type. */\nexport interface MsgBeginRedelegateResponse {\n  completionTime?: Date;\n}\n\n/**\n * MsgUndelegate defines a SDK message for performing an undelegation from a\n * delegate and a validator.\n */\nexport interface MsgUndelegate {\n  delegatorAddress: string;\n  validatorAddress: string;\n  amount?: Coin;\n}\n\n/** MsgUndelegateResponse defines the Msg/Undelegate response type. */\nexport interface MsgUndelegateResponse {\n  completionTime?: Date;\n}\n\nfunction createBaseMsgCreateValidator(): MsgCreateValidator {\n  return {\n    description: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    pubkey: undefined,\n    value: undefined,\n  };\n}\n\nexport const MsgCreateValidator = {\n  encode(\n    message: MsgCreateValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.commission !== undefined) {\n      CommissionRates.encode(\n        message.commission,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(26).string(message.minSelfDelegation);\n    }\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(34).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(42).string(message.validatorAddress);\n    }\n    if (message.pubkey !== undefined) {\n      Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.value !== undefined) {\n      Coin.encode(message.value, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commission = CommissionRates.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.minSelfDelegation = reader.string();\n          break;\n        case 4:\n          message.delegatorAddress = reader.string();\n          break;\n        case 5:\n          message.validatorAddress = reader.string();\n          break;\n        case 6:\n          message.pubkey = Any.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.value = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateValidator {\n    return {\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      commission: isSet(object.commission)\n        ? CommissionRates.fromJSON(object.commission)\n        : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      pubkey: isSet(object.pubkey) ? Any.fromJSON(object.pubkey) : undefined,\n      value: isSet(object.value) ? Coin.fromJSON(object.value) : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateValidator): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.commission !== undefined &&\n      (obj.commission = message.commission\n        ? CommissionRates.toJSON(message.commission)\n        : undefined);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.pubkey !== undefined &&\n      (obj.pubkey = message.pubkey ? Any.toJSON(message.pubkey) : undefined);\n    message.value !== undefined &&\n      (obj.value = message.value ? Coin.toJSON(message.value) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateValidator>, I>>(\n    object: I\n  ): MsgCreateValidator {\n    const message = createBaseMsgCreateValidator();\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.commission =\n      object.commission !== undefined && object.commission !== null\n        ? CommissionRates.fromPartial(object.commission)\n        : undefined;\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.pubkey =\n      object.pubkey !== undefined && object.pubkey !== null\n        ? Any.fromPartial(object.pubkey)\n        : undefined;\n    message.value =\n      object.value !== undefined && object.value !== null\n        ? Coin.fromPartial(object.value)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateValidatorResponse(): MsgCreateValidatorResponse {\n  return {};\n}\n\nexport const MsgCreateValidatorResponse = {\n  encode(\n    _: MsgCreateValidatorResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateValidatorResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateValidatorResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateValidatorResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateValidatorResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateValidatorResponse>, I>>(\n    _: I\n  ): MsgCreateValidatorResponse {\n    const message = createBaseMsgCreateValidatorResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgEditValidator(): MsgEditValidator {\n  return {\n    description: undefined,\n    validatorAddress: \"\",\n    commissionRate: \"\",\n    minSelfDelegation: \"\",\n  };\n}\n\nexport const MsgEditValidator = {\n  encode(\n    message: MsgEditValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.commissionRate !== \"\") {\n      writer.uint32(26).string(message.commissionRate);\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(34).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEditValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.commissionRate = reader.string();\n          break;\n        case 4:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgEditValidator {\n    return {\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      commissionRate: isSet(object.commissionRate)\n        ? String(object.commissionRate)\n        : \"\",\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgEditValidator): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.commissionRate !== undefined &&\n      (obj.commissionRate = message.commissionRate);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEditValidator>, I>>(\n    object: I\n  ): MsgEditValidator {\n    const message = createBaseMsgEditValidator();\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.commissionRate = object.commissionRate ?? \"\";\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgEditValidatorResponse(): MsgEditValidatorResponse {\n  return {};\n}\n\nexport const MsgEditValidatorResponse = {\n  encode(\n    _: MsgEditValidatorResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgEditValidatorResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEditValidatorResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgEditValidatorResponse {\n    return {};\n  },\n\n  toJSON(_: MsgEditValidatorResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEditValidatorResponse>, I>>(\n    _: I\n  ): MsgEditValidatorResponse {\n    const message = createBaseMsgEditValidatorResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDelegate(): MsgDelegate {\n  return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\n\nexport const MsgDelegate = {\n  encode(\n    message: MsgDelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgDelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDelegate>, I>>(\n    object: I\n  ): MsgDelegate {\n    const message = createBaseMsgDelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDelegateResponse(): MsgDelegateResponse {\n  return {};\n}\n\nexport const MsgDelegateResponse = {\n  encode(\n    _: MsgDelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDelegateResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDelegateResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDelegateResponse>, I>>(\n    _: I\n  ): MsgDelegateResponse {\n    const message = createBaseMsgDelegateResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgBeginRedelegate(): MsgBeginRedelegate {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    amount: undefined,\n  };\n}\n\nexport const MsgBeginRedelegate = {\n  encode(\n    message: MsgBeginRedelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBeginRedelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBeginRedelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBeginRedelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgBeginRedelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBeginRedelegate>, I>>(\n    object: I\n  ): MsgBeginRedelegate {\n    const message = createBaseMsgBeginRedelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgBeginRedelegateResponse(): MsgBeginRedelegateResponse {\n  return { completionTime: undefined };\n}\n\nexport const MsgBeginRedelegateResponse = {\n  encode(\n    message: MsgBeginRedelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgBeginRedelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBeginRedelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBeginRedelegateResponse {\n    return {\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgBeginRedelegateResponse): unknown {\n    const obj: any = {};\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBeginRedelegateResponse>, I>>(\n    object: I\n  ): MsgBeginRedelegateResponse {\n    const message = createBaseMsgBeginRedelegateResponse();\n    message.completionTime = object.completionTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUndelegate(): MsgUndelegate {\n  return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\n\nexport const MsgUndelegate = {\n  encode(\n    message: MsgUndelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUndelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUndelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUndelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgUndelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUndelegate>, I>>(\n    object: I\n  ): MsgUndelegate {\n    const message = createBaseMsgUndelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUndelegateResponse(): MsgUndelegateResponse {\n  return { completionTime: undefined };\n}\n\nexport const MsgUndelegateResponse = {\n  encode(\n    message: MsgUndelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUndelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUndelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUndelegateResponse {\n    return {\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUndelegateResponse): unknown {\n    const obj: any = {};\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUndelegateResponse>, I>>(\n    object: I\n  ): MsgUndelegateResponse {\n    const message = createBaseMsgUndelegateResponse();\n    message.completionTime = object.completionTime ?? undefined;\n    return message;\n  },\n};\n\n/** Msg defines the staking Msg service. */\nexport interface Msg {\n  /** CreateValidator defines a method for creating a new validator. */\n  CreateValidator(\n    request: DeepPartial<MsgCreateValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateValidatorResponse>;\n  /** EditValidator defines a method for editing an existing validator. */\n  EditValidator(\n    request: DeepPartial<MsgEditValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEditValidatorResponse>;\n  /**\n   * Delegate defines a method for performing a delegation of coins\n   * from a delegator to a validator.\n   */\n  Delegate(\n    request: DeepPartial<MsgDelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDelegateResponse>;\n  /**\n   * BeginRedelegate defines a method for performing a redelegation\n   * of coins from a delegator and source validator to a destination validator.\n   */\n  BeginRedelegate(\n    request: DeepPartial<MsgBeginRedelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBeginRedelegateResponse>;\n  /**\n   * Undelegate defines a method for performing an undelegation from a\n   * delegate and a validator.\n   */\n  Undelegate(\n    request: DeepPartial<MsgUndelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUndelegateResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreateValidator = this.CreateValidator.bind(this);\n    this.EditValidator = this.EditValidator.bind(this);\n    this.Delegate = this.Delegate.bind(this);\n    this.BeginRedelegate = this.BeginRedelegate.bind(this);\n    this.Undelegate = this.Undelegate.bind(this);\n  }\n\n  CreateValidator(\n    request: DeepPartial<MsgCreateValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateValidatorResponse> {\n    return this.rpc.unary(\n      MsgCreateValidatorDesc,\n      MsgCreateValidator.fromPartial(request),\n      metadata\n    );\n  }\n\n  EditValidator(\n    request: DeepPartial<MsgEditValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEditValidatorResponse> {\n    return this.rpc.unary(\n      MsgEditValidatorDesc,\n      MsgEditValidator.fromPartial(request),\n      metadata\n    );\n  }\n\n  Delegate(\n    request: DeepPartial<MsgDelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDelegateResponse> {\n    return this.rpc.unary(\n      MsgDelegateDesc,\n      MsgDelegate.fromPartial(request),\n      metadata\n    );\n  }\n\n  BeginRedelegate(\n    request: DeepPartial<MsgBeginRedelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBeginRedelegateResponse> {\n    return this.rpc.unary(\n      MsgBeginRedelegateDesc,\n      MsgBeginRedelegate.fromPartial(request),\n      metadata\n    );\n  }\n\n  Undelegate(\n    request: DeepPartial<MsgUndelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUndelegateResponse> {\n    return this.rpc.unary(\n      MsgUndelegateDesc,\n      MsgUndelegate.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.staking.v1beta1.Msg\",\n};\n\nexport const MsgCreateValidatorDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateValidator\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateValidator.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateValidatorResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgEditValidatorDesc: UnaryMethodDefinitionish = {\n  methodName: \"EditValidator\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgEditValidator.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgEditValidatorResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"Delegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgBeginRedelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"BeginRedelegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgBeginRedelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgBeginRedelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUndelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"Undelegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUndelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUndelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from './BaseMsg';\nimport {\n  protobufPackage,\n  MsgCreateValidator as MsgCreateValidator_pb,\n  MsgEditValidator as MsgEditValidator_pb,\n  MsgDelegate as MsgDelegate_pb,\n  MsgBeginRedelegate as MsgBeginRedelegate_pb,\n  MsgUndelegate as MsgUndelegate_pb\n} from \"../proto/cosmos/staking/v1beta1/tx\";\nimport {EncodeObject} from \"@cosmjs/proto-signing\";\n\nexport class MsgCreateValidator extends BaseMsg {\n  public protoMsg: MsgCreateValidator_pb;\n  constructor(msg: MsgCreateValidator_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateValidator.typeUrl,\n      value: MsgCreateValidator_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreateValidator {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreateValidator`;\n  export const Proto = MsgCreateValidator_pb;\n  export interface Proto extends MsgCreateValidator_pb {}\n}\n\nexport class MsgEditValidator extends BaseMsg {\n  public protoMsg: MsgEditValidator_pb;\n  constructor(msg: MsgEditValidator_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgEditValidator.typeUrl,\n      value: MsgEditValidator_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgEditValidator {\n  export const typeUrl: string = `/${protobufPackage}.MsgEditValidator`;\n  export const Proto = MsgEditValidator_pb;\n  export interface Proto extends MsgEditValidator_pb {}\n}\n\nexport class MsgDelegate extends BaseMsg {\n  public protoMsg: MsgDelegate_pb;\n  constructor(msg: MsgDelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDelegate.typeUrl,\n      value: MsgDelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDelegate {\n  export const typeUrl: string = `/${protobufPackage}.MsgDelegate`;\n  export const Proto = MsgDelegate_pb;\n  export interface Proto extends MsgDelegate_pb {}\n}\n\nexport class MsgBeginRedelegate extends BaseMsg {\n  public protoMsg: MsgBeginRedelegate_pb;\n  constructor(msg: MsgBeginRedelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgBeginRedelegate.typeUrl,\n      value: MsgBeginRedelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgBeginRedelegate {\n  export const typeUrl: string = `/${protobufPackage}.MsgBeginRedelegate`;\n  export const Proto = MsgBeginRedelegate_pb;\n  export interface Proto extends MsgBeginRedelegate_pb {}\n}\n\nexport class MsgUndelegate extends BaseMsg {\n  public protoMsg: MsgUndelegate_pb;\n  constructor(msg: MsgUndelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgUndelegate.typeUrl,\n      value: MsgUndelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgUndelegate {\n  export const typeUrl: string = `/${protobufPackage}.MsgUndelegate`;\n  export const Proto = MsgUndelegate_pb;\n  export interface Proto extends MsgUndelegate_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.multisig.v1beta1\";\n\n/**\n * MultiSignature wraps the signatures from a multisig.LegacyAminoPubKey.\n * See cosmos.tx.v1betata1.ModeInfo.Multi for how to specify which signers\n * signed and with which modes.\n */\nexport interface MultiSignature {\n  signatures: Uint8Array[];\n}\n\n/**\n * CompactBitArray is an implementation of a space efficient bit array.\n * This is used to ensure that the encoded data takes up a minimal amount of\n * space after proto encoding.\n * This is not thread safe, and is not intended for concurrent usage.\n */\nexport interface CompactBitArray {\n  extraBitsStored: number;\n  elems: Uint8Array;\n}\n\nfunction createBaseMultiSignature(): MultiSignature {\n  return { signatures: [] };\n}\n\nexport const MultiSignature = {\n  encode(\n    message: MultiSignature,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MultiSignature {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMultiSignature();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MultiSignature {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MultiSignature): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MultiSignature>, I>>(\n    object: I\n  ): MultiSignature {\n    const message = createBaseMultiSignature();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseCompactBitArray(): CompactBitArray {\n  return { extraBitsStored: 0, elems: new Uint8Array() };\n}\n\nexport const CompactBitArray = {\n  encode(\n    message: CompactBitArray,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.extraBitsStored !== 0) {\n      writer.uint32(8).uint32(message.extraBitsStored);\n    }\n    if (message.elems.length !== 0) {\n      writer.uint32(18).bytes(message.elems);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CompactBitArray {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompactBitArray();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.extraBitsStored = reader.uint32();\n          break;\n        case 2:\n          message.elems = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CompactBitArray {\n    return {\n      extraBitsStored: isSet(object.extraBitsStored)\n        ? Number(object.extraBitsStored)\n        : 0,\n      elems: isSet(object.elems)\n        ? bytesFromBase64(object.elems)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CompactBitArray): unknown {\n    const obj: any = {};\n    message.extraBitsStored !== undefined &&\n      (obj.extraBitsStored = Math.round(message.extraBitsStored));\n    message.elems !== undefined &&\n      (obj.elems = base64FromBytes(\n        message.elems !== undefined ? message.elems : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CompactBitArray>, I>>(\n    object: I\n  ): CompactBitArray {\n    const message = createBaseCompactBitArray();\n    message.extraBitsStored = object.extraBitsStored ?? 0;\n    message.elems = object.elems ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.secp256k1\";\n\n/**\n * PubKey defines a secp256k1 public key\n * Key is the compressed form of the pubkey. The first byte depends is a 0x02 byte\n * if the y-coordinate is the lexicographically largest of the two associated with\n * the x-coordinate. Otherwise the first byte is a 0x03.\n * This prefix is followed with the x-coordinate.\n */\nexport interface PubKey {\n  key: Uint8Array;\n}\n\n/** PrivKey defines a secp256k1 private key. */\nexport interface PrivKey {\n  key: Uint8Array;\n}\n\nfunction createBasePubKey(): PubKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PubKey = {\n  encode(\n    message: PubKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PubKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePubKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PubKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PubKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PubKey>, I>>(object: I): PubKey {\n    const message = createBasePubKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePrivKey(): PrivKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PrivKey = {\n  encode(\n    message: PrivKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PrivKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePrivKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PrivKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PrivKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PrivKey>, I>>(object: I): PrivKey {\n    const message = createBasePrivKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../../google/protobuf/any\";\nimport { CompactBitArray } from \"../../../crypto/multisig/v1beta1/multisig\";\n\nexport const protobufPackage = \"cosmos.tx.signing.v1beta1\";\n\n/** SignMode represents a signing mode with its own security guarantees. */\nexport enum SignMode {\n  /**\n   * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n   * rejected\n   */\n  SIGN_MODE_UNSPECIFIED = 0,\n  /**\n   * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n   * verified with raw bytes from Tx\n   */\n  SIGN_MODE_DIRECT = 1,\n  /**\n   * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n   * human-readable textual representation on top of the binary representation\n   * from SIGN_MODE_DIRECT\n   */\n  SIGN_MODE_TEXTUAL = 2,\n  /**\n   * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n   * Amino JSON and will be removed in the future\n   */\n  SIGN_MODE_LEGACY_AMINO_JSON = 127,\n  /**\n   * SIGN_MODE_EIP_191 - SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\n   * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n   *\n   * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\n   * but is not implemented on the SDK by default. To enable EIP-191, you need\n   * to pass a custom `TxConfig` that has an implementation of\n   * `SignModeHandler` for EIP-191. The SDK may decide to fully support\n   * EIP-191 in the future.\n   *\n   * Since: cosmos-sdk 0.45.2\n   */\n  SIGN_MODE_EIP_191 = 191,\n  UNRECOGNIZED = -1,\n}\n\nexport function signModeFromJSON(object: any): SignMode {\n  switch (object) {\n    case 0:\n    case \"SIGN_MODE_UNSPECIFIED\":\n      return SignMode.SIGN_MODE_UNSPECIFIED;\n    case 1:\n    case \"SIGN_MODE_DIRECT\":\n      return SignMode.SIGN_MODE_DIRECT;\n    case 2:\n    case \"SIGN_MODE_TEXTUAL\":\n      return SignMode.SIGN_MODE_TEXTUAL;\n    case 127:\n    case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n      return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    case 191:\n    case \"SIGN_MODE_EIP_191\":\n      return SignMode.SIGN_MODE_EIP_191;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignMode.UNRECOGNIZED;\n  }\n}\n\nexport function signModeToJSON(object: SignMode): string {\n  switch (object) {\n    case SignMode.SIGN_MODE_UNSPECIFIED:\n      return \"SIGN_MODE_UNSPECIFIED\";\n    case SignMode.SIGN_MODE_DIRECT:\n      return \"SIGN_MODE_DIRECT\";\n    case SignMode.SIGN_MODE_TEXTUAL:\n      return \"SIGN_MODE_TEXTUAL\";\n    case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n      return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    case SignMode.SIGN_MODE_EIP_191:\n      return \"SIGN_MODE_EIP_191\";\n    case SignMode.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignatureDescriptors wraps multiple SignatureDescriptor's. */\nexport interface SignatureDescriptors {\n  /** signatures are the signature descriptors */\n  signatures: SignatureDescriptor[];\n}\n\n/**\n * SignatureDescriptor is a convenience type which represents the full data for\n * a signature including the public key of the signer, signing modes and the\n * signature itself. It is primarily used for coordinating signatures between\n * clients.\n */\nexport interface SignatureDescriptor {\n  /** public_key is the public key of the signer */\n  publicKey?: Any;\n  data?: SignatureDescriptor_Data;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to prevent\n   * replay attacks.\n   */\n  sequence: Long;\n}\n\n/** Data represents signature data */\nexport interface SignatureDescriptor_Data {\n  /** single represents a single signer */\n  single?: SignatureDescriptor_Data_Single | undefined;\n  /** multi represents a multisig signer */\n  multi?: SignatureDescriptor_Data_Multi | undefined;\n}\n\n/** Single is the signature data for a single signer */\nexport interface SignatureDescriptor_Data_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n  /** signature is the raw signature bytes */\n  signature: Uint8Array;\n}\n\n/** Multi is the signature data for a multisig public key */\nexport interface SignatureDescriptor_Data_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /** signatures is the signatures of the multi-signature */\n  signatures: SignatureDescriptor_Data[];\n}\n\nfunction createBaseSignatureDescriptors(): SignatureDescriptors {\n  return { signatures: [] };\n}\n\nexport const SignatureDescriptors = {\n  encode(\n    message: SignatureDescriptors,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      SignatureDescriptor.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptors {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptors();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(\n            SignatureDescriptor.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptors {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => SignatureDescriptor.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptors): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptors>, I>>(\n    object: I\n  ): SignatureDescriptors {\n    const message = createBaseSignatureDescriptors();\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor(): SignatureDescriptor {\n  return { publicKey: undefined, data: undefined, sequence: Long.UZERO };\n}\n\nexport const SignatureDescriptor = {\n  encode(\n    message: SignatureDescriptor,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.data !== undefined) {\n      SignatureDescriptor_Data.encode(\n        message.data,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureDescriptor {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.data = SignatureDescriptor_Data.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      data: isSet(object.data)\n        ? SignatureDescriptor_Data.fromJSON(object.data)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.data !== undefined &&\n      (obj.data = message.data\n        ? SignatureDescriptor_Data.toJSON(message.data)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor>, I>>(\n    object: I\n  ): SignatureDescriptor {\n    const message = createBaseSignatureDescriptor();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.data =\n      object.data !== undefined && object.data !== null\n        ? SignatureDescriptor_Data.fromPartial(object.data)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data(): SignatureDescriptor_Data {\n  return { single: undefined, multi: undefined };\n}\n\nexport const SignatureDescriptor_Data = {\n  encode(\n    message: SignatureDescriptor_Data,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      SignatureDescriptor_Data_Single.encode(\n        message.single,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.multi !== undefined) {\n      SignatureDescriptor_Data_Multi.encode(\n        message.multi,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = SignatureDescriptor_Data_Single.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.multi = SignatureDescriptor_Data_Multi.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data {\n    return {\n      single: isSet(object.single)\n        ? SignatureDescriptor_Data_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? SignatureDescriptor_Data_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? SignatureDescriptor_Data_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? SignatureDescriptor_Data_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data>, I>>(\n    object: I\n  ): SignatureDescriptor_Data {\n    const message = createBaseSignatureDescriptor_Data();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? SignatureDescriptor_Data_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? SignatureDescriptor_Data_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Single(): SignatureDescriptor_Data_Single {\n  return { mode: 0, signature: new Uint8Array() };\n}\n\nexport const SignatureDescriptor_Data_Single = {\n  encode(\n    message: SignatureDescriptor_Data_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(18).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        case 2:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Single>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Single {\n    const message = createBaseSignatureDescriptor_Data_Single();\n    message.mode = object.mode ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Multi(): SignatureDescriptor_Data_Multi {\n  return { bitarray: undefined, signatures: [] };\n}\n\nexport const SignatureDescriptor_Data_Multi = {\n  encode(\n    message: SignatureDescriptor_Data_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.signatures) {\n      SignatureDescriptor_Data.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signatures.push(\n            SignatureDescriptor_Data.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) =>\n            SignatureDescriptor_Data.fromJSON(e)\n          )\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor_Data.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Multi>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Multi {\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor_Data.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  SignMode,\n  signModeFromJSON,\n  signModeToJSON,\n} from \"../signing/v1beta1/signing\";\nimport { CompactBitArray } from \"../../crypto/multisig/v1beta1/multisig\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.tx.v1beta1\";\n\n/** Tx is the standard type used for broadcasting transactions. */\nexport interface Tx {\n  /** body is the processable content of the transaction */\n  body?: TxBody;\n  /**\n   * auth_info is the authorization related content of the transaction,\n   * specifically signers, signer modes and fee\n   */\n  authInfo?: AuthInfo;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/**\n * TxRaw is a variant of Tx that pins the signer's exact binary representation\n * of body and auth_info. This is used for signing, broadcasting and\n * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and\n * the hash `sha256(serialize(tx: TxRaw))` becomes the \"txhash\", commonly used\n * as the transaction ID.\n */\nexport interface TxRaw {\n  /**\n   * body_bytes is a protobuf serialization of a TxBody that matches the\n   * representation in SignDoc.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in SignDoc.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/** SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT. */\nexport interface SignDoc {\n  /**\n   * body_bytes is protobuf serialization of a TxBody that matches the\n   * representation in TxRaw.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in TxRaw.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * chain_id is the unique identifier of the chain this transaction targets.\n   * It prevents signed transactions from being used on another chain by an\n   * attacker\n   */\n  chainId: string;\n  /** account_number is the account number of the account in state */\n  accountNumber: Long;\n}\n\n/** TxBody is the body of a transaction that all signers sign over. */\nexport interface TxBody {\n  /**\n   * messages is a list of messages to be executed. The required signers of\n   * those messages define the number and order of elements in AuthInfo's\n   * signer_infos and Tx's signatures. Each required signer address is added to\n   * the list only the first time it occurs.\n   * By convention, the first required signer (usually from the first message)\n   * is referred to as the primary signer and pays the fee for the whole\n   * transaction.\n   */\n  messages: Any[];\n  /**\n   * memo is any arbitrary note/comment to be added to the transaction.\n   * WARNING: in clients, any publicly exposed text should not be called memo,\n   * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).\n   */\n  memo: string;\n  /**\n   * timeout is the block height after which this transaction will not\n   * be processed by the chain\n   */\n  timeoutHeight: Long;\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, the transaction will be rejected\n   */\n  extensionOptions: Any[];\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, they will be ignored\n   */\n  nonCriticalExtensionOptions: Any[];\n}\n\n/**\n * AuthInfo describes the fee and signer modes that are used to sign a\n * transaction.\n */\nexport interface AuthInfo {\n  /**\n   * signer_infos defines the signing modes for the required signers. The number\n   * and order of elements must match the required signers from TxBody's\n   * messages. The first element is the primary signer and the one which pays\n   * the fee.\n   */\n  signerInfos: SignerInfo[];\n  /**\n   * Fee is the fee and gas limit for the transaction. The first signer is the\n   * primary signer and the one which pays the fee. The fee can be calculated\n   * based on the cost of evaluating the body and doing signature verification\n   * of the signers. This can be estimated via simulation.\n   */\n  fee?: Fee;\n}\n\n/**\n * SignerInfo describes the public key and signing mode of a single top-level\n * signer.\n */\nexport interface SignerInfo {\n  /**\n   * public_key is the public key of the signer. It is optional for accounts\n   * that already exist in state. If unset, the verifier can use the required \\\n   * signer address for this position and lookup the public key.\n   */\n  publicKey?: Any;\n  /**\n   * mode_info describes the signing mode of the signer and is a nested\n   * structure to support nested multisig pubkey's\n   */\n  modeInfo?: ModeInfo;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to\n   * prevent replay attacks.\n   */\n  sequence: Long;\n}\n\n/** ModeInfo describes the signing mode of a single or nested multisig signer. */\nexport interface ModeInfo {\n  /** single represents a single signer */\n  single?: ModeInfo_Single | undefined;\n  /** multi represents a nested multisig signer */\n  multi?: ModeInfo_Multi | undefined;\n}\n\n/**\n * Single is the mode info for a single signer. It is structured as a message\n * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\n * future\n */\nexport interface ModeInfo_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n}\n\n/** Multi is the mode info for a multisig public key */\nexport interface ModeInfo_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /**\n   * mode_infos is the corresponding modes of the signers of the multisig\n   * which could include nested multisig public keys\n   */\n  modeInfos: ModeInfo[];\n}\n\n/**\n * Fee includes the amount of coins paid in fees and the maximum\n * gas to be used by the transaction. The ratio yields an effective \"gasprice\",\n * which must be above some miminum to be accepted into the mempool.\n */\nexport interface Fee {\n  /** amount is the amount of coins to be paid as a fee */\n  amount: Coin[];\n  /**\n   * gas_limit is the maximum gas that can be used in transaction processing\n   * before an out of gas error occurs\n   */\n  gasLimit: Long;\n  /**\n   * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\n   * the payer must be a tx signer (and thus have signed this field in AuthInfo).\n   * setting this field does *not* change the ordering of required signers for the transaction.\n   */\n  payer: string;\n  /**\n   * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\n   * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\n   * not support fee grants, this will fail\n   */\n  granter: string;\n}\n\nfunction createBaseTx(): Tx {\n  return { body: undefined, authInfo: undefined, signatures: [] };\n}\n\nexport const Tx = {\n  encode(message: Tx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.body !== undefined) {\n      TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.authInfo !== undefined) {\n      AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Tx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.body = TxBody.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.authInfo = AuthInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Tx {\n    return {\n      body: isSet(object.body) ? TxBody.fromJSON(object.body) : undefined,\n      authInfo: isSet(object.authInfo)\n        ? AuthInfo.fromJSON(object.authInfo)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Tx): unknown {\n    const obj: any = {};\n    message.body !== undefined &&\n      (obj.body = message.body ? TxBody.toJSON(message.body) : undefined);\n    message.authInfo !== undefined &&\n      (obj.authInfo = message.authInfo\n        ? AuthInfo.toJSON(message.authInfo)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Tx>, I>>(object: I): Tx {\n    const message = createBaseTx();\n    message.body =\n      object.body !== undefined && object.body !== null\n        ? TxBody.fromPartial(object.body)\n        : undefined;\n    message.authInfo =\n      object.authInfo !== undefined && object.authInfo !== null\n        ? AuthInfo.fromPartial(object.authInfo)\n        : undefined;\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseTxRaw(): TxRaw {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    signatures: [],\n  };\n}\n\nexport const TxRaw = {\n  encode(message: TxRaw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxRaw {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxRaw();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxRaw {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxRaw): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxRaw>, I>>(object: I): TxRaw {\n    const message = createBaseTxRaw();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignDoc(): SignDoc {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    chainId: \"\",\n    accountNumber: Long.UZERO,\n  };\n}\n\nexport const SignDoc = {\n  encode(\n    message: SignDoc,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(26).string(message.chainId);\n    }\n    if (!message.accountNumber.isZero()) {\n      writer.uint32(32).uint64(message.accountNumber);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignDoc {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignDoc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.chainId = reader.string();\n          break;\n        case 4:\n          message.accountNumber = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignDoc {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      accountNumber: isSet(object.accountNumber)\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignDoc): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.accountNumber !== undefined &&\n      (obj.accountNumber = (message.accountNumber || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignDoc>, I>>(object: I): SignDoc {\n    const message = createBaseSignDoc();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.chainId = object.chainId ?? \"\";\n    message.accountNumber =\n      object.accountNumber !== undefined && object.accountNumber !== null\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxBody(): TxBody {\n  return {\n    messages: [],\n    memo: \"\",\n    timeoutHeight: Long.UZERO,\n    extensionOptions: [],\n    nonCriticalExtensionOptions: [],\n  };\n}\n\nexport const TxBody = {\n  encode(\n    message: TxBody,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.messages) {\n      Any.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.memo !== \"\") {\n      writer.uint32(18).string(message.memo);\n    }\n    if (!message.timeoutHeight.isZero()) {\n      writer.uint32(24).uint64(message.timeoutHeight);\n    }\n    for (const v of message.extensionOptions) {\n      Any.encode(v!, writer.uint32(8186).fork()).ldelim();\n    }\n    for (const v of message.nonCriticalExtensionOptions) {\n      Any.encode(v!, writer.uint32(16378).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxBody {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxBody();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.messages.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.memo = reader.string();\n          break;\n        case 3:\n          message.timeoutHeight = reader.uint64() as Long;\n          break;\n        case 1023:\n          message.extensionOptions.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2047:\n          message.nonCriticalExtensionOptions.push(\n            Any.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxBody {\n    return {\n      messages: Array.isArray(object?.messages)\n        ? object.messages.map((e: any) => Any.fromJSON(e))\n        : [],\n      memo: isSet(object.memo) ? String(object.memo) : \"\",\n      timeoutHeight: isSet(object.timeoutHeight)\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO,\n      extensionOptions: Array.isArray(object?.extensionOptions)\n        ? object.extensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n      nonCriticalExtensionOptions: Array.isArray(\n        object?.nonCriticalExtensionOptions\n      )\n        ? object.nonCriticalExtensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxBody): unknown {\n    const obj: any = {};\n    if (message.messages) {\n      obj.messages = message.messages.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.messages = [];\n    }\n    message.memo !== undefined && (obj.memo = message.memo);\n    message.timeoutHeight !== undefined &&\n      (obj.timeoutHeight = (message.timeoutHeight || Long.UZERO).toString());\n    if (message.extensionOptions) {\n      obj.extensionOptions = message.extensionOptions.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.extensionOptions = [];\n    }\n    if (message.nonCriticalExtensionOptions) {\n      obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(\n        (e) => (e ? Any.toJSON(e) : undefined)\n      );\n    } else {\n      obj.nonCriticalExtensionOptions = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxBody>, I>>(object: I): TxBody {\n    const message = createBaseTxBody();\n    message.messages = object.messages?.map((e) => Any.fromPartial(e)) || [];\n    message.memo = object.memo ?? \"\";\n    message.timeoutHeight =\n      object.timeoutHeight !== undefined && object.timeoutHeight !== null\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO;\n    message.extensionOptions =\n      object.extensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    message.nonCriticalExtensionOptions =\n      object.nonCriticalExtensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseAuthInfo(): AuthInfo {\n  return { signerInfos: [], fee: undefined };\n}\n\nexport const AuthInfo = {\n  encode(\n    message: AuthInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signerInfos) {\n      SignerInfo.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.fee !== undefined) {\n      Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AuthInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAuthInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signerInfos.push(SignerInfo.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.fee = Fee.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AuthInfo {\n    return {\n      signerInfos: Array.isArray(object?.signerInfos)\n        ? object.signerInfos.map((e: any) => SignerInfo.fromJSON(e))\n        : [],\n      fee: isSet(object.fee) ? Fee.fromJSON(object.fee) : undefined,\n    };\n  },\n\n  toJSON(message: AuthInfo): unknown {\n    const obj: any = {};\n    if (message.signerInfos) {\n      obj.signerInfos = message.signerInfos.map((e) =>\n        e ? SignerInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.signerInfos = [];\n    }\n    message.fee !== undefined &&\n      (obj.fee = message.fee ? Fee.toJSON(message.fee) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AuthInfo>, I>>(object: I): AuthInfo {\n    const message = createBaseAuthInfo();\n    message.signerInfos =\n      object.signerInfos?.map((e) => SignerInfo.fromPartial(e)) || [];\n    message.fee =\n      object.fee !== undefined && object.fee !== null\n        ? Fee.fromPartial(object.fee)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignerInfo(): SignerInfo {\n  return { publicKey: undefined, modeInfo: undefined, sequence: Long.UZERO };\n}\n\nexport const SignerInfo = {\n  encode(\n    message: SignerInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.modeInfo !== undefined) {\n      ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignerInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignerInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfo = ModeInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignerInfo {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      modeInfo: isSet(object.modeInfo)\n        ? ModeInfo.fromJSON(object.modeInfo)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignerInfo): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.modeInfo !== undefined &&\n      (obj.modeInfo = message.modeInfo\n        ? ModeInfo.toJSON(message.modeInfo)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignerInfo>, I>>(\n    object: I\n  ): SignerInfo {\n    const message = createBaseSignerInfo();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.modeInfo =\n      object.modeInfo !== undefined && object.modeInfo !== null\n        ? ModeInfo.fromPartial(object.modeInfo)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo(): ModeInfo {\n  return { single: undefined, multi: undefined };\n}\n\nexport const ModeInfo = {\n  encode(\n    message: ModeInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.multi !== undefined) {\n      ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = ModeInfo_Single.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.multi = ModeInfo_Multi.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo {\n    return {\n      single: isSet(object.single)\n        ? ModeInfo_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? ModeInfo_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: ModeInfo): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? ModeInfo_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? ModeInfo_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo>, I>>(object: I): ModeInfo {\n    const message = createBaseModeInfo();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? ModeInfo_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? ModeInfo_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Single(): ModeInfo_Single {\n  return { mode: 0 };\n}\n\nexport const ModeInfo_Single = {\n  encode(\n    message: ModeInfo_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n    };\n  },\n\n  toJSON(message: ModeInfo_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Single>, I>>(\n    object: I\n  ): ModeInfo_Single {\n    const message = createBaseModeInfo_Single();\n    message.mode = object.mode ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Multi(): ModeInfo_Multi {\n  return { bitarray: undefined, modeInfos: [] };\n}\n\nexport const ModeInfo_Multi = {\n  encode(\n    message: ModeInfo_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.modeInfos) {\n      ModeInfo.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfos.push(ModeInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      modeInfos: Array.isArray(object?.modeInfos)\n        ? object.modeInfos.map((e: any) => ModeInfo.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ModeInfo_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.modeInfos) {\n      obj.modeInfos = message.modeInfos.map((e) =>\n        e ? ModeInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.modeInfos = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Multi>, I>>(\n    object: I\n  ): ModeInfo_Multi {\n    const message = createBaseModeInfo_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.modeInfos =\n      object.modeInfos?.map((e) => ModeInfo.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseFee(): Fee {\n  return { amount: [], gasLimit: Long.UZERO, payer: \"\", granter: \"\" };\n}\n\nexport const Fee = {\n  encode(message: Fee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.gasLimit.isZero()) {\n      writer.uint32(16).uint64(message.gasLimit);\n    }\n    if (message.payer !== \"\") {\n      writer.uint32(26).string(message.payer);\n    }\n    if (message.granter !== \"\") {\n      writer.uint32(34).string(message.granter);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Fee {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseFee();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.gasLimit = reader.uint64() as Long;\n          break;\n        case 3:\n          message.payer = reader.string();\n          break;\n        case 4:\n          message.granter = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Fee {\n    return {\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n      gasLimit: isSet(object.gasLimit)\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO,\n      payer: isSet(object.payer) ? String(object.payer) : \"\",\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n    };\n  },\n\n  toJSON(message: Fee): unknown {\n    const obj: any = {};\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    message.gasLimit !== undefined &&\n      (obj.gasLimit = (message.gasLimit || Long.UZERO).toString());\n    message.payer !== undefined && (obj.payer = message.payer);\n    message.granter !== undefined && (obj.granter = message.granter);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Fee>, I>>(object: I): Fee {\n    const message = createBaseFee();\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    message.gasLimit =\n      object.gasLimit !== undefined && object.gasLimit !== null\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO;\n    message.payer = object.payer ?? \"\";\n    message.granter = object.granter ?? \"\";\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import invariant from \"tiny-invariant\";\nimport {APIClient} from \"./APIClient\";\nimport {\n  GeneratedType,\n  OfflineSigner,\n  Registry,\n  TxBodyEncodeObject,\n} from \"@cosmjs/proto-signing\";\nimport { Any } from \"cosmjs-types/google/protobuf/any\";\nimport {\n  BaseMsg,\n  MsgCollect,\n  MsgCollectReward,\n  MsgCreatePool,\n  MsgCreatePosition,\n  MsgDecreaseLiquidity,\n  MsgIncreaseLiquidity,\n  MsgSwapExactIn,\n  MsgSwapExactOut,\n  MsgSubmitProposal,\n  MsgDeposit,\n  MsgVote,\n  MsgVoteWeighted,\n  MsgCreateValidator,\n  MsgEditValidator,\n  MsgDelegate,\n  MsgBeginRedelegate,\n  MsgUndelegate,\n  MsgCollectRandSwapReward\n} from \"../msgs\";\nimport { SigningStargateClient } from \"@cosmjs/stargate\";\nimport { PubKey } from \"../proto/cosmos/crypto/secp256k1/keys\";\nimport {\n  SignerInfo,\n  ModeInfo,\n  ModeInfo_Single,\n  Fee,\n  AuthInfo,\n  SignDoc,\n  TxRaw,\n} from \"../proto/cosmos/tx/v1beta1/tx\";\nimport { SignMode } from \"../proto/cosmos/tx/signing/v1beta1/signing\";\nimport { Coin } from \"../proto/cosmos/base/v1beta1/coin\";\nimport { fromBase64, toBase64 } from \"@cosmjs/encoding\";\nimport {Chain_Id, CHAIN_NAMES, NETWORK_DETAILS} from \"../constants\";\n\nexport interface ISender {\n  address: string;\n  pubkey: Uint8Array;\n  accountNumber: number;\n  sequence: number;\n}\n\nexport interface TxGenerated {\n  signDirect: {\n    body: TxBodyEncodeObject;\n    authInfo: AuthInfo;\n    signBytes: string;\n  };\n}\n\nexport const SIGN_DIRECT = SignMode.SIGN_MODE_DIRECT;\n\nexport class TxClient {\n  public chainId: Chain_Id;\n  public apiClient: APIClient;\n  public rpcUrl: string;\n  public accountAddress: string;\n  public signer: OfflineSigner;\n  public registry: Registry;\n\n  // public walletClient: SigningStargateClient | null = null;\n  // public sender: ISender | null = null;\n\n  constructor(\n    chainId: Chain_Id,\n    apiClient: APIClient,\n    rpcUrl: string,\n    signer: OfflineSigner,\n    accountAddress: string,\n  ) {\n    invariant(!!signer, \"wallet is required!\");\n\n    this.chainId = chainId;\n    this.apiClient = apiClient;\n    this.rpcUrl = rpcUrl;\n    this.signer = signer;\n    this.accountAddress = accountAddress;\n\n    const registryTypes = new Map<string, GeneratedType>();\n    registryTypes.set(MsgCollect.typeUrl, MsgCollect.Proto);\n    registryTypes.set(MsgCollectReward.typeUrl, MsgCollectReward.Proto);\n    registryTypes.set(MsgCreatePool.typeUrl, MsgCreatePool.Proto);\n    registryTypes.set(MsgCreatePosition.typeUrl, MsgCreatePosition.Proto);\n    registryTypes.set(MsgDecreaseLiquidity.typeUrl, MsgDecreaseLiquidity.Proto);\n    registryTypes.set(MsgIncreaseLiquidity.typeUrl, MsgIncreaseLiquidity.Proto);\n    registryTypes.set(MsgSwapExactIn.typeUrl, MsgSwapExactIn.Proto);\n    registryTypes.set(MsgSwapExactOut.typeUrl, MsgSwapExactOut.Proto);\n    registryTypes.set(MsgSubmitProposal.typeUrl, MsgSubmitProposal.Proto);\n    registryTypes.set(MsgDeposit.typeUrl, MsgDeposit.Proto);\n    registryTypes.set(MsgVote.typeUrl, MsgVote.Proto);\n    registryTypes.set(MsgVoteWeighted.typeUrl, MsgVoteWeighted.Proto);\n    registryTypes.set(MsgCreateValidator.typeUrl, MsgCreateValidator.Proto);\n    registryTypes.set(MsgEditValidator.typeUrl, MsgEditValidator.Proto);\n    registryTypes.set(MsgDelegate.typeUrl, MsgDelegate.Proto);\n    registryTypes.set(MsgBeginRedelegate.typeUrl, MsgBeginRedelegate.Proto);\n    registryTypes.set(MsgUndelegate.typeUrl, MsgUndelegate.Proto);\n    registryTypes.set(MsgCollectRandSwapReward.typeUrl, MsgCollectRandSwapReward.Proto);\n\n    this.registry = new Registry(registryTypes);\n  }\n\n  public async getSender(): Promise<ISender> {\n    const { authAPI } = this.apiClient;\n    const {\n      account: {\n        base_account: {\n          pub_key,\n          account_number,\n          sequence,\n        },\n      },\n    } = await authAPI.apiAccountInfo(this.accountAddress);\n    const { address, pubkey } = (await this.signer.getAccounts())[0];\n    return {\n      address: this.accountAddress,\n      pubkey,\n      accountNumber: parseInt(account_number),\n      sequence: parseInt(sequence),\n    } as ISender;\n  }\n\n  public async sendTransaction(\n    messages: BaseMsg | Array<BaseMsg>,\n    gasLimit?: number,\n    memo = \"\",\n  ) {\n    const sender = await this.getSender();\n    // const pubKeyDecoded = Buffer.from(sender.pubkey, \"base64\");\n\n    // 1. SignDirect\n    const signInfoDirect = createSignerInfo(\n      sender.pubkey,\n      sender.sequence,\n      SIGN_DIRECT\n    );\n\n    // 2. authInfo\n    let authInfoDirect;\n    if (gasLimit) {\n      // 2. Fee\n      const feeMessage = createFee(\n        '',\n        NETWORK_DETAILS[this.chainId].nativeCurrency.base,\n        gasLimit\n      );\n      authInfoDirect = createAuthInfo(signInfoDirect, feeMessage);\n    } else {\n      authInfoDirect = AuthInfo.fromPartial({\n        signerInfos: [signInfoDirect],\n        fee:{}\n      });\n    }\n\n    // 3. txbody\n    // const body = createBodyWithMultipleMessages(messages, memo);\n    const _messages = messages instanceof Array ? messages : [messages];\n    const body = createTxBodyEncodeObject(_messages, memo);\n\n    // 4. signDoc\n    const signDocDirect = createSigDoc(\n      this.registry.encode(body),\n      AuthInfo.encode(authInfoDirect).finish(),\n      this.chainId,\n      sender.accountNumber\n    );\n\n    // 5. sign\n    let walletClient;\n    walletClient = await SigningStargateClient.connectWithSigner(\n      this.rpcUrl,\n      this.signer,\n      {\n        registry: this.registry,\n        prefix: NETWORK_DETAILS[this.chainId].nativeCurrency.symbol.toLowerCase(),\n      }\n    );\n    // @ts-ignore\n    const { signed, signature } = await walletClient.signer.signDirect(\n      this.accountAddress,\n      signDocDirect\n    );\n\n    const txRaw = TxRaw.fromPartial({\n      bodyBytes: signed.bodyBytes,\n      authInfoBytes: signed.authInfoBytes,\n      signatures: [fromBase64(signature.signature)],\n    });\n    const txBytes = TxRaw.encode(txRaw).finish();\n\n    return walletClient.broadcastTx(txBytes);\n  }\n\n  public async getEstimatedFee(\n    messages: BaseMsg | Array<BaseMsg>,\n    memo: string = \"\"\n  ) {\n    const sender = await this.getSender();\n    // const pubKeyDecoded = Buffer.from(sender.pubkey, \"base64\");\n\n    // 1. SignDirect\n    const signInfoDirect = createSignerInfo(\n      sender.pubkey,\n      sender.sequence,\n      SIGN_DIRECT\n    );\n\n    // 2. authInfo\n    const authInfoDirect = AuthInfo.fromPartial({\n      signerInfos: [signInfoDirect],\n      fee:{}\n    });\n\n    // 3. txbody\n    // const body = createBodyWithMultipleMessages(messages, memo);\n    const _messages = messages instanceof Array ? messages : [messages];\n    const body = createTxBodyEncodeObject(_messages, memo);\n\n    // 4. signDoc\n    const signDocDirect = createSigDoc(\n      this.registry.encode(body),\n      AuthInfo.encode(authInfoDirect).finish(),\n      this.chainId,\n      sender.accountNumber\n    );\n    console.log(signDocDirect);\n\n    const txRaw = TxRaw.fromPartial({\n      bodyBytes: signDocDirect.bodyBytes,\n      authInfoBytes: signDocDirect.authInfoBytes,\n      signatures: [new Uint8Array()],\n    });\n    const txBytes = TxRaw.encode(txRaw).finish();\n\n    const { gas_info: { gas_wanted, gas_used } } = await this.apiClient.txAPI.estimateGas(toBase64(txBytes));\n\n    console.log('gas_used: ' + gas_used);\n\n    return gas_used;\n  }\n}\n\nexport function createTxBodyEncodeObject(\n  messages: Array<BaseMsg>,\n  memo: string\n): TxBodyEncodeObject {\n  const results = messages.map((item) => {\n    return item.generateMessage();\n  });\n  return {\n    typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n    value: {\n      messages: results,\n      memo: memo,\n    },\n  };\n}\n\nexport function createSigDoc(\n  bodyBytes: Uint8Array,\n  authInfoBytes: Uint8Array,\n  chainId: string,\n  accountNumber: number\n) {\n  return SignDoc.fromPartial({\n    bodyBytes,\n    authInfoBytes,\n    chainId,\n    accountNumber,\n  });\n}\n\nfunction createAuthInfo(signerInfo: SignerInfo, fee: Fee) {\n  return AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee,\n  });\n}\n\nfunction createFee(fee: string, denom: string, gasLimit: number) {\n  return Fee.fromPartial({\n    amount: [\n      Coin.fromPartial({\n        denom,\n        amount: fee,\n      }),\n    ],\n    gasLimit,\n  });\n}\n\nfunction createSignerInfo(\n  publicKey: Uint8Array,\n  sequence: number,\n  mode: number\n) {\n  const pubkey = Any.fromPartial({\n    typeUrl: \"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\n    value: PubKey.encode({\n      key: publicKey,\n    }).finish(),\n  });\n  const signerInfo = SignerInfo.fromPartial({\n    publicKey: pubkey,\n    modeInfo: ModeInfo.fromPartial({\n      single: ModeInfo_Single.fromPartial({\n        mode,\n      }),\n    }),\n    sequence,\n  });\n\n  return signerInfo;\n}\n","import {\n  APIRequester,\n  TokenAPI,\n  TxAPI,\n  BankAPI,\n  AuthAPI,\n  SwapAPI\n} from \"../api\";\nimport {Chain_Id} from \"../constants\";\n\nexport class APIClient {\n  public apiRequester: APIRequester;\n\n  // API access\n  public bankAPI: BankAPI;\n  public authAPI: AuthAPI;\n  public swapAPI: SwapAPI;\n  public txAPI: TxAPI;\n  public tokenAPI: TokenAPI;\n  public nodeUrl: string;\n\n  constructor(URL: string, chainId: Chain_Id = Chain_Id.Mainnet) {\n    this.nodeUrl = URL;\n    this.apiRequester = new APIRequester(URL);\n\n    // instantiate APIs\n    this.bankAPI = new BankAPI(this.apiRequester);\n    this.authAPI = new AuthAPI(this.apiRequester);\n    this.tokenAPI = new TokenAPI(this.apiRequester);\n    this.swapAPI = new SwapAPI(this.apiRequester);\n    this.txAPI = new TxAPI(this.apiRequester);\n  }\n}\n","export const ONE_DAY_TO_SECONDS = 86400;\n\nexport const ONE_YEAR_TO_DAYS = 365;\n","import { Transaction_Status } from \"../types\";\n\nexport class TransactionLooper {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n  counter: number;\n  onTransactionSuccess: Function | undefined;\n\n  constructor(\n    txHash: string,\n    description: string,\n    status: Transaction_Status,\n    onTransactionSuccess?: Function\n  ) {\n    this.transactionHash = txHash;\n    this.description = description;\n    this.status = status;\n    this.counter = 0;\n    this.onTransactionSuccess = onTransactionSuccess;\n  }\n}\n","export const ZERO = \"0\";\n","export function objectToMap<K, T>(source: Object) {\n  return new Map(Object.entries(source));\n}\n\nexport function arrayToMap<T, K extends keyof T>(array: Array<T>, property: K) {\n  const map = new Map<T[K], T>();\n  for (const item of array) {\n    map.set(item[property], item);\n  }\n  return map;\n}\n","import { REG_DECIMAL, REG_NUMBER, ZERO } from \"../constants\";\nimport Decimal from \"decimal.js\";\n\nexport function isNumeric(value: string) {\n  return !isNaN(parseFloat(value));\n  // return new Decimal(value).lessThan(ZERO);\n}\n\nexport function checkInputNumber(value: string) {\n  if (REG_NUMBER.test(value) || REG_DECIMAL.test(value) === true) {\n    return true;\n  }\n  return false;\n}\n","import Decimal from \"decimal.js\";\n\nexport const decimalNumber = (number = \" \") => {\n  const [int = \"\", float = \"\"] = number.toString().replace(\"$\", \"\").split(\".\");\n\n  if (int.length > 10) {\n    return `${new Decimal(int).div(new Decimal(10).pow(10)).toFixed(2)}B`;\n  } else if (int.length > 7) {\n    return `${new Decimal(int).div(new Decimal(10).pow(7)).toFixed(2)}M`;\n  } else if (int.length > 3) {\n    return `${new Decimal(int).div(new Decimal(10).pow(3)).toFixed(2)}K`;\n  } else {\n    return `${Number(int) > 0 ? int : 0}.${\n      float.length > 0 ? float.slice(0, 2) : \"00\"\n    }`;\n  }\n};\n","export function deepCopy(source: Object) {\n  // if (typeof source != \"object\") {\n  //   return source;\n  // }\n  // if (source == null) {\n  //   return source;\n  // }\n  // const newObj = source.constructor === Array ? [] as Array<T> : {};\n  // for (const i in source) {\n  //   newObj[i] = deepCopy(source[i]);\n  // }\n  // return newObj;\n\n  return JSON.parse(JSON.stringify(source));\n}\n","import Decimal from \"decimal.js\";\nimport { DEFAULT_PRECISION } from \"../constants\";\n\nexport function plus(value1: string, value2: string) {\n  return new Decimal(value1).plus(value2).toString();\n}\n\nexport function minus(value1: string | number, value2: string | number) {\n  return new Decimal(value1).minus(value2).toString();\n}\n\nexport function multipliedBy(value1: string | number, value2: string | number) {\n  return new Decimal(value1).mul(value2).toString();\n}\n\nexport function div(value1: string, value2: string): string {\n  return new Decimal(value1).div(value2).toString();\n}\n\nexport function isGreaterThan(value1: string, value2: string) {\n  return new Decimal(value1).greaterThanOrEqualTo(value2);\n}\n\nexport function isLessThan(value1: string, value2: string) {\n  return new Decimal(value1).lessThan(value2);\n}\n\nexport function isEqualTo(value1: string, value2: string) {\n  return new Decimal(value1).equals(value2);\n}\n\nexport function pow18(value: string): string {\n  return new Decimal(value).mul(Math.pow(10, DEFAULT_PRECISION)).toFixed();\n}\n\nexport function pow(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION,\n  round: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  if (value === \"\") {\n    return \"0\";\n  }\n  const _value = new Decimal(value).mul(Math.pow(10, precision));\n  if (round === Decimal.ROUND_UP) {\n    return _value.ceil().toFixed();\n  }\n  return _value.floor().toFixed();\n}\n\nexport function powM18(value: string | number) {\n  return new Decimal(value).div(Math.pow(10, DEFAULT_PRECISION)).toString();\n}\n\nexport function shift(value: string, precision: number = DEFAULT_PRECISION) {\n  return new Decimal(value).div(Math.pow(10, precision)).toFixed();\n}\n\nexport function isPositive(value: string | number) {\n  if (!value) {\n    return false;\n  }\n  return new Decimal(value).greaterThan(0);\n}\n","export function encrypt(value: string, prefix = 6, suffix = 4) {\n  if (value) {\n    return value.substr(0, prefix) + \"...\" + value.substr(-suffix);\n  } else {\n    return value;\n  }\n}\n","import { Fee_Amount, FEE_AMOUNT_DETAIL } from \"../constants\";\n\nexport function getPercentByFeeAmount(fee: Fee_Amount | undefined) {\n  if (fee) {\n    return `${FEE_AMOUNT_DETAIL[fee].label}%`;\n  } else {\n    return \"-\";\n  }\n}\n","import { Fee_Amount } from \"../constants\";\nimport { Bech32, toUtf8 } from \"@cosmjs/encoding\";\nimport { sha256 } from \"@cosmjs/crypto\";\n\nexport function getPoolAddress(\n  denom0: string,\n  denom1: string,\n  fee: Fee_Amount\n) {\n  let key;\n  if (denom0 > denom1) {\n    key = `${denom1}-${denom0}-${fee}`;\n  } else {\n    key = `${denom0}-${denom1}-${fee}`;\n  }\n  return Bech32.encode(\"mtos\", sha256(toUtf8(key)).slice(0, 20));\n}\n","import { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { Transaction_Status } from \"./ICommon\";\n\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>;\n    }\n  : T;\n\nexport type BroadcastResult = DeliverTxResponse;\n\nexport interface ITransaction {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n}\n\nexport function longToNumber(long: Long): number {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\n","export function to32(value: string) {\n  const arr = value.split(\",\");\n  const len = 32 - arr.length;\n  const result: Array<number> = [];\n  arr.forEach((item) => {\n    result.push(+item);\n  });\n  for (let i = 0; i < len; i++) {\n    result.unshift(0);\n  }\n  return result;\n}\n","import Decimal from \"decimal.js\";\n\nexport function toPercent(value: Decimal.Value, hundred: boolean = true): string {\n  try {\n    if (hundred) {\n      return `${new Decimal(value).mul(100).toFixed(2)}%`;\n    } else {\n      return `${new Decimal(value).toFixed(2)}%`;\n    }\n  } catch (e) {\n    return value.toString();\n  }\n}\n","import Decimal from \"decimal.js\";\n\nexport function toUsd(value: Decimal.Value): string | number {\n  try {\n    return \"$\" + new Decimal(value).toFixed(2);\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n"],"names":["Fee_Amount","APIRequester","baseURL","axios","this","Axios","create","headers","Accept","timeout","_proto","get","endpoint","params","then","d","data","post","BaseAPI","request","BankAPI","_inheritsLoose","apiTokenBalance","token","accountAddress","denom","base","apiAccountBalance","apiDenomMetadata","AuthAPI","apiAccountInfo","SwapAPI","apiPoolListByAddresses","addresses","qs","stringify","indices","apiPoolMetadataByAddress","address","apiPoolMetadataPriceByAddress","apiLiquidityPositionById","tokenId","apiLiquidityRewardsByIds","tokenIds","apiTickImagePath","apiActiveFarmList","apiLiquidityPositionList","skip_zero_liquidity","TokenAPI","apiTokenMetadatasByDenom","apiTokenMetadatas","TxAPI","estimateGas","txBytes","tx_bytes","_broadcast","tx","mode","broadcast","txInfo","txHash","Chain_Id","FEE_AMOUNT_DETAIL","LOWEST","label","value","description","LOW","MEDIUM","HIGH","Bound","Tip_Level","Swap_Direction","Transaction_Status","CHAIN_NAMES","Mainnet","Testnet","Devnet","NETWORK_DETAILS","chainId","chainName","nativeCurrency","name","symbol","display_exponent","logo_uri","nodeUrl","rpcUrl","blockExplorerUrl","REG_NUMBER","RegExp","REG_DECIMAL","TICK_SPACINGS","100","500","3000","10000","toAmountString","precision","roundingMode","Decimal","ROUND_DOWN","toSignificantDigits","toString","e","String","sortsBefore","baseToken","quoteToken","toLowerCase","moment","locale","LiquidityMath","getRightSideLiquidity","leftRangeValue","rightRangeValue","priceValue","amount","numerator","_value1","div","sqrt","_value2","denominator","sub","getLeftSideLiquidity","getLiquidityFromAmount0","amount0","pc","lessThan","greaterThan","deltaX","_getDiverForDeltaX","lower","upper","_getDiverForDeltaY","getLiquidityFromAmount1","amount1","deltaY","getAmount1FromAmount0","token0","liquidity","console","log","mul","getAmount0FromAmount1","token1","getAmountByLiquidity","deltaXDiver","deltaYDiver","TickMath","priceToClosestTick","price","log2","toNumber","getNearestTickByPrice","feeAmount","trim","INVALID_TICK","MIN_TICK_VALUE","MIN_TICK","MAX_TICK_VALUE","MAX_TICK","tick","nearestUsableTick","getFormattedPriceByTick","fee","isLowestTick","isHighestTick","pow","getPriceByTick","getNearestPriceByInput","nearestTick","getPriceBySqrtPrice","sqrtPrice","getSqrtPriceByPrice","getBaseTickRange","fromToken","toToken","leftRange","rightRange","tickLower","tickUpper","getNearestLowestTick","getNearestHighestTick","getNearestPricesByFullTick","lowestPrice","highestPrice","tickSpacing","rounded","Math","round","BaseMsg","Timestamp","message","writer","_m0","seconds","isZero","uint32","int64","nanos","int32","input","length","reader","end","undefined","len","pos","Long","ZERO","tag","skipType","isSet","MsgCollectReward","MsgSwapExactOut","MsgSwapExactIn","MsgCreatePool","MsgCollect","MsgCreatePosition","MsgDecreaseLiquidity","MsgIncreaseLiquidity","protobufPackage","encode","creator","string","denom0","denom1","decode","fromJSON","object","Number","toJSON","obj","fromPartial","amount0Desired","amount1Desired","amount0Min","amount1Min","recipient","deadline","toTimestamp","fork","ldelim","fromTimestamp","fromJsonTimestamp","toISOString","amount0Max","amount1Max","collectOnly","bool","Boolean","amountIn","amountOutMin","denoms","v","fees","push","end2","Array","isArray","map","amountOut","amountInMax","date","number","getTime","fromNumber","t","millis","Date","o","fromValue","createBaseAny","typeUrl","Uint8Array","msg","_this","protoMsg","generateMessage","MsgCollectReward_pb","_this2","MsgSwapExactOut_pb","_this3","MsgSwapExactIn_pb","_this4","MsgCreatePool_pb","_this5","MsgCollect_pb","_this6","MsgCreatePosition_pb","_this7","MsgDecreaseLiquidity_pb","_this8","MsgIncreaseLiquidity_pb","Any","bytes","bytesFromBase64","arr","bin","forEach","byte","fromCharCode","btoa","join","globalThis","self","window","global","atob","b64","Buffer","from","i","charCodeAt","createBaseDuration","Duration","VoteOption","ProposalStatus","Coin","voteOptionFromJSON","VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO","UNRECOGNIZED","voteOptionToJSON","WeightedVoteOption","option","weight","MsgSubmitProposal","content","initialDeposit","proposer","createBaseMsgVote","proposalId","UZERO","voter","MsgVote","uint64","createBaseMsgVoteWeighted","options","MsgVoteWeighted","createBaseMsgDeposit","depositor","MsgDeposit","MsgSubmitProposal_pb","MsgDeposit_pb","MsgVote_pb","MsgVoteWeighted_pb","RandSwapRewardSubConfig","title","numberOfReveal","createBaseRandSwapRewardConfig","id","enabled","intervalPeriod","mintable","owner","decimal","totalReward","subConfigs","pools","RandSwapRewardConfig","MsgCreateRandSwapRewardConfig","MsgCollectRandSwapReward","BlockIDFlag","SignedMsgType","BondStatus","config","MsgCreateRandSwapRewardConfig_pb","MsgCollectRandSwapReward_pb","CommissionRates","rate","maxRate","maxChangeRate","Description","moniker","identity","website","securityContact","details","MsgCreateValidator","MsgEditValidator","MsgDelegate","MsgBeginRedelegate","MsgUndelegate","commission","minSelfDelegation","delegatorAddress","validatorAddress","pubkey","commissionRate","validatorSrcAddress","validatorDstAddress","createBaseCompactBitArray","extraBitsStored","elems","MsgCreateValidator_pb","MsgEditValidator_pb","MsgDelegate_pb","MsgBeginRedelegate_pb","MsgUndelegate_pb","CompactBitArray","SignMode","signModeFromJSON","SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_LEGACY_AMINO_JSON","SIGN_MODE_EIP_191","TxRaw","bodyBytes","authInfoBytes","signatures","AuthInfo","signerInfos","SignerInfo","Fee","createBaseSignerInfo","publicKey","modeInfo","sequence","ModeInfo","single","ModeInfo_Single","multi","ModeInfo_Multi","signModeToJSON","bitarray","modeInfos","createBaseFee","gasLimit","payer","granter","SIGN_DIRECT","TxClient","apiClient","signer","registry","invariant","registryTypes","Map","set","Proto","Registry","getSender","authAPI","_context","account_number","_yield$authAPI$apiAcc2","account","base_account","getAccounts","accountNumber","parseInt","sendTransaction","messages","memo","_context2","signInfoDirect","createSignerInfo","sender","feeMessage","createFee","authInfoDirect","body","createTxBodyEncodeObject","signDocDirect","createSigDoc","finish","SigningStargateClient","connectWithSigner","prefix","walletClient","signDirect","txRaw","signed","_yield$walletClient$s","fromBase64","signature","broadcastTx","getEstimatedFee","_context3","txAPI","toBase64","gas_used","gas_info","item","key","URL","apiRequester","bankAPI","swapAPI","tokenAPI","status","onTransactionSuccess","transactionHash","counter","array","property","test","replace","split","int","float","toFixed","slice","source","JSON","parse","value1","value2","suffix","substr","time","fromNow","pattern","format","seperator","fixed","Bech32","sha256","toUtf8","floor","equals","greaterThanOrEqualTo","isNaN","parseFloat","long","gt","MAX_SAFE_INTEGER","Error","minus","Object","entries","plus","_value","ROUND_UP","ceil","result","unshift","toDecimalPlaces","CosmosDecimal","fromUserInput","hundred"],"mappings":"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"}