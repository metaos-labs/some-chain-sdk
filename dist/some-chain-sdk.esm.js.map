{"version":3,"file":"some-chain-sdk.esm.js","sources":["../src/api/APIRequester.ts","../src/api/BaseAPI.ts","../src/api/BankAPI.ts","../src/api/AuthAPI.ts","../src/api/SwapAPI.ts","../src/api/TxAPI.ts","../src/utils/crypto.ts","../src/utils/deepCopy.ts","../src/utils/encrypt.ts","../src/constants/tokenlist.default.ts","../src/utils/findToken.ts","../src/constants/date.ts","../src/constants/fee.ts","../src/constants/network.ts","../src/constants/number.ts","../src/constants/precision.ts","../src/constants/tick.ts","../src/utils/formatCurrencyAmount.ts","../src/utils/formatMoment.ts","../src/utils/formatPrice.ts","../src/utils/getPoolAddress.ts","../src/utils/getToPercent.ts","../src/utils/isNumberic.ts","../src/utils/mathUtil.ts","../src/utils/parseToMap.ts","../src/utils/sort.ts","../src/utils/toPercent.ts","../src/utils/decimalNumber.ts","../src/types/ICommon.ts","../src/types/IWallet.ts","../src/core/LiquidityMath.ts","../src/core/TickMath.ts","../src/core/TransactionLooper.ts","../src/clients/APIClient.ts","../src/msgs/BaseMsg.ts","../src/proto/google/protobuf/timestamp.ts","../src/proto/swap/tx.ts","../src/msgs/SwapMsg.ts","../src/proto/google/protobuf/any.ts","../src/proto/google/protobuf/duration.ts","../src/proto/cosmos/base/v1beta1/coin.ts","../src/proto/cosmos/gov/v1beta1/gov.ts","../src/proto/cosmos/gov/v1beta1/tx.ts","../src/msgs/GovMsg.ts","../src/proto/tendermint/crypto/proof.ts","../src/proto/tendermint/version/types.ts","../src/proto/tendermint/crypto/keys.ts","../src/proto/tendermint/types/validator.ts","../src/proto/tendermint/types/types.ts","../src/proto/cosmos/staking/v1beta1/staking.ts","../src/proto/cosmos/staking/v1beta1/tx.ts","../src/msgs/StakingMsg.ts","../src/proto/cosmos/crypto/secp256k1/keys.ts","../src/proto/cosmos/crypto/multisig/v1beta1/multisig.ts","../src/proto/cosmos/tx/signing/v1beta1/signing.ts","../src/proto/cosmos/tx/v1beta1/tx.ts","../src/clients/TxClient.ts"],"sourcesContent":["import Axios, { AxiosInstance } from \"axios\";\nimport { OrderBy } from \"../proto/cosmos/tx/v1beta1/service\";\n\nexport type APIParams = Record<string, string | number | null | undefined>;\n\nexport interface PaginationOptions {\n  \"pagination.limit\": string;\n  \"pagination.offset\": string;\n  \"pagination.key\": string;\n  \"pagination.count_total\": \"true\" | \"false\";\n  \"pagination.reverse\": \"true\" | \"false\";\n  order_by: keyof typeof OrderBy;\n}\n\nexport interface Pagination {\n  next_key: string | null;\n  total: number;\n}\n\nexport class APIRequester {\n  private axios: AxiosInstance;\n\n  constructor(baseURL: string) {\n    this.axios = Axios.create({\n      baseURL,\n      headers: {\n        Accept: \"application/json\",\n      },\n      timeout: 60000,\n    });\n  }\n\n  public async get<T>(\n    endpoint: string,\n    params: URLSearchParams | APIParams = {}\n  ): Promise<T> {\n    return this.axios.get(endpoint, { params }).then((d) => d.data);\n  }\n\n  public async post<T>(endpoint: string, data?: APIParams): Promise<T> {\n    return this.axios.post(endpoint, data).then((d) => d.data);\n  }\n}\n","import { APIRequester } from \"./APIRequester\";\n\nexport abstract class BaseAPI {\n  constructor(protected request: APIRequester) {}\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { IToken } from \"../types\";\n\nexport interface IResBalances {\n  balance: {\n    denom: string;\n    amount: string;\n  };\n}\n\nexport class BankAPI extends BaseAPI {\n  public async apiTokenBalance(\n    token: IToken,\n    accountAddress: string\n  ): Promise<IResBalances> {\n    return this.request.get<IResBalances>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}/by_denom`,\n      {\n        denom: token.denom,\n      }\n    );\n  }\n\n  public async apiAccountBalance(\n    accountAddress: string\n  ): Promise<IResBalances> {\n    return this.request.get<IResBalances>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\n\nexport interface IResAccountInfo {\n  account: {\n    \"@type\": string;\n    base_account: {\n      address: string;\n      pub_key: {\n        \"@type\": string;\n        key: string;\n      };\n      account_number: string;\n      sequence: string;\n    };\n    code_hash: string;\n  };\n}\n\nexport class AuthAPI extends BaseAPI {\n  public async apiAccountInfo(\n    accountAddress: string\n  ): Promise<IResAccountInfo> {\n    return this.request.get<IResAccountInfo>(\n      `/cosmos/auth/v1beta1/accounts/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { ILiquidityPosition, IPool, IPoolPrice } from \"../types\";\n\nexport interface IResPoolInfo {\n  pool: IPool;\n  pool_slot0: IPoolPrice;\n}\n\nexport interface IResPoolMetadataNew {\n  [pool: string]: IPool;\n}\n\nexport interface IFarmV3 {\n  address: string;\n}\n\nexport interface IResFarmList {\n  core_pools: Array<IFarmV3>;\n  pagination: {\n    next_key: null | string;\n    total: string;\n  };\n}\n\nexport interface IResLiquidityPositionList {\n  liquidity_positions: Array<ILiquidityPosition>;\n}\n\nexport class SwapAPI extends BaseAPI {\n  /**\n   * find pool list by address array\n   * @param addresses\n   */\n  public async apiPoolListByAddresses(\n    addresses: Array<string>\n  ): Promise<{ pool_slot0_aggregations: Array<IResPoolInfo> }> {\n    return this.request.get<{ pool_slot0_aggregations: Array<IResPoolInfo> }>(\n      `/sophon-labs/sophon/swap/pool_slot0_aggregations?${addresses.join(\"&\")}`\n    );\n  }\n\n  public async apiPoolMetadataByAddress(\n    address: string\n  ): Promise<IResPoolMetadataNew> {\n    return this.request.get<IResPoolMetadataNew>(\n      `/sophon-labs/sophon/swap/pools/${address}`\n    );\n  }\n\n  public async apiPoolMetadataPriceByAddress(\n    address: string\n  ): Promise<{ pool_slot0: IPoolPrice }> {\n    return this.request.get<{ pool_slot0: IPoolPrice }>(\n      `/sophon-labs/sophon/swap/pools/${address}/slot0`\n    );\n  }\n\n  public async apiLiquidityPositionById(\n    tokenId: string\n  ): Promise<{ liquidity_position: ILiquidityPosition }> {\n    return this.request.get<{ liquidity_position: ILiquidityPosition }>(\n      `/sophon-labs/sophon/swap/liquidity_positions/${tokenId}`\n    );\n  }\n\n  public async apiLiquidityRewardsByIds(\n    tokenIds: Array<string>\n  ): Promise<{ liquidity_positions: Array<ILiquidityPosition> }> {\n    return this.request.get<{ liquidity_positions: Array<ILiquidityPosition> }>(\n      `/sophon-labs/sophon/swap/liquidity_position_by_ids?${tokenIds.join(\"&\")}`\n    );\n  }\n\n  public async apiTickImagePath(tokenId: string): Promise<{ uri: string }> {\n    return this.request.get<{ uri: string }>(\n      `/sophon-labs/sophon/swap/liquidity_positions/${tokenId}/token_uri`\n    );\n  }\n\n  public async apiActiveFarmList(): Promise<IResFarmList> {\n    return this.request.get<IResFarmList>(\n      `/sophon-labs/sophon/swap/core_pools`\n    );\n  }\n\n  public async apiLiquidityPositionList(\n    accountAddress: string\n  ): Promise<IResLiquidityPositionList> {\n    return this.request.get<IResLiquidityPositionList>(\n      `/sophon-labs/sophon/swap/liquidity_positions_owner/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { TxResponse } from \"../proto/cosmos/base/abci/v1beta1/abci\";\nimport {\n  BroadcastMode,\n  BroadcastTxRequest,\n  BroadcastTxResponse,\n} from \"../proto/cosmos/tx/v1beta1/service\";\n\nexport class TxAPI extends BaseAPI {\n  public async txInfo(txHash: string): Promise<TxResponse> {\n    return this.request.get<TxResponse>(`/cosmos/tx/v1beta1/txs/${txHash}`);\n  }\n\n  private async _broadcast<T>(\n    tx: BroadcastTxRequest,\n    mode: keyof typeof BroadcastMode\n  ): Promise<T> {\n    return this.request.post<any>(`/cosmos/tx/v1beta1/txs`);\n  }\n\n  public async broadcast(tx: BroadcastTxRequest): Promise<BroadcastTxResponse> {\n    return this._broadcast<BroadcastTxResponse>(tx, \"BROADCAST_MODE_BLOCK\");\n  }\n}\n","export function to32(value: string) {\n  const arr = value.split(\",\");\n  const len = 32 - arr.length;\n  const result: Array<number> = [];\n  arr.forEach((item) => {\n    result.push(+item);\n  });\n  for (let i = 0; i < len; i++) {\n    result.unshift(0);\n  }\n  return result;\n}\n","export function deepCopy(source: Object) {\n  // if (typeof source != \"object\") {\n  //   return source;\n  // }\n  // if (source == null) {\n  //   return source;\n  // }\n  // const newObj = source.constructor === Array ? [] as Array<T> : {};\n  // for (const i in source) {\n  //   newObj[i] = deepCopy(source[i]);\n  // }\n  // return newObj;\n\n  return JSON.parse(JSON.stringify(source));\n}\n","export function encrypt(value: string, prefix = 6, suffix = 4) {\n  if (value) {\n    return value.substr(0, prefix) + \"...\" + value.substr(-suffix);\n  } else {\n    return value;\n  }\n}\n","export default [\n  {\n    denom: \"usop\",\n    creator: \"\",\n    name: \"Sophon\",\n    symbol: \"SOP\",\n    totalSupply: \"2000000000000000000000000000\",\n    decimal: 18,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png\",\n  },\n  {\n    denom: \"useth\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"Ethereum\",\n    symbol: \"ETH\",\n    totalSupply: \"2000000000000000000000000\",\n    decimal: 18,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/1027.png\",\n  },\n  {\n    denom: \"ustake\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"STAKE\",\n    symbol: \"STAKE\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 8,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/5601.png\",\n  },\n  {\n    denom: \"ususdc\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"USDC\",\n    symbol: \"USDC\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 6,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/3408.png\",\n  },\n  {\n    denom: \"token/token1/3\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"token1\",\n    symbol: \"token1\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 18,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/4195.png\",\n  },\n  {\n    denom: \"token/token2/4\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"token2\",\n    symbol: \"token2\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 8,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/2280.png\",\n  },\n];\n","import { IToken } from \"../types\";\nimport DEFAULT_TOKEN_LIST from \"../constants/tokenlist.default\";\n\nexport function findTokenByDenom(tokenDenom?: string): IToken {\n  const tokens: Array<IToken> = DEFAULT_TOKEN_LIST;\n  const result = tokens.find((item) => item.denom === tokenDenom);\n  if (result) {\n    return result;\n  } else {\n    return DEFAULT_TOKEN_LIST[0];\n  }\n}\n\nexport function findTokenBySymbol(symbol: string): IToken {\n  const tokens: Array<IToken> = DEFAULT_TOKEN_LIST;\n  const result = tokens.find(\n    (item) => item.symbol.toUpperCase() === symbol.toUpperCase()\n  );\n  if (result) {\n    return result;\n  } else {\n    return DEFAULT_TOKEN_LIST[0];\n  }\n}\n","export const ONE_DAY_TO_SECONDS = 86400;\n\nexport const ONE_YEAR_TO_DAYS = 365;\n","export enum Fee_Amount {\n  LOW = 500,\n  MEDIUM = 3000,\n  HIGH = 10000,\n}\n\nexport const FEE_AMOUNT_DETAIL: Record<\n  Fee_Amount,\n  { label: string; value: Fee_Amount; description: string }\n> = {\n  [Fee_Amount.LOW]: {\n    label: \"0.05\",\n    value: Fee_Amount.LOW,\n    description: \"Best for stable pairs.\",\n  },\n  [Fee_Amount.MEDIUM]: {\n    label: \"0.3\",\n    value: Fee_Amount.MEDIUM,\n    description: \"Best for most pairs.\",\n  },\n  [Fee_Amount.HIGH]: {\n    label: \"1\",\n    value: Fee_Amount.HIGH,\n    description: \"Best for exotic pairs.\",\n  },\n};\n","export const ETH = \"eth\";\nexport const BSC = \"bsc\";\nexport const OEC = \"oec\";\nexport const HOO = \"hoo\";\nexport const XDAI = \"xdai\";\nexport const HECO = \"heco\";\nexport const POLYGON = \"polygon\";\nexport const FANTOM = \"fantom\";\nexport const KCC = \"kcc\";\nexport const AVALANCHE = \"avalanche\";\nexport const SOPHON = \"sop\";\n\nexport const ETH_CHAIN_NAME = \"Ethereum\";\nexport const BSC_CHAIN_NAME = \"Binance Smart Chain\";\nexport const OEC_CHAIN_NAME = \"OKEx Chain\";\nexport const HOO_CHAIN_NAME = \"Hoo Smart Chain\";\nexport const XDAI_CHAIN_NAME = \"xDAI\";\nexport const HECO_CHAIN_NAME = \"Huobi ECO Chain\";\nexport const POLYGON_CHAIN_NAME = \"Polygon\";\nexport const FANTOM_CHAIN_NAME = \"Fantom\";\nexport const KCC_CHAIN_NAME = \"KCC\";\nexport const AVALANCHE_CHAIN_NAME = \"Avalanche\";\nexport const SOPHON_TEST_CHAIN_NAME = \"Sophon Dev\";\n\nexport const ETH_NETWORK_ID = \"1\";\nexport const BSC_NETWORK_ID = \"56\";\nexport const BSC_NETWORK_TEST_ID = \"97\";\nexport const OEC_NETWORK_ID = \"66\";\nexport const HOO_NETWORK_ID = \"70\";\nexport const XDAI_NETWORK_ID = \"100\";\nexport const HECO_NETWORK_ID = \"128\";\nexport const POLYGON_NETWORK_ID = \"137\";\nexport const FANTOM_NETWORK_ID = \"250\";\nexport const KCC_NETWORK_ID = \"321\";\nexport const AVALANCHE_NETWORK_ID = \"43114\";\nexport const ETH_TEST_NETWORK_ID = \"2117\";\nexport const SOPHON_TEST_NETWORK_ID = \"118\";\n\nexport const ETH_CHAIN_ID = \"0x1\";\nexport const BSC_CHAIN_ID = \"0x38\";\nexport const BSC_CHAIN_ID_TEST = \"0x61\";\nexport const OEC_CHAIN_ID = \"0x42\";\nexport const HOO_CHAIN_ID = \"0x46\";\nexport const XDAI_CHAIN_ID = \"0x64\";\nexport const HECO_CHAIN_ID = \"0x80\";\nexport const POLYGON_CHAIN_ID = \"0x89\";\nexport const FANTOM_CHAIN_ID = \"0xfa\";\nexport const KCC_CHAIN_ID = \"0x141\";\nexport const AVALANCHE_CHAIN_ID = \"0xa86a\";\nexport const SOPHON_TEST_CHAIN_ID = \"sophond_9000-1\";\n\nexport const ETH_SYMBOL = \"ETH\";\nexport const BNB_SYMBOL = \"BNB\";\nexport const OKT_SYMBOL = \"OKT\";\nexport const HOO_SYMBOL = \"HOO\";\nexport const XDAI_SYMBOL = \"XDAI\";\nexport const HT_SYMBOL = \"HT\";\nexport const POLYGON_SYMBOL = \"MATIC\";\nexport const FANTOM_SYMBOL = \"FTM\";\nexport const KCC_SYMBOL = \"KCS\";\nexport const AVALANCHE_SYMBOL = \"AVAX\";\nexport const SOPHON_SYMBOL = \"SOP\";\n\nexport const SUPPORTED_CHAIN_IDS = [ETH_NETWORK_ID, SOPHON_TEST_NETWORK_ID];\n\nexport const NETWORK_MAP = {\n  [ETH_NETWORK_ID]: {\n    networkId: ETH_NETWORK_ID,\n    chainId: ETH_CHAIN_ID,\n    chainName: ETH_CHAIN_NAME,\n    providerType: ETH,\n    ticker: ETH_SYMBOL,\n  },\n  [BSC_NETWORK_ID]: {\n    networkId: BSC_NETWORK_ID,\n    chainId: BSC_CHAIN_ID,\n    chainName: BSC_CHAIN_NAME,\n    providerType: BSC,\n    ticker: BNB_SYMBOL,\n  },\n  [BSC_NETWORK_TEST_ID]: {\n    networkId: BSC_NETWORK_TEST_ID,\n    chainId: BSC_CHAIN_ID_TEST,\n    chainName: BSC_CHAIN_NAME,\n    providerType: BSC,\n    ticker: BNB_SYMBOL,\n  },\n  [OEC_NETWORK_ID]: {\n    networkId: OEC_NETWORK_ID,\n    chainId: OEC_CHAIN_ID,\n    chainName: OEC_CHAIN_NAME,\n    providerType: OEC,\n    ticker: OKT_SYMBOL,\n  },\n  [HOO_NETWORK_ID]: {\n    networkId: HOO_NETWORK_ID,\n    chainId: HOO_CHAIN_ID,\n    chainName: HOO_CHAIN_NAME,\n    providerType: HOO,\n    ticker: HOO_SYMBOL,\n  },\n  [XDAI_NETWORK_ID]: {\n    networkId: XDAI_NETWORK_ID,\n    chainId: XDAI_CHAIN_ID,\n    chainName: XDAI_CHAIN_NAME,\n    providerType: XDAI,\n    ticker: XDAI_SYMBOL,\n  },\n  [HECO_NETWORK_ID]: {\n    networkId: HECO_NETWORK_ID,\n    chainId: HECO_CHAIN_ID,\n    chainName: HECO_CHAIN_NAME,\n    providerType: HECO,\n    ticker: HT_SYMBOL,\n  },\n  [POLYGON_NETWORK_ID]: {\n    networkId: POLYGON_NETWORK_ID,\n    chainId: POLYGON_CHAIN_ID,\n    chainName: POLYGON_CHAIN_NAME,\n    providerType: POLYGON,\n    ticker: POLYGON_SYMBOL,\n  },\n  [FANTOM_NETWORK_ID]: {\n    networkId: FANTOM_NETWORK_ID,\n    chainId: FANTOM_CHAIN_ID,\n    chainName: FANTOM_CHAIN_NAME,\n    providerType: FANTOM,\n    ticker: FANTOM_SYMBOL,\n  },\n  [KCC_NETWORK_ID]: {\n    networkId: KCC_NETWORK_ID,\n    chainId: KCC_CHAIN_ID,\n    chainName: KCC_CHAIN_NAME,\n    providerType: KCC,\n    ticker: KCC_SYMBOL,\n  },\n  [AVALANCHE_NETWORK_ID]: {\n    networkId: AVALANCHE_NETWORK_ID,\n    chainId: AVALANCHE_CHAIN_ID,\n    chainName: AVALANCHE_CHAIN_NAME,\n    providerType: AVALANCHE,\n    ticker: AVALANCHE_SYMBOL,\n  },\n  [SOPHON_TEST_NETWORK_ID]: {\n    networkId: SOPHON_TEST_NETWORK_ID,\n    chainId: SOPHON_TEST_CHAIN_ID,\n    chainName: SOPHON_TEST_CHAIN_NAME,\n    providerType: SOPHON,\n    ticker: SOPHON_SYMBOL,\n  },\n};\n\nexport const CONFIG_CHAIN_SOPHON = {\n  RPC_URL: \"\",\n  REST_URL: \"\",\n  EXPLORER_URL: \"https://explorer.evmos.org\",\n  NETWORK_NAME: \"Sophon TestNet\",\n  NETWORK_TYPE: \"testnet\",\n  CHAIN_ID: \"sophon_99237-1\",\n  CHAIN_NAME: \"Sophon Dev\",\n  COIN_DENOM: \"usop\",\n  COIN_MINIMAL_DENOM: \"SOP\",\n  COIN_DECIMALS: 18,\n  PREFIX: \"sophon\",\n  COIN_TYPE: 118,\n  COINGECKO_ID: \"sophon\",\n  DEFAULT_GAS: 1000000000,\n  GAS_PRICE_STEP_LOW: 0.005,\n  GAS_PRICE_STEP_AVERAGE: 0.025,\n  GAS_PRICE_STEP_HIGH: 0.08,\n  FEATURES: [\"stargate\", \"ibc-transfer\", \"sophon\"],\n};\n\nexport const CHAIN_ETH = {\n  chainId: \"0x1\",\n  name: \"Ethereum\",\n  logoURI:\n    \"https://assets.trustwalletapp.com/blockchains/smartchain/assets/0x2170Ed0880ac9A755fd29B2688956BD959F933F8/logo.png\",\n  symbol: \"ETH\",\n};\n\nexport const CHAIN_SOP = {\n  chainId: \"sophon\",\n  name: \"Sophon\",\n  logoURI:\n    \"https://assets.trustwalletapp.com/blockchains/smartchain/assets/0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51/logo.png\",\n  symbol: \"sop\",\n};\n","export const ZERO = \"0\";\n","export const DEFAULT_USER_PRECISION = 6;\n\nexport const DEFAULT_PRECISION = 18;\n\nexport const MAX_PRECISION = 28;\n\nexport const REG_NUMBER = new RegExp(\n  \"^[1-9]+[0-9]*(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n\nexport const REG_DECIMAL_SIMPLE = /^\\d*(\\.\\d*)?$/;\n\nexport const REG_DECIMAL = new RegExp(\n  \"^0(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n","export const TICK_SPACINGS = {\n  500: 10,\n  3000: 60,\n  10000: 200,\n};\n\nexport const BASE_UNIT_TICK = 1.0001;\n","import Decimal from \"decimal.js\";\nimport { Decimal as CosmosDecimal } from \"@cosmjs/math\";\nimport {\n  DEFAULT_PRECISION,\n  DEFAULT_USER_PRECISION,\n  MAX_PRECISION,\n} from \"../constants\";\n\nexport function toDecimalPlaces(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION\n) {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_UP)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountString(\n  value: Decimal.Value | undefined = \"\",\n  precision: number = DEFAULT_USER_PRECISION,\n  roundingMode: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  try {\n    return new Decimal(value)\n      .toSignificantDigits(precision, roundingMode)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountFloor(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n): string {\n  return toAmountString(value, precision, Decimal.ROUND_DOWN);\n}\n\nexport function toAmountCeil(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n) {\n  return toAmountString(value, precision, Decimal.ROUND_UP);\n}\n\nexport function toAmountFee(\n  value: string | number,\n  precision: number = DEFAULT_PRECISION\n): string {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_DOWN)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function isEmptyAmount(\n  value: Decimal.Value,\n  precision: number = MAX_PRECISION\n): boolean {\n  const _value = new Decimal(value).mul(Math.pow(10, precision)).floor();\n  return _value.isZero();\n}\n\nexport function toExactAmount(\n  value: string,\n  precision = MAX_PRECISION\n): string {\n  try {\n    return CosmosDecimal.fromUserInput(value, precision).toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport const formatNumber = (\n  value: Decimal.Value,\n  seperator: number = 3,\n  fixed: number = 2\n) => {\n  return `${new Decimal(value)\n    .div(new Decimal(10).pow(seperator))\n    .toFixed(fixed)}k`;\n};\n","import moment from \"moment\";\n\nmoment.locale(\"en-ca\");\n\nexport function formatMoment(value: string, pattern = \"YYYY/MM/DD HH:mm:ss\") {\n  return moment(+value).format(pattern);\n}\n\nexport function formatUnixMoment(value: string, pattern = \"MM/DD HH:mm:ss\") {\n  return moment(+value * 1000).format(pattern);\n}\n\nexport const formatTime = (time: string) => {\n  return moment(time).format(\"YYYY-MM-DD HH:mm:ss\");\n};\n\nexport const formatDiffTime = (time: string) => {\n  return moment(time).fromNow();\n};\n","import Decimal from \"decimal.js\";\n\nexport function toUsd(value: string | undefined): string | number {\n  if (!value) {\n    return 0;\n  }\n  return \"$\" + new Decimal(value).toFixed(2);\n}\n","import { Fee_Amount } from \"../constants\";\nimport { Bech32, toUtf8 } from \"@cosmjs/encoding\";\nimport { sha256 } from \"@cosmjs/crypto\";\n\nexport function getPoolAddress(\n  denom0: string,\n  denom1: string,\n  fee: Fee_Amount\n) {\n  let key;\n  if (denom0 > denom1) {\n    key = `${denom1}-${denom0}-${fee}`;\n  } else {\n    key = `${denom0}-${denom1}-${fee}`;\n  }\n  // console.log('poolAddress: ' + Bech32.encode('sop', sha256(toUtf8(key)).slice(0, 20)));\n  return Bech32.encode(\"sop\", sha256(toUtf8(key)).slice(0, 20));\n}\n","import { Fee_Amount, FEE_AMOUNT_DETAIL } from \"../constants\";\n\nexport function getPercentByFeeAmount(fee: Fee_Amount | undefined) {\n  if (fee) {\n    return `${FEE_AMOUNT_DETAIL[fee].label}%`;\n  } else {\n    return \"-\";\n  }\n}\n","import { REG_DECIMAL, REG_NUMBER, ZERO } from \"../constants\";\nimport Decimal from \"decimal.js\";\n\nexport function isNumeric(value: string) {\n  return !isNaN(parseFloat(value));\n  // return new Decimal(value).lessThan(ZERO);\n}\n\nexport function checkInputNumber(value: string) {\n  if (REG_NUMBER.test(value) || REG_DECIMAL.test(value) === true) {\n    return true;\n  }\n  return false;\n}\n","import Decimal from \"decimal.js\";\nimport { DEFAULT_PRECISION } from \"../constants\";\n\nexport function plus(value1: string, value2: string) {\n  return new Decimal(value1).plus(value2).toString();\n}\n\nexport function minus(value1: string | number, value2: string | number) {\n  return new Decimal(value1).minus(value2).toString();\n}\n\nexport function multipliedBy(value1: string | number, value2: string | number) {\n  return new Decimal(value1).mul(value2).toString();\n}\n\nexport function div(value1: string, value2: string): string {\n  return new Decimal(value1).div(value2).toString();\n}\n\nexport function isGreaterThan(value1: string, value2: string) {\n  return new Decimal(value1).greaterThanOrEqualTo(value2);\n}\n\nexport function isLessThan(value1: string, value2: string) {\n  return new Decimal(value1).lessThan(value2);\n}\n\nexport function isEqualTo(value1: string, value2: string) {\n  return new Decimal(value1).equals(value2);\n}\n\nexport function pow18(value: string): string {\n  return new Decimal(value).mul(Math.pow(10, DEFAULT_PRECISION)).toString();\n}\n\nexport function pow(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION,\n  round: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  if (value === \"\") {\n    return \"0\";\n  }\n  const _value = new Decimal(value).mul(Math.pow(10, precision));\n  if (round === Decimal.ROUND_UP) {\n    return _value.ceil().toString();\n  }\n  return _value.floor().toString();\n}\n\nexport function powM18(value: string | number) {\n  return new Decimal(value).div(Math.pow(10, DEFAULT_PRECISION)).toString();\n}\n\nexport function shift(value: string, precision: number = DEFAULT_PRECISION) {\n  return new Decimal(value).div(Math.pow(10, precision)).toString();\n}\n\nexport function isPositive(value: string | number) {\n  if (!value) {\n    return false;\n  }\n  return new Decimal(value).greaterThan(0);\n}\n","export function objectToMap<K, T>(source: Object) {\n  return new Map(Object.entries(source));\n}\n\nexport function arrayToMap<T, K extends keyof T>(array: Array<T>, property: K) {\n  const map = new Map<T[K], T>();\n  for (const item of array) {\n    map.set(item[property], item);\n  }\n  return map;\n}\n","import { IToken } from \"../types\";\n\nexport function sortsBefore(baseToken: IToken, quoteToken: IToken) {\n  return baseToken.denom.toLowerCase() < quoteToken.denom.toLowerCase();\n}\n","import Decimal from \"decimal.js\";\nimport { isNumeric } from \"./isNumberic\";\n\n// export function toPercent(percent: number, balance: string) {\n//   return new Decimal(percent).div(100).mul(balance).toFixed(2);\n// }\n\nexport function percentage(value: string): string {\n  if (isNumeric(value)) {\n    return `${new Decimal(value).toFixed(2)}%`;\n  } else {\n    return value;\n  }\n}\n\nexport function toPercent(value: Decimal.Value): string {\n  try {\n    return `${new Decimal(value).mul(100).toFixed(2)}%`;\n  } catch (e) {\n    return value.toString();\n  }\n}\n","import Decimal from \"decimal.js\";\n\nexport const decimalNumber = (number = \" \") => {\n  const [int = \"\", float = \"\"] = number.toString().replace(\"$\", \"\").split(\".\");\n\n  if (int.length > 10) {\n    return `${new Decimal(int).div(new Decimal(10).pow(10)).toFixed(2)}B`;\n  } else if (int.length > 7) {\n    return `${new Decimal(int).div(new Decimal(10).pow(7)).toFixed(2)}M`;\n  } else if (int.length > 3) {\n    return `${new Decimal(int).div(new Decimal(10).pow(3)).toFixed(2)}K`;\n  } else {\n    return `${Number(int) > 0 ? int : 0}.${\n      float.length > 0 ? float.slice(0, 2) : \"00\"\n    }`;\n  }\n};\n","import { IToken } from \"./IToken\";\nimport { Fee_Amount } from \"../constants\";\n\nexport interface ITickProcessed {\n  tick: number;\n  liquidityActive: string;\n  liquidityNet: string;\n  price0: string;\n}\n\nexport interface ITickData {\n  tick_idx: number;\n  liquidity_gross: string;\n  liquidity_net: string;\n  price0: string;\n  price1: string;\n}\n\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\nexport enum Bound {\n  LOWER = \"LOWER\",\n  UPPER = \"UPPER\",\n}\n\nexport interface IFeeItem {\n  label: string;\n  value: Fee_Amount;\n  description: string;\n}\n\nexport enum Tip_Level {\n  Info = \"info\",\n  Warning = \"warning\",\n  Error = \"error\",\n}\n\nexport enum Swap_Direction {\n  In = \"exactIn\",\n  Out = \"exactOut\",\n}\n\nexport enum Transaction_Status {\n  Wallet = \"wallet\",\n  Pending = \"pending\",\n  Complete = \"complete\",\n  Success = \"success\",\n  Error = \"error\",\n  Reject = \"reject\",\n}\n\nexport interface ILiquidityPosition {\n  token_id: string;\n  address: string;\n  liquidity: string;\n  fee_growth_inside0_last: string;\n  fee_growth_inside1_last: string;\n  tokens_owed0: string;\n  tokens_owed1: string;\n  tick_lower: number;\n  tick_upper: number;\n  reward_growth_inside_lasts: Array<string>;\n  reward_oweds: Array<string>;\n}\n\nexport interface IPool {\n  address: string;\n  denom0: string;\n  denom1: string;\n  decimal0: number;\n  decimal1: number;\n  fee: number;\n  tick_spacing: number;\n  max_liquidity_per_tick: string;\n}\n\nexport interface IV3RewardConfig {\n  denom: string;\n  mintable: boolean;\n  operator: string;\n  reward_growth_global: string;\n  reward_per_second: string;\n  vault: string;\n  token?: IToken;\n  reward_per_day?: string;\n}\n\nexport interface IV3Reward extends IV3RewardConfig {\n  amount: string;\n  token?: IToken;\n}\n\nexport interface IPoolPrice {\n  address: string;\n  tick: number;\n  sqrt_price: string;\n  liquidity: string;\n  fee_growth_global0: string;\n  fee_growth_global1: string;\n  fee_protocol_owed0: string;\n  fee_protocol_owed1: string;\n  observation_index: number;\n  observation_cardinality: number;\n  observation_cardinality_next: number;\n  reward_configs: Array<IV3RewardConfig>;\n  reward_update_time_last: string;\n}\n\nexport interface IPoolMetaData extends IPool, IPoolPrice {}\n","import { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { Transaction_Status } from \"./ICommon\";\n\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>;\n    }\n  : T;\n\nexport type BroadcastResult = DeliverTxResponse;\n\nexport interface ITransaction {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n}\n\nexport function longToNumber(long: Long): number {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\n","import { IToken } from \"../types\";\nimport { toDecimalPlaces } from \"../utils\";\nimport Decimal from \"decimal.js\";\n\nexport class LiquidityMath {\n  private static getRightSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(leftRangeValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return numerator.div(denominator);\n  }\n\n  private static getLeftSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(rightRangeValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return numerator.div(denominator);\n  }\n\n  public static getLiquidityFromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n    if (pc.lessThan(leftRangeValue) === true) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    } else if (pc.greaterThan(rightRangeValue) === true) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    }\n    const deltaX = new Decimal(amount0);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(priceValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return deltaX.div(denominator);\n  }\n\n  private static _getDiverForDeltaX(\n    lower: number | string,\n    upper: number | string\n  ): Decimal {\n    const _value1 = new Decimal(1).div(Decimal.sqrt(lower));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(upper));\n    return Decimal.sub(_value1, _value2);\n  }\n\n  private static _getDiverForDeltaY(\n    lower: number | string,\n    upper: number | string\n  ) {\n    return Decimal.sub(Decimal.sqrt(upper), Decimal.sqrt(lower));\n  }\n\n  public static getLiquidityFromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n\n    if (pc.lessThan(leftRangeValue) === true) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    } else if (pc.greaterThan(rightRangeValue) === true) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    }\n\n    const deltaY = new Decimal(amount1);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(priceValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return deltaY.div(denominator);\n  }\n\n  public static getAmount1FromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string,\n    token0: IToken\n  ): string {\n    const liquidity = this.getLiquidityFromAmount0(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount0\n    );\n    console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmount0FromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string,\n    token1: IToken\n  ): string {\n    const liquidity = this.getLiquidityFromAmount1(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount1\n    );\n\n    console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmountByLiquidity(\n    leftRangeValue: number | string,\n    rightRangeValue: number | string,\n    priceValue: number | string,\n    liquidity: string,\n    token0: IToken,\n    token1: IToken\n  ): { amount0: string; amount1: string } {\n    const pc = new Decimal(priceValue);\n\n    const _value1 = new Decimal(liquidity);\n\n    if (pc.lessThan(leftRangeValue) === true) {\n      const _value2 = this._getDiverForDeltaX(leftRangeValue, rightRangeValue);\n      return {\n        amount0: toDecimalPlaces(_value1.mul(_value2), token0.decimal),\n        amount1: \"0\",\n      };\n    } else if (pc.greaterThan(rightRangeValue) === true) {\n      const _value2 = this._getDiverForDeltaY(leftRangeValue, rightRangeValue);\n      return {\n        amount0: \"0\",\n        amount1: toDecimalPlaces(_value1.mul(_value2), token1.decimal),\n      };\n    }\n    const deltaXDiver = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    const deltaYDiver = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return {\n      amount0: toDecimalPlaces(_value1.mul(deltaXDiver), token0.decimal),\n      amount1: toDecimalPlaces(_value1.mul(deltaYDiver), token1.decimal),\n    };\n  }\n}\n","import invariant from \"tiny-invariant\";\nimport Decimal from \"decimal.js\";\nimport { Fee_Amount, TICK_SPACINGS, BASE_UNIT_TICK } from \"../constants\";\nimport { IToken } from \"../types\";\nimport { sortsBefore, toAmountString } from \"../utils\";\n\nexport class TickMath {\n  public static INVALID_TICK = -99999999;\n\n  public static MIN_TICK = -887272;\n\n  public static MIN_TICK_VALUE = \"0\";\n\n  public static MAX_TICK: number = -TickMath.MIN_TICK;\n\n  public static MAX_TICK_VALUE = \"âˆž\";\n\n  public static nearestUsableTick = (\n    tick: number,\n    tickSpacing: number\n  ): number => {\n    const rounded = Math.round(tick / tickSpacing) * tickSpacing;\n    if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;\n    else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;\n    else return rounded;\n  };\n\n  private static priceToClosestTick(price: string): number {\n    const numerator = Decimal.log2(Decimal.sqrt(price));\n    const denominator = Decimal.log2(Decimal.sqrt(BASE_UNIT_TICK));\n    return numerator.div(denominator).toNumber();\n  }\n\n  /**\n   * Compute nearest tick of price for input\n   * @param feeAmount\n   * @param value\n   */\n  public static getNearestTickByPrice(\n    feeAmount: Fee_Amount,\n    value: string\n  ): number {\n    const _value = value.trim();\n    if (_value === \"\") {\n      return this.INVALID_TICK;\n    }\n    if (value === this.MIN_TICK_VALUE) {\n      return this.MIN_TICK;\n    }\n    if (value === this.MAX_TICK_VALUE) {\n      return this.MAX_TICK;\n    }\n    const tick: number = this.priceToClosestTick(value);\n    // console.log(`[priceToClosestTick]: ` + tick);\n    const result = this.nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n    // console.log(`[nearestUsableTick]: ` + result);\n    return result;\n  }\n\n  public static getFormattedPriceByTick(\n    tick: Decimal.Value,\n    fee: Fee_Amount\n  ): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    if (this.isLowestTick(tick, fee)) {\n      return this.MIN_TICK_VALUE;\n    }\n    if (this.isHighestTick(tick, fee)) {\n      return this.MAX_TICK_VALUE;\n    }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getPriceByTick(tick: Decimal.Value): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    // if (this.isLowestTick(tick, fee)) {\n    //   return this.MIN_TICK_VALUE;\n    // }\n    // if (this.isHighestTick(tick, fee)) {\n    //   return this.MAX_TICK_VALUE;\n    // }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getNearestPriceByInput(\n    feeAmount: Fee_Amount,\n    price: string\n  ): string {\n    // console.log('INPUT price: ' + price);\n    const nearestTick = this.getNearestTickByPrice(feeAmount, price);\n    const result = this.getPriceByTick(nearestTick);\n    // console.log('getPriceByTick: ' + result);\n    // console.log('==========');\n    return toAmountString(result);\n  }\n\n  public static getPriceBySqrtPrice(sqrtPrice: string): string {\n    if (!sqrtPrice) {\n      return \"\";\n    }\n    if (sqrtPrice === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(sqrtPrice).pow(2).toString();\n  }\n\n  public static getSqrtPriceByPrice(price: string): string {\n    if (price === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(price).sqrt().toString();\n  }\n\n  public static getBaseTickRange(\n    fromToken: IToken,\n    toToken: IToken,\n    fee: Fee_Amount,\n    leftRange: string,\n    rightRange: string\n  ): { tickLower: number; tickUpper: number } {\n    let tickLower: number;\n    let tickUpper: number;\n    if (sortsBefore(fromToken, toToken)) {\n      tickLower =\n        leftRange === TickMath.MIN_TICK_VALUE\n          ? TickMath.getNearestLowestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, leftRange);\n      tickUpper =\n        rightRange === TickMath.MAX_TICK_VALUE\n          ? TickMath.getNearestHighestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, rightRange);\n    } else {\n      if (leftRange === TickMath.MIN_TICK_VALUE) {\n        tickUpper = TickMath.getNearestHighestTick(fee);\n      } else {\n        tickUpper = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(leftRange).toString()\n        );\n      }\n      if (rightRange === TickMath.MAX_TICK_VALUE) {\n        tickLower = TickMath.getNearestLowestTick(fee);\n      } else {\n        tickLower = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(rightRange).toString()\n        );\n      }\n    }\n    console.log(\"tickLower: \" + tickLower);\n    console.log(\"tickUpper: \" + tickUpper);\n    return {\n      tickLower,\n      tickUpper,\n    };\n  }\n\n  public static getNearestLowestTick(fee: Fee_Amount): number {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestLowestTick: ' + tickLower);\n    return tickLower;\n  }\n\n  public static getNearestHighestTick(fee: Fee_Amount): number {\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestHighestTick: ' + tickUpper);\n    return tickUpper;\n  }\n\n  public static getNearestPricesByFullTick(fee: Fee_Amount): {\n    lowestPrice: string;\n    highestPrice: string;\n  } {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    const lowestPrice = this.getPriceByTick(tickLower);\n    const highestPrice = this.getPriceByTick(tickUpper);\n    return {\n      lowestPrice,\n      highestPrice,\n    };\n  }\n\n  public static isHighestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const highestTick = this.getNearestHighestTick(fee);\n    return tick >= highestTick;\n  }\n\n  public static isLowestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const lowestTick = this.getNearestLowestTick(fee);\n    return tick <= lowestTick;\n  }\n}\n","import { Transaction_Status } from \"../types\";\n\nexport class TransactionLooper {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n  counter: number;\n  onTransactionSuccess: Function | undefined;\n\n  constructor(\n    txHash: string,\n    description: string,\n    status: Transaction_Status,\n    onTransactionSuccess?: Function\n  ) {\n    this.transactionHash = txHash;\n    this.description = description;\n    this.status = status;\n    this.counter = 0;\n    this.onTransactionSuccess = onTransactionSuccess;\n  }\n}\n","import { APIRequester, TxAPI } from \"../api\";\nimport { BankAPI, AuthAPI, SwapAPI } from \"../api\";\nimport { CONFIG_CHAIN_SOPHON } from \"../constants\";\n\nexport class APIClient {\n  public apiRequester: APIRequester;\n\n  // API access\n  public bankAPI: BankAPI;\n  public authAPI: AuthAPI;\n  public swapAPI: SwapAPI;\n  public txAPI: TxAPI;\n  public nodeUrl: string;\n\n  constructor(URL: string, chainId: string = CONFIG_CHAIN_SOPHON.CHAIN_ID) {\n    this.nodeUrl = URL;\n    this.apiRequester = new APIRequester(URL);\n\n    // instantiate APIs\n    this.bankAPI = new BankAPI(this.apiRequester);\n    this.authAPI = new AuthAPI(this.apiRequester);\n    this.swapAPI = new SwapAPI(this.apiRequester);\n    this.txAPI = new TxAPI(this.apiRequester);\n  }\n}\n","import { EncodeObject, TxBodyEncodeObject } from \"@cosmjs/proto-signing\";\n\nexport abstract class BaseMsg {\n  constructor() {}\n  public abstract generateMessage(): EncodeObject;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n * ) to obtain a formatter capable of generating timestamps in this format.\n */\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: Long;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseTimestamp(): Timestamp {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Timestamp = {\n  encode(\n    message: Timestamp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Timestamp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Timestamp {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Timestamp): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(\n    object: I\n  ): Timestamp {\n    const message = createBaseTimestamp();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"sophonlabs.sophon.swap\";\n\nexport interface MsgCreatePool {\n  creator: string;\n  /** the denom of denom0 in the pool */\n  denom0: string;\n  /** the denom of denom1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the initial square root price of the poo */\n  sqrtPrice: string;\n}\n\nexport interface MsgCreatePoolResponse {}\n\nexport interface MsgCreatePosition {\n  creator: string;\n  /** the denom of token0 in the pool */\n  denom0: string;\n  /** the denom of token1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the price lower bound of the position */\n  tickLower: number;\n  /** the price higher bound of the position */\n  tickUpper: number;\n  /** the desired amount of denom0 in the position */\n  amount0Desired: string;\n  /** the desired amount of denom1 in the position */\n  amount1Desired: string;\n  /** the minimum amount that denom0 needs to add when slippage occurs */\n  amount0Min: string;\n  /** the minimum amount that denom1 needs to add when slippage occurs */\n  amount1Min: string;\n  /** the minted NFT holder address */\n  recipient: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgCreatePositionResponse {}\n\nexport interface MsgIncreaseLiquidity {\n  /** the message creator, with tokens paid for the message */\n  creator: string;\n  /** then id of the NFT for which liquidity is being increased */\n  tokenId: string;\n  /** the desired amount of denom0 to be spent */\n  amount0Desired: string;\n  /** the desired amount of denom1 to be spent */\n  amount1Desired: string;\n  /** the minimum amount of denom0 to spend, which serves as a slippage check */\n  amount0Min: string;\n  /** the minimum amount of denom1 to spend, which serves as a slippage check */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgIncreaseLiquidityResponse {}\n\nexport interface MsgDecreaseLiquidity {\n  creator: string;\n  /** then id of the NFT for which liquidity is being decreased */\n  tokenId: string;\n  /** the amount by which liquidity will be decreased */\n  liquidity: string;\n  /** the minimum amount of denom0 that should be accounted for the burned liquidity */\n  amount0Min: string;\n  /** the minimum amount of denom1 that should be accounted for the burned liquidity */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgDecreaseLiquidityResponse {}\n\nexport interface MsgCollect {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** the maximum amount of denom0 to collect */\n  amount0Max: string;\n  /** the maximum amount of denom1 to collect */\n  amount1Max: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectResponse {}\n\nexport interface MsgSwapExactIn {\n  creator: string;\n  recipient: string;\n  amountIn: string;\n  amountOutMin: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactInResponse {}\n\nexport interface MsgSwapExactOut {\n  creator: string;\n  recipient: string;\n  amountOut: string;\n  amountInMax: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactOutResponse {}\n\nexport interface MsgCollectReward {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectRewardResponse {}\n\nexport interface MsgCollectFeeProtocol {\n  creator: string;\n  /** the pool address */\n  address: string;\n}\n\nexport interface MsgCollectFeeProtocolResponse {}\n\nexport interface MsgGovCorePool {\n  creator: string;\n  address: string;\n  action: string;\n  triggerTime?: Date;\n}\n\nexport interface MsgGovCorePoolResponse {}\n\nfunction createBaseMsgCreatePool(): MsgCreatePool {\n  return { creator: \"\", denom0: \"\", denom1: \"\", fee: 0, sqrtPrice: \"\" };\n}\n\nexport const MsgCreatePool = {\n  encode(\n    message: MsgCreatePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.sqrtPrice !== \"\") {\n      writer.uint32(42).string(message.sqrtPrice);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.sqrtPrice = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      sqrtPrice: isSet(object.sqrtPrice) ? String(object.sqrtPrice) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCreatePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.sqrtPrice !== undefined && (obj.sqrtPrice = message.sqrtPrice);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePool>, I>>(\n    object: I\n  ): MsgCreatePool {\n    const message = createBaseMsgCreatePool();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.sqrtPrice = object.sqrtPrice ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePoolResponse(): MsgCreatePoolResponse {\n  return {};\n}\n\nexport const MsgCreatePoolResponse = {\n  encode(\n    _: MsgCreatePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePoolResponse>, I>>(\n    _: I\n  ): MsgCreatePoolResponse {\n    const message = createBaseMsgCreatePoolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePosition(): MsgCreatePosition {\n  return {\n    creator: \"\",\n    denom0: \"\",\n    denom1: \"\",\n    fee: 0,\n    tickLower: 0,\n    tickUpper: 0,\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    recipient: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgCreatePosition = {\n  encode(\n    message: MsgCreatePosition,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.tickLower !== 0) {\n      writer.uint32(40).int32(message.tickLower);\n    }\n    if (message.tickUpper !== 0) {\n      writer.uint32(48).int32(message.tickUpper);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(58).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(66).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(74).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(82).string(message.amount1Min);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(90).string(message.recipient);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(98).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePosition {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePosition();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.tickLower = reader.int32();\n          break;\n        case 6:\n          message.tickUpper = reader.int32();\n          break;\n        case 7:\n          message.amount0Desired = reader.string();\n          break;\n        case 8:\n          message.amount1Desired = reader.string();\n          break;\n        case 9:\n          message.amount0Min = reader.string();\n          break;\n        case 10:\n          message.amount1Min = reader.string();\n          break;\n        case 11:\n          message.recipient = reader.string();\n          break;\n        case 12:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePosition {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      tickLower: isSet(object.tickLower) ? Number(object.tickLower) : 0,\n      tickUpper: isSet(object.tickUpper) ? Number(object.tickUpper) : 0,\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreatePosition): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.tickLower !== undefined &&\n      (obj.tickLower = Math.round(message.tickLower));\n    message.tickUpper !== undefined &&\n      (obj.tickUpper = Math.round(message.tickUpper));\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePosition>, I>>(\n    object: I\n  ): MsgCreatePosition {\n    const message = createBaseMsgCreatePosition();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.tickLower = object.tickLower ?? 0;\n    message.tickUpper = object.tickUpper ?? 0;\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePositionResponse(): MsgCreatePositionResponse {\n  return {};\n}\n\nexport const MsgCreatePositionResponse = {\n  encode(\n    _: MsgCreatePositionResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePositionResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePositionResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePositionResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePositionResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePositionResponse>, I>>(\n    _: I\n  ): MsgCreatePositionResponse {\n    const message = createBaseMsgCreatePositionResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidity(): MsgIncreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgIncreaseLiquidity = {\n  encode(\n    message: MsgIncreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(26).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(34).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(42).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(50).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.amount0Desired = reader.string();\n          break;\n        case 4:\n          message.amount1Desired = reader.string();\n          break;\n        case 5:\n          message.amount0Min = reader.string();\n          break;\n        case 6:\n          message.amount1Min = reader.string();\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgIncreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgIncreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidity>, I>>(\n    object: I\n  ): MsgIncreaseLiquidity {\n    const message = createBaseMsgIncreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidityResponse(): MsgIncreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgIncreaseLiquidityResponse = {\n  encode(\n    _: MsgIncreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgIncreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgIncreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgIncreaseLiquidityResponse {\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidity(): MsgDecreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    liquidity: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgDecreaseLiquidity = {\n  encode(\n    message: MsgDecreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.liquidity !== \"\") {\n      writer.uint32(26).string(message.liquidity);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(34).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(42).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.liquidity = reader.string();\n          break;\n        case 4:\n          message.amount0Min = reader.string();\n          break;\n        case 5:\n          message.amount1Min = reader.string();\n          break;\n        case 6:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDecreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      liquidity: isSet(object.liquidity) ? String(object.liquidity) : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgDecreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.liquidity !== undefined && (obj.liquidity = message.liquidity);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidity>, I>>(\n    object: I\n  ): MsgDecreaseLiquidity {\n    const message = createBaseMsgDecreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.liquidity = object.liquidity ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidityResponse(): MsgDecreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgDecreaseLiquidityResponse = {\n  encode(\n    _: MsgDecreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDecreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDecreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgDecreaseLiquidityResponse {\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollect(): MsgCollect {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    recipient: \"\",\n    amount0Max: \"\",\n    amount1Max: \"\",\n    collectOnly: false,\n  };\n}\n\nexport const MsgCollect = {\n  encode(\n    message: MsgCollect,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.amount0Max !== \"\") {\n      writer.uint32(34).string(message.amount0Max);\n    }\n    if (message.amount1Max !== \"\") {\n      writer.uint32(42).string(message.amount1Max);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(48).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollect {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollect();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.amount0Max = reader.string();\n          break;\n        case 5:\n          message.amount1Max = reader.string();\n          break;\n        case 6:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollect {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amount0Max: isSet(object.amount0Max) ? String(object.amount0Max) : \"\",\n      amount1Max: isSet(object.amount1Max) ? String(object.amount1Max) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollect): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amount0Max !== undefined && (obj.amount0Max = message.amount0Max);\n    message.amount1Max !== undefined && (obj.amount1Max = message.amount1Max);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollect>, I>>(\n    object: I\n  ): MsgCollect {\n    const message = createBaseMsgCollect();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amount0Max = object.amount0Max ?? \"\";\n    message.amount1Max = object.amount1Max ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectResponse(): MsgCollectResponse {\n  return {};\n}\n\nexport const MsgCollectResponse = {\n  encode(\n    _: MsgCollectResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectResponse>, I>>(\n    _: I\n  ): MsgCollectResponse {\n    const message = createBaseMsgCollectResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactIn(): MsgSwapExactIn {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountIn: \"\",\n    amountOutMin: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactIn = {\n  encode(\n    message: MsgSwapExactIn,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountIn !== \"\") {\n      writer.uint32(26).string(message.amountIn);\n    }\n    if (message.amountOutMin !== \"\") {\n      writer.uint32(34).string(message.amountOutMin);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactIn {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactIn();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountIn = reader.string();\n          break;\n        case 4:\n          message.amountOutMin = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactIn {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountIn: isSet(object.amountIn) ? String(object.amountIn) : \"\",\n      amountOutMin: isSet(object.amountOutMin)\n        ? String(object.amountOutMin)\n        : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactIn): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountIn !== undefined && (obj.amountIn = message.amountIn);\n    message.amountOutMin !== undefined &&\n      (obj.amountOutMin = message.amountOutMin);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactIn>, I>>(\n    object: I\n  ): MsgSwapExactIn {\n    const message = createBaseMsgSwapExactIn();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountIn = object.amountIn ?? \"\";\n    message.amountOutMin = object.amountOutMin ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactInResponse(): MsgSwapExactInResponse {\n  return {};\n}\n\nexport const MsgSwapExactInResponse = {\n  encode(\n    _: MsgSwapExactInResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactInResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactInResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactInResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactInResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactInResponse>, I>>(\n    _: I\n  ): MsgSwapExactInResponse {\n    const message = createBaseMsgSwapExactInResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOut(): MsgSwapExactOut {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountOut: \"\",\n    amountInMax: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactOut = {\n  encode(\n    message: MsgSwapExactOut,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountOut !== \"\") {\n      writer.uint32(26).string(message.amountOut);\n    }\n    if (message.amountInMax !== \"\") {\n      writer.uint32(34).string(message.amountInMax);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactOut {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOut();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountOut = reader.string();\n          break;\n        case 4:\n          message.amountInMax = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactOut {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountOut: isSet(object.amountOut) ? String(object.amountOut) : \"\",\n      amountInMax: isSet(object.amountInMax) ? String(object.amountInMax) : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactOut): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountOut !== undefined && (obj.amountOut = message.amountOut);\n    message.amountInMax !== undefined &&\n      (obj.amountInMax = message.amountInMax);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOut>, I>>(\n    object: I\n  ): MsgSwapExactOut {\n    const message = createBaseMsgSwapExactOut();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountOut = object.amountOut ?? \"\";\n    message.amountInMax = object.amountInMax ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOutResponse(): MsgSwapExactOutResponse {\n  return {};\n}\n\nexport const MsgSwapExactOutResponse = {\n  encode(\n    _: MsgSwapExactOutResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactOutResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOutResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactOutResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactOutResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOutResponse>, I>>(\n    _: I\n  ): MsgSwapExactOutResponse {\n    const message = createBaseMsgSwapExactOutResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectReward(): MsgCollectReward {\n  return { creator: \"\", tokenId: \"\", recipient: \"\", collectOnly: false };\n}\n\nexport const MsgCollectReward = {\n  encode(\n    message: MsgCollectReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(32).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollectReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectReward>, I>>(\n    object: I\n  ): MsgCollectReward {\n    const message = createBaseMsgCollectReward();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRewardResponse(): MsgCollectRewardResponse {\n  return {};\n}\n\nexport const MsgCollectRewardResponse = {\n  encode(\n    _: MsgCollectRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectRewardResponse>, I>>(\n    _: I\n  ): MsgCollectRewardResponse {\n    const message = createBaseMsgCollectRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocol(): MsgCollectFeeProtocol {\n  return { creator: \"\", address: \"\" };\n}\n\nexport const MsgCollectFeeProtocol = {\n  encode(\n    message: MsgCollectFeeProtocol,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocol {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocol();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectFeeProtocol {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCollectFeeProtocol): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocol>, I>>(\n    object: I\n  ): MsgCollectFeeProtocol {\n    const message = createBaseMsgCollectFeeProtocol();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocolResponse(): MsgCollectFeeProtocolResponse {\n  return {};\n}\n\nexport const MsgCollectFeeProtocolResponse = {\n  encode(\n    _: MsgCollectFeeProtocolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectFeeProtocolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectFeeProtocolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocolResponse>, I>>(\n    _: I\n  ): MsgCollectFeeProtocolResponse {\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePool(): MsgGovCorePool {\n  return { creator: \"\", address: \"\", action: \"\", triggerTime: undefined };\n}\n\nexport const MsgGovCorePool = {\n  encode(\n    message: MsgGovCorePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    if (message.action !== \"\") {\n      writer.uint32(26).string(message.action);\n    }\n    if (message.triggerTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.triggerTime),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGovCorePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        case 3:\n          message.action = reader.string();\n          break;\n        case 4:\n          message.triggerTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGovCorePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n      action: isSet(object.action) ? String(object.action) : \"\",\n      triggerTime: isSet(object.triggerTime)\n        ? fromJsonTimestamp(object.triggerTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgGovCorePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    message.action !== undefined && (obj.action = message.action);\n    message.triggerTime !== undefined &&\n      (obj.triggerTime = message.triggerTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePool>, I>>(\n    object: I\n  ): MsgGovCorePool {\n    const message = createBaseMsgGovCorePool();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    message.action = object.action ?? \"\";\n    message.triggerTime = object.triggerTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePoolResponse(): MsgGovCorePoolResponse {\n  return {};\n}\n\nexport const MsgGovCorePoolResponse = {\n  encode(\n    _: MsgGovCorePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgGovCorePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGovCorePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGovCorePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePoolResponse>, I>>(\n    _: I\n  ): MsgGovCorePoolResponse {\n    const message = createBaseMsgGovCorePoolResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse>;\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse>;\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse>;\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse>;\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse>;\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse>;\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse>;\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse>;\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreatePool = this.CreatePool.bind(this);\n    this.CreatePosition = this.CreatePosition.bind(this);\n    this.IncreaseLiquidity = this.IncreaseLiquidity.bind(this);\n    this.DecreaseLiquidity = this.DecreaseLiquidity.bind(this);\n    this.Collect = this.Collect.bind(this);\n    this.SwapExactIn = this.SwapExactIn.bind(this);\n    this.SwapExactOut = this.SwapExactOut.bind(this);\n    this.CollectReward = this.CollectReward.bind(this);\n    this.CollectFeeProtocol = this.CollectFeeProtocol.bind(this);\n    this.GovCorePool = this.GovCorePool.bind(this);\n  }\n\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse> {\n    return this.rpc.unary(\n      MsgCreatePoolDesc,\n      MsgCreatePool.fromPartial(request),\n      metadata\n    );\n  }\n\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse> {\n    return this.rpc.unary(\n      MsgCreatePositionDesc,\n      MsgCreatePosition.fromPartial(request),\n      metadata\n    );\n  }\n\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgIncreaseLiquidityDesc,\n      MsgIncreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgDecreaseLiquidityDesc,\n      MsgDecreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse> {\n    return this.rpc.unary(\n      MsgCollectDesc,\n      MsgCollect.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse> {\n    return this.rpc.unary(\n      MsgSwapExactInDesc,\n      MsgSwapExactIn.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse> {\n    return this.rpc.unary(\n      MsgSwapExactOutDesc,\n      MsgSwapExactOut.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse> {\n    return this.rpc.unary(\n      MsgCollectRewardDesc,\n      MsgCollectReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse> {\n    return this.rpc.unary(\n      MsgCollectFeeProtocolDesc,\n      MsgCollectFeeProtocol.fromPartial(request),\n      metadata\n    );\n  }\n\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse> {\n    return this.rpc.unary(\n      MsgGovCorePoolDesc,\n      MsgGovCorePool.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"sophonlabs.sophon.swap.Msg\",\n};\n\nexport const MsgCreatePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCreatePositionDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePosition\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePosition.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePositionResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgIncreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"IncreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgIncreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgIncreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDecreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"DecreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDecreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDecreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectDesc: UnaryMethodDefinitionish = {\n  methodName: \"Collect\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollect.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactInDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactIn\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactIn.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactInResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactOutDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactOut\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactOut.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactOutResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectFeeProtocolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectFeeProtocol\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectFeeProtocol.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectFeeProtocolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgGovCorePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"GovCorePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGovCorePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGovCorePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import {\n  MsgCollect as MsgCollect_pb,\n  MsgCollectReward as MsgCollectReward_pb,\n  MsgCreatePool as MsgCreatePool_pb,\n  MsgCreatePosition as MsgCreatePosition_pb,\n  MsgDecreaseLiquidity as MsgDecreaseLiquidity_pb,\n  MsgIncreaseLiquidity as MsgIncreaseLiquidity_pb,\n  MsgSwapExactIn as MsgSwapExactIn_pb,\n  MsgSwapExactOut as MsgSwapExactOut_pb,\n  protobufPackage,\n} from \"../proto/swap/tx\";\nimport { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\n\nexport class MsgCollectReward extends BaseMsg {\n  public protoMsg: MsgCollectReward_pb;\n  constructor(msg: MsgCollectReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollectReward.typeUrl,\n      value: MsgCollectReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectReward`;\n  export const Proto = MsgCollectReward_pb;\n  export interface Proto extends MsgCollectReward_pb {}\n}\n\nexport class MsgSwapExactOut extends BaseMsg {\n  public protoMsg: MsgSwapExactOut_pb;\n  constructor(msg: MsgSwapExactOut_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactOut.typeUrl,\n      value: MsgSwapExactOut_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactOut {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactOut`;\n  export const Proto = MsgSwapExactOut_pb;\n  export interface Proto extends MsgSwapExactOut_pb {}\n}\n\nexport class MsgSwapExactIn extends BaseMsg {\n  public protoMsg: MsgSwapExactIn_pb;\n  constructor(msg: MsgSwapExactIn_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactIn.typeUrl,\n      value: MsgSwapExactIn_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactIn {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactIn`;\n  export const Proto = MsgSwapExactIn_pb;\n  export interface Proto extends MsgSwapExactIn_pb {}\n}\n\nexport class MsgCreatePool extends BaseMsg {\n  public protoMsg: MsgCreatePool_pb;\n  constructor(msg: MsgCreatePool_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePool.typeUrl,\n      value: MsgCreatePool_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePool {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePool`;\n  export const Proto = MsgCreatePool_pb;\n  export interface Proto extends MsgCreatePool_pb {}\n}\n\nexport class MsgCollect extends BaseMsg {\n  public protoMsg: MsgCollect_pb;\n  constructor(msg: MsgCollect_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollect.typeUrl,\n      value: MsgCollect_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollect {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollect`;\n  export const Proto = MsgCollect_pb;\n  export interface Proto extends MsgCollect_pb {}\n}\n\nexport class MsgCreatePosition extends BaseMsg {\n  public protoMsg: MsgCreatePosition_pb;\n  constructor(msg: MsgCreatePosition_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePosition.typeUrl,\n      value: MsgCreatePosition_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePosition {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePosition`;\n  export const Proto = MsgCreatePosition_pb;\n  export interface Proto extends MsgCreatePosition_pb {}\n}\n\nexport class MsgDecreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgDecreaseLiquidity_pb;\n  constructor(msg: MsgDecreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDecreaseLiquidity.typeUrl,\n      value: MsgDecreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDecreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgDecreaseLiquidity`;\n  export const Proto = MsgDecreaseLiquidity_pb;\n  export interface Proto extends MsgDecreaseLiquidity_pb {}\n}\n\nexport class MsgIncreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgIncreaseLiquidity_pb;\n  constructor(msg: MsgIncreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgIncreaseLiquidity.typeUrl,\n      value: MsgIncreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgIncreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgIncreaseLiquidity`;\n  export const Proto = MsgIncreaseLiquidity_pb;\n  export interface Proto extends MsgIncreaseLiquidity_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := ptypes.MarshalAny(foo)\n *      ...\n *      foo := &pb.Foo{}\n *      if err := ptypes.UnmarshalAny(any, foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n */\nexport interface Any {\n  /**\n   * A URL/resource name that uniquely identifies the type of the serialized\n   * protocol buffer message. This string must contain at least\n   * one \"/\" character. The last segment of the URL's path must represent\n   * the fully qualified name of the type (as in\n   * `path/google.protobuf.Duration`). The name should be in a canonical form\n   * (e.g., leading \".\" is not accepted).\n   *\n   * In practice, teams usually precompile into the binary all types that they\n   * expect it to use in the context of Any. However, for URLs which use the\n   * scheme `http`, `https`, or no scheme, one can optionally set up a type\n   * server that maps type URLs to message definitions as follows:\n   *\n   * * If no scheme is provided, `https` is assumed.\n   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   *   value in binary format, or produce an error.\n   * * Applications are allowed to cache lookup results based on the\n   *   URL, or have them precompiled into a binary to avoid any\n   *   lookup. Therefore, binary compatibility needs to be preserved\n   *   on changes to types. (Use versioned type names to manage\n   *   breaking changes.)\n   *\n   * Note: this functionality is not currently available in the official\n   * protobuf release, and it is not used for type URLs beginning with\n   * type.googleapis.com.\n   *\n   * Schemes other than `http`, `https` (or the empty scheme) might be\n   * used with implementation specific semantics.\n   */\n  typeUrl: string;\n  /** Must be a valid serialized protocol buffer of the above specified type. */\n  value: Uint8Array;\n}\n\nfunction createBaseAny(): Any {\n  return { typeUrl: \"\", value: new Uint8Array() };\n}\n\nexport const Any = {\n  encode(message: Any, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.typeUrl !== \"\") {\n      writer.uint32(10).string(message.typeUrl);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Any {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAny();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.typeUrl = reader.string();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Any {\n    return {\n      typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : \"\",\n      value: isSet(object.value)\n        ? bytesFromBase64(object.value)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Any): unknown {\n    const obj: any = {};\n    message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);\n    message.value !== undefined &&\n      (obj.value = base64FromBytes(\n        message.value !== undefined ? message.value : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Any>, I>>(object: I): Any {\n    const message = createBaseAny();\n    message.typeUrl = object.typeUrl ?? \"\";\n    message.value = object.value ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n *\n * # Examples\n *\n * Example 1: Compute Duration from two Timestamps in pseudo code.\n *\n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n *\n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n *\n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (duration.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n *\n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n *\n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n *\n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n *\n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n *\n * Example 3: Compute Duration from datetime.timedelta in Python.\n *\n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n *\n * # JSON Mapping\n *\n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n */\nexport interface Duration {\n  /**\n   * Signed seconds of the span of time. Must be from -315,576,000,000\n   * to +315,576,000,000 inclusive. Note: these bounds are computed from:\n   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n   */\n  seconds: Long;\n  /**\n   * Signed fractions of a second at nanosecond resolution of the span\n   * of time. Durations less than one second are represented with a 0\n   * `seconds` field and a positive or negative `nanos` field. For durations\n   * of one second or more, a non-zero value for the `nanos` field must be\n   * of the same sign as the `seconds` field. Must be from -999,999,999\n   * to +999,999,999 inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseDuration(): Duration {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Duration = {\n  encode(\n    message: Duration,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Duration {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDuration();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Duration {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Duration): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Duration>, I>>(object: I): Duration {\n    const message = createBaseDuration();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.base.v1beta1\";\n\n/**\n * Coin defines a token with a denomination and an amount.\n *\n * NOTE: The amount field is an Int which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface Coin {\n  denom: string;\n  amount: string;\n}\n\n/**\n * DecCoin defines a token with a denomination and a decimal amount.\n *\n * NOTE: The amount field is an Dec which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface DecCoin {\n  denom: string;\n  amount: string;\n}\n\n/** IntProto defines a Protobuf wrapper around an Int object. */\nexport interface IntProto {\n  int: string;\n}\n\n/** DecProto defines a Protobuf wrapper around a Dec object. */\nexport interface DecProto {\n  dec: string;\n}\n\nfunction createBaseCoin(): Coin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const Coin = {\n  encode(message: Coin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Coin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Coin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: Coin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Coin>, I>>(object: I): Coin {\n    const message = createBaseCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecCoin(): DecCoin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const DecCoin = {\n  encode(\n    message: DecCoin,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecCoin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecCoin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: DecCoin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecCoin>, I>>(object: I): DecCoin {\n    const message = createBaseDecCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseIntProto(): IntProto {\n  return { int: \"\" };\n}\n\nexport const IntProto = {\n  encode(\n    message: IntProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.int !== \"\") {\n      writer.uint32(10).string(message.int);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): IntProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseIntProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.int = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): IntProto {\n    return {\n      int: isSet(object.int) ? String(object.int) : \"\",\n    };\n  },\n\n  toJSON(message: IntProto): unknown {\n    const obj: any = {};\n    message.int !== undefined && (obj.int = message.int);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<IntProto>, I>>(object: I): IntProto {\n    const message = createBaseIntProto();\n    message.int = object.int ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecProto(): DecProto {\n  return { dec: \"\" };\n}\n\nexport const DecProto = {\n  encode(\n    message: DecProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.dec !== \"\") {\n      writer.uint32(10).string(message.dec);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.dec = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecProto {\n    return {\n      dec: isSet(object.dec) ? String(object.dec) : \"\",\n    };\n  },\n\n  toJSON(message: DecProto): unknown {\n    const obj: any = {};\n    message.dec !== undefined && (obj.dec = message.dec);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecProto>, I>>(object: I): DecProto {\n    const message = createBaseDecProto();\n    message.dec = object.dec ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Duration } from \"../../../google/protobuf/duration\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.gov.v1beta1\";\n\n/** VoteOption enumerates the valid vote options for a given governance proposal. */\nexport enum VoteOption {\n  /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */\n  VOTE_OPTION_UNSPECIFIED = 0,\n  /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */\n  VOTE_OPTION_YES = 1,\n  /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */\n  VOTE_OPTION_ABSTAIN = 2,\n  /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */\n  VOTE_OPTION_NO = 3,\n  /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */\n  VOTE_OPTION_NO_WITH_VETO = 4,\n  UNRECOGNIZED = -1,\n}\n\nexport function voteOptionFromJSON(object: any): VoteOption {\n  switch (object) {\n    case 0:\n    case \"VOTE_OPTION_UNSPECIFIED\":\n      return VoteOption.VOTE_OPTION_UNSPECIFIED;\n    case 1:\n    case \"VOTE_OPTION_YES\":\n      return VoteOption.VOTE_OPTION_YES;\n    case 2:\n    case \"VOTE_OPTION_ABSTAIN\":\n      return VoteOption.VOTE_OPTION_ABSTAIN;\n    case 3:\n    case \"VOTE_OPTION_NO\":\n      return VoteOption.VOTE_OPTION_NO;\n    case 4:\n    case \"VOTE_OPTION_NO_WITH_VETO\":\n      return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VoteOption.UNRECOGNIZED;\n  }\n}\n\nexport function voteOptionToJSON(object: VoteOption): string {\n  switch (object) {\n    case VoteOption.VOTE_OPTION_UNSPECIFIED:\n      return \"VOTE_OPTION_UNSPECIFIED\";\n    case VoteOption.VOTE_OPTION_YES:\n      return \"VOTE_OPTION_YES\";\n    case VoteOption.VOTE_OPTION_ABSTAIN:\n      return \"VOTE_OPTION_ABSTAIN\";\n    case VoteOption.VOTE_OPTION_NO:\n      return \"VOTE_OPTION_NO\";\n    case VoteOption.VOTE_OPTION_NO_WITH_VETO:\n      return \"VOTE_OPTION_NO_WITH_VETO\";\n    case VoteOption.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** ProposalStatus enumerates the valid statuses of a proposal. */\nexport enum ProposalStatus {\n  /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status. */\n  PROPOSAL_STATUS_UNSPECIFIED = 0,\n  /**\n   * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\n   * period.\n   */\n  PROPOSAL_STATUS_DEPOSIT_PERIOD = 1,\n  /**\n   * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\n   * period.\n   */\n  PROPOSAL_STATUS_VOTING_PERIOD = 2,\n  /**\n   * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\n   * passed.\n   */\n  PROPOSAL_STATUS_PASSED = 3,\n  /**\n   * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\n   * been rejected.\n   */\n  PROPOSAL_STATUS_REJECTED = 4,\n  /**\n   * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\n   * failed.\n   */\n  PROPOSAL_STATUS_FAILED = 5,\n  UNRECOGNIZED = -1,\n}\n\nexport function proposalStatusFromJSON(object: any): ProposalStatus {\n  switch (object) {\n    case 0:\n    case \"PROPOSAL_STATUS_UNSPECIFIED\":\n      return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;\n    case 1:\n    case \"PROPOSAL_STATUS_DEPOSIT_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;\n    case 2:\n    case \"PROPOSAL_STATUS_VOTING_PERIOD\":\n      return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;\n    case 3:\n    case \"PROPOSAL_STATUS_PASSED\":\n      return ProposalStatus.PROPOSAL_STATUS_PASSED;\n    case 4:\n    case \"PROPOSAL_STATUS_REJECTED\":\n      return ProposalStatus.PROPOSAL_STATUS_REJECTED;\n    case 5:\n    case \"PROPOSAL_STATUS_FAILED\":\n      return ProposalStatus.PROPOSAL_STATUS_FAILED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ProposalStatus.UNRECOGNIZED;\n  }\n}\n\nexport function proposalStatusToJSON(object: ProposalStatus): string {\n  switch (object) {\n    case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:\n      return \"PROPOSAL_STATUS_UNSPECIFIED\";\n    case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:\n      return \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:\n      return \"PROPOSAL_STATUS_VOTING_PERIOD\";\n    case ProposalStatus.PROPOSAL_STATUS_PASSED:\n      return \"PROPOSAL_STATUS_PASSED\";\n    case ProposalStatus.PROPOSAL_STATUS_REJECTED:\n      return \"PROPOSAL_STATUS_REJECTED\";\n    case ProposalStatus.PROPOSAL_STATUS_FAILED:\n      return \"PROPOSAL_STATUS_FAILED\";\n    case ProposalStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** WeightedVoteOption defines a unit of vote for vote split. */\nexport interface WeightedVoteOption {\n  option: VoteOption;\n  weight: string;\n}\n\n/**\n * TextProposal defines a standard text proposal whose changes need to be\n * manually updated in case of approval.\n */\nexport interface TextProposal {\n  title: string;\n  description: string;\n}\n\n/**\n * Deposit defines an amount deposited by an account address to an active\n * proposal.\n */\nexport interface Deposit {\n  proposalId: Long;\n  depositor: string;\n  amount: Coin[];\n}\n\n/** Proposal defines the core field members of a governance proposal. */\nexport interface Proposal {\n  proposalId: Long;\n  content?: Any;\n  status: ProposalStatus;\n  finalTallyResult?: TallyResult;\n  submitTime?: Date;\n  depositEndTime?: Date;\n  totalDeposit: Coin[];\n  votingStartTime?: Date;\n  votingEndTime?: Date;\n}\n\n/** TallyResult defines a standard tally for a governance proposal. */\nexport interface TallyResult {\n  yes: string;\n  abstain: string;\n  no: string;\n  noWithVeto: string;\n}\n\n/**\n * Vote defines a vote on a governance proposal.\n * A Vote consists of a proposal ID, the voter, and the vote option.\n */\nexport interface Vote {\n  proposalId: Long;\n  voter: string;\n  /**\n   * Deprecated: Prefer to use `options` instead. This field is set in queries\n   * if and only if `len(options) == 1` and that option has weight 1. In all\n   * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.\n   *\n   * @deprecated\n   */\n  option: VoteOption;\n  options: WeightedVoteOption[];\n}\n\n/** DepositParams defines the params for deposits on governance proposals. */\nexport interface DepositParams {\n  /** Minimum deposit for a proposal to enter voting period. */\n  minDeposit: Coin[];\n  /**\n   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n   *  months.\n   */\n  maxDepositPeriod?: Duration;\n}\n\n/** VotingParams defines the params for voting on governance proposals. */\nexport interface VotingParams {\n  /** Length of the voting period. */\n  votingPeriod?: Duration;\n}\n\n/** TallyParams defines the params for tallying votes on governance proposals. */\nexport interface TallyParams {\n  /**\n   * Minimum percentage of total stake needed to vote for a result to be\n   *  considered valid.\n   */\n  quorum: Uint8Array;\n  /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */\n  threshold: Uint8Array;\n  /**\n   * Minimum value of Veto votes to Total votes ratio for proposal to be\n   *  vetoed. Default value: 1/3.\n   */\n  vetoThreshold: Uint8Array;\n}\n\nfunction createBaseWeightedVoteOption(): WeightedVoteOption {\n  return { option: 0, weight: \"\" };\n}\n\nexport const WeightedVoteOption = {\n  encode(\n    message: WeightedVoteOption,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.option !== 0) {\n      writer.uint32(8).int32(message.option);\n    }\n    if (message.weight !== \"\") {\n      writer.uint32(18).string(message.weight);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): WeightedVoteOption {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseWeightedVoteOption();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.option = reader.int32() as any;\n          break;\n        case 2:\n          message.weight = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): WeightedVoteOption {\n    return {\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n      weight: isSet(object.weight) ? String(object.weight) : \"\",\n    };\n  },\n\n  toJSON(message: WeightedVoteOption): unknown {\n    const obj: any = {};\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    message.weight !== undefined && (obj.weight = message.weight);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<WeightedVoteOption>, I>>(\n    object: I\n  ): WeightedVoteOption {\n    const message = createBaseWeightedVoteOption();\n    message.option = object.option ?? 0;\n    message.weight = object.weight ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextProposal(): TextProposal {\n  return { title: \"\", description: \"\" };\n}\n\nexport const TextProposal = {\n  encode(\n    message: TextProposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TextProposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TextProposal {\n    return {\n      title: isSet(object.title) ? String(object.title) : \"\",\n      description: isSet(object.description) ? String(object.description) : \"\",\n    };\n  },\n\n  toJSON(message: TextProposal): unknown {\n    const obj: any = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined &&\n      (obj.description = message.description);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TextProposal>, I>>(\n    object: I\n  ): TextProposal {\n    const message = createBaseTextProposal();\n    message.title = object.title ?? \"\";\n    message.description = object.description ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDeposit(): Deposit {\n  return { proposalId: Long.UZERO, depositor: \"\", amount: [] };\n}\n\nexport const Deposit = {\n  encode(\n    message: Deposit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Deposit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDeposit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Deposit {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Deposit): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Deposit>, I>>(object: I): Deposit {\n    const message = createBaseDeposit();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.depositor = object.depositor ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseProposal(): Proposal {\n  return {\n    proposalId: Long.UZERO,\n    content: undefined,\n    status: 0,\n    finalTallyResult: undefined,\n    submitTime: undefined,\n    depositEndTime: undefined,\n    totalDeposit: [],\n    votingStartTime: undefined,\n    votingEndTime: undefined,\n  };\n}\n\nexport const Proposal = {\n  encode(\n    message: Proposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.content !== undefined) {\n      Any.encode(message.content, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(24).int32(message.status);\n    }\n    if (message.finalTallyResult !== undefined) {\n      TallyResult.encode(\n        message.finalTallyResult,\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    if (message.submitTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.submitTime),\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.depositEndTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.depositEndTime),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    for (const v of message.totalDeposit) {\n      Coin.encode(v!, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.votingStartTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.votingStartTime),\n        writer.uint32(66).fork()\n      ).ldelim();\n    }\n    if (message.votingEndTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.votingEndTime),\n        writer.uint32(74).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.content = Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.status = reader.int32() as any;\n          break;\n        case 4:\n          message.finalTallyResult = TallyResult.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 5:\n          message.submitTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 6:\n          message.depositEndTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 7:\n          message.totalDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.votingStartTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 9:\n          message.votingEndTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proposal {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      content: isSet(object.content) ? Any.fromJSON(object.content) : undefined,\n      status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,\n      finalTallyResult: isSet(object.finalTallyResult)\n        ? TallyResult.fromJSON(object.finalTallyResult)\n        : undefined,\n      submitTime: isSet(object.submitTime)\n        ? fromJsonTimestamp(object.submitTime)\n        : undefined,\n      depositEndTime: isSet(object.depositEndTime)\n        ? fromJsonTimestamp(object.depositEndTime)\n        : undefined,\n      totalDeposit: Array.isArray(object?.totalDeposit)\n        ? object.totalDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      votingStartTime: isSet(object.votingStartTime)\n        ? fromJsonTimestamp(object.votingStartTime)\n        : undefined,\n      votingEndTime: isSet(object.votingEndTime)\n        ? fromJsonTimestamp(object.votingEndTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Proposal): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.content !== undefined &&\n      (obj.content = message.content ? Any.toJSON(message.content) : undefined);\n    message.status !== undefined &&\n      (obj.status = proposalStatusToJSON(message.status));\n    message.finalTallyResult !== undefined &&\n      (obj.finalTallyResult = message.finalTallyResult\n        ? TallyResult.toJSON(message.finalTallyResult)\n        : undefined);\n    message.submitTime !== undefined &&\n      (obj.submitTime = message.submitTime.toISOString());\n    message.depositEndTime !== undefined &&\n      (obj.depositEndTime = message.depositEndTime.toISOString());\n    if (message.totalDeposit) {\n      obj.totalDeposit = message.totalDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.totalDeposit = [];\n    }\n    message.votingStartTime !== undefined &&\n      (obj.votingStartTime = message.votingStartTime.toISOString());\n    message.votingEndTime !== undefined &&\n      (obj.votingEndTime = message.votingEndTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {\n    const message = createBaseProposal();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.content =\n      object.content !== undefined && object.content !== null\n        ? Any.fromPartial(object.content)\n        : undefined;\n    message.status = object.status ?? 0;\n    message.finalTallyResult =\n      object.finalTallyResult !== undefined && object.finalTallyResult !== null\n        ? TallyResult.fromPartial(object.finalTallyResult)\n        : undefined;\n    message.submitTime = object.submitTime ?? undefined;\n    message.depositEndTime = object.depositEndTime ?? undefined;\n    message.totalDeposit =\n      object.totalDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.votingStartTime = object.votingStartTime ?? undefined;\n    message.votingEndTime = object.votingEndTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTallyResult(): TallyResult {\n  return { yes: \"\", abstain: \"\", no: \"\", noWithVeto: \"\" };\n}\n\nexport const TallyResult = {\n  encode(\n    message: TallyResult,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.yes !== \"\") {\n      writer.uint32(10).string(message.yes);\n    }\n    if (message.abstain !== \"\") {\n      writer.uint32(18).string(message.abstain);\n    }\n    if (message.no !== \"\") {\n      writer.uint32(26).string(message.no);\n    }\n    if (message.noWithVeto !== \"\") {\n      writer.uint32(34).string(message.noWithVeto);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TallyResult {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTallyResult();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.yes = reader.string();\n          break;\n        case 2:\n          message.abstain = reader.string();\n          break;\n        case 3:\n          message.no = reader.string();\n          break;\n        case 4:\n          message.noWithVeto = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TallyResult {\n    return {\n      yes: isSet(object.yes) ? String(object.yes) : \"\",\n      abstain: isSet(object.abstain) ? String(object.abstain) : \"\",\n      no: isSet(object.no) ? String(object.no) : \"\",\n      noWithVeto: isSet(object.noWithVeto) ? String(object.noWithVeto) : \"\",\n    };\n  },\n\n  toJSON(message: TallyResult): unknown {\n    const obj: any = {};\n    message.yes !== undefined && (obj.yes = message.yes);\n    message.abstain !== undefined && (obj.abstain = message.abstain);\n    message.no !== undefined && (obj.no = message.no);\n    message.noWithVeto !== undefined && (obj.noWithVeto = message.noWithVeto);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TallyResult>, I>>(\n    object: I\n  ): TallyResult {\n    const message = createBaseTallyResult();\n    message.yes = object.yes ?? \"\";\n    message.abstain = object.abstain ?? \"\";\n    message.no = object.no ?? \"\";\n    message.noWithVeto = object.noWithVeto ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseVote(): Vote {\n  return { proposalId: Long.UZERO, voter: \"\", option: 0, options: [] };\n}\n\nexport const Vote = {\n  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    for (const v of message.options) {\n      WeightedVoteOption.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32() as any;\n          break;\n        case 4:\n          message.options.push(\n            WeightedVoteOption.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Vote {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n      options: Array.isArray(object?.options)\n        ? object.options.map((e: any) => WeightedVoteOption.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Vote): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    if (message.options) {\n      obj.options = message.options.map((e) =>\n        e ? WeightedVoteOption.toJSON(e) : undefined\n      );\n    } else {\n      obj.options = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {\n    const message = createBaseVote();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.option = object.option ?? 0;\n    message.options =\n      object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDepositParams(): DepositParams {\n  return { minDeposit: [], maxDepositPeriod: undefined };\n}\n\nexport const DepositParams = {\n  encode(\n    message: DepositParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.minDeposit) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxDepositPeriod !== undefined) {\n      Duration.encode(\n        message.maxDepositPeriod,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DepositParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDepositParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.minDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.maxDepositPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DepositParams {\n    return {\n      minDeposit: Array.isArray(object?.minDeposit)\n        ? object.minDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      maxDepositPeriod: isSet(object.maxDepositPeriod)\n        ? Duration.fromJSON(object.maxDepositPeriod)\n        : undefined,\n    };\n  },\n\n  toJSON(message: DepositParams): unknown {\n    const obj: any = {};\n    if (message.minDeposit) {\n      obj.minDeposit = message.minDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.minDeposit = [];\n    }\n    message.maxDepositPeriod !== undefined &&\n      (obj.maxDepositPeriod = message.maxDepositPeriod\n        ? Duration.toJSON(message.maxDepositPeriod)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DepositParams>, I>>(\n    object: I\n  ): DepositParams {\n    const message = createBaseDepositParams();\n    message.minDeposit =\n      object.minDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.maxDepositPeriod =\n      object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null\n        ? Duration.fromPartial(object.maxDepositPeriod)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseVotingParams(): VotingParams {\n  return { votingPeriod: undefined };\n}\n\nexport const VotingParams = {\n  encode(\n    message: VotingParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.votingPeriod !== undefined) {\n      Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): VotingParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVotingParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.votingPeriod = Duration.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): VotingParams {\n    return {\n      votingPeriod: isSet(object.votingPeriod)\n        ? Duration.fromJSON(object.votingPeriod)\n        : undefined,\n    };\n  },\n\n  toJSON(message: VotingParams): unknown {\n    const obj: any = {};\n    message.votingPeriod !== undefined &&\n      (obj.votingPeriod = message.votingPeriod\n        ? Duration.toJSON(message.votingPeriod)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<VotingParams>, I>>(\n    object: I\n  ): VotingParams {\n    const message = createBaseVotingParams();\n    message.votingPeriod =\n      object.votingPeriod !== undefined && object.votingPeriod !== null\n        ? Duration.fromPartial(object.votingPeriod)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseTallyParams(): TallyParams {\n  return {\n    quorum: new Uint8Array(),\n    threshold: new Uint8Array(),\n    vetoThreshold: new Uint8Array(),\n  };\n}\n\nexport const TallyParams = {\n  encode(\n    message: TallyParams,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.quorum.length !== 0) {\n      writer.uint32(10).bytes(message.quorum);\n    }\n    if (message.threshold.length !== 0) {\n      writer.uint32(18).bytes(message.threshold);\n    }\n    if (message.vetoThreshold.length !== 0) {\n      writer.uint32(26).bytes(message.vetoThreshold);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TallyParams {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTallyParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.quorum = reader.bytes();\n          break;\n        case 2:\n          message.threshold = reader.bytes();\n          break;\n        case 3:\n          message.vetoThreshold = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TallyParams {\n    return {\n      quorum: isSet(object.quorum)\n        ? bytesFromBase64(object.quorum)\n        : new Uint8Array(),\n      threshold: isSet(object.threshold)\n        ? bytesFromBase64(object.threshold)\n        : new Uint8Array(),\n      vetoThreshold: isSet(object.vetoThreshold)\n        ? bytesFromBase64(object.vetoThreshold)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: TallyParams): unknown {\n    const obj: any = {};\n    message.quorum !== undefined &&\n      (obj.quorum = base64FromBytes(\n        message.quorum !== undefined ? message.quorum : new Uint8Array()\n      ));\n    message.threshold !== undefined &&\n      (obj.threshold = base64FromBytes(\n        message.threshold !== undefined ? message.threshold : new Uint8Array()\n      ));\n    message.vetoThreshold !== undefined &&\n      (obj.vetoThreshold = base64FromBytes(\n        message.vetoThreshold !== undefined\n          ? message.vetoThreshold\n          : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TallyParams>, I>>(\n    object: I\n  ): TallyParams {\n    const message = createBaseTallyParams();\n    message.quorum = object.quorum ?? new Uint8Array();\n    message.threshold = object.threshold ?? new Uint8Array();\n    message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  VoteOption,\n  WeightedVoteOption,\n  voteOptionFromJSON,\n  voteOptionToJSON,\n} from \"./gov\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.gov.v1beta1\";\n\n/**\n * MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary\n * proposal Content.\n */\nexport interface MsgSubmitProposal {\n  content?: Any;\n  initialDeposit: Coin[];\n  proposer: string;\n}\n\n/** MsgSubmitProposalResponse defines the Msg/SubmitProposal response type. */\nexport interface MsgSubmitProposalResponse {\n  proposalId: Long;\n}\n\n/** MsgVote defines a message to cast a vote. */\nexport interface MsgVote {\n  proposalId: Long;\n  voter: string;\n  option: VoteOption;\n}\n\n/** MsgVoteResponse defines the Msg/Vote response type. */\nexport interface MsgVoteResponse {}\n\n/** MsgVoteWeighted defines a message to cast a vote. */\nexport interface MsgVoteWeighted {\n  proposalId: Long;\n  voter: string;\n  options: WeightedVoteOption[];\n}\n\n/** MsgVoteWeightedResponse defines the Msg/VoteWeighted response type. */\nexport interface MsgVoteWeightedResponse {}\n\n/** MsgDeposit defines a message to submit a deposit to an existing proposal. */\nexport interface MsgDeposit {\n  proposalId: Long;\n  depositor: string;\n  amount: Coin[];\n}\n\n/** MsgDepositResponse defines the Msg/Deposit response type. */\nexport interface MsgDepositResponse {}\n\nfunction createBaseMsgSubmitProposal(): MsgSubmitProposal {\n  return { content: undefined, initialDeposit: [], proposer: \"\" };\n}\n\nexport const MsgSubmitProposal = {\n  encode(\n    message: MsgSubmitProposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.content !== undefined) {\n      Any.encode(message.content, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.initialDeposit) {\n      Coin.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.proposer !== \"\") {\n      writer.uint32(26).string(message.proposer);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubmitProposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.content = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.initialDeposit.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.proposer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitProposal {\n    return {\n      content: isSet(object.content) ? Any.fromJSON(object.content) : undefined,\n      initialDeposit: Array.isArray(object?.initialDeposit)\n        ? object.initialDeposit.map((e: any) => Coin.fromJSON(e))\n        : [],\n      proposer: isSet(object.proposer) ? String(object.proposer) : \"\",\n    };\n  },\n\n  toJSON(message: MsgSubmitProposal): unknown {\n    const obj: any = {};\n    message.content !== undefined &&\n      (obj.content = message.content ? Any.toJSON(message.content) : undefined);\n    if (message.initialDeposit) {\n      obj.initialDeposit = message.initialDeposit.map((e) =>\n        e ? Coin.toJSON(e) : undefined\n      );\n    } else {\n      obj.initialDeposit = [];\n    }\n    message.proposer !== undefined && (obj.proposer = message.proposer);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitProposal>, I>>(\n    object: I\n  ): MsgSubmitProposal {\n    const message = createBaseMsgSubmitProposal();\n    message.content =\n      object.content !== undefined && object.content !== null\n        ? Any.fromPartial(object.content)\n        : undefined;\n    message.initialDeposit =\n      object.initialDeposit?.map((e) => Coin.fromPartial(e)) || [];\n    message.proposer = object.proposer ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgSubmitProposalResponse(): MsgSubmitProposalResponse {\n  return { proposalId: Long.UZERO };\n}\n\nexport const MsgSubmitProposalResponse = {\n  encode(\n    message: MsgSubmitProposalResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSubmitProposalResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSubmitProposalResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSubmitProposalResponse {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: MsgSubmitProposalResponse): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSubmitProposalResponse>, I>>(\n    object: I\n  ): MsgSubmitProposalResponse {\n    const message = createBaseMsgSubmitProposalResponse();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseMsgVote(): MsgVote {\n  return { proposalId: Long.UZERO, voter: \"\", option: 0 };\n}\n\nexport const MsgVote = {\n  encode(\n    message: MsgVote,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (message.option !== 0) {\n      writer.uint32(24).int32(message.option);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.option = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVote {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n    };\n  },\n\n  toJSON(message: MsgVote): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.option !== undefined &&\n      (obj.option = voteOptionToJSON(message.option));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVote>, I>>(object: I): MsgVote {\n    const message = createBaseMsgVote();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.option = object.option ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteResponse(): MsgVoteResponse {\n  return {};\n}\n\nexport const MsgVoteResponse = {\n  encode(\n    _: MsgVoteResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVoteResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVoteResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVoteResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteResponse>, I>>(\n    _: I\n  ): MsgVoteResponse {\n    const message = createBaseMsgVoteResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteWeighted(): MsgVoteWeighted {\n  return { proposalId: Long.UZERO, voter: \"\", options: [] };\n}\n\nexport const MsgVoteWeighted = {\n  encode(\n    message: MsgVoteWeighted,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    for (const v of message.options) {\n      WeightedVoteOption.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgVoteWeighted {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteWeighted();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.options.push(\n            WeightedVoteOption.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgVoteWeighted {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      voter: isSet(object.voter) ? String(object.voter) : \"\",\n      options: Array.isArray(object?.options)\n        ? object.options.map((e: any) => WeightedVoteOption.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgVoteWeighted): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.voter !== undefined && (obj.voter = message.voter);\n    if (message.options) {\n      obj.options = message.options.map((e) =>\n        e ? WeightedVoteOption.toJSON(e) : undefined\n      );\n    } else {\n      obj.options = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteWeighted>, I>>(\n    object: I\n  ): MsgVoteWeighted {\n    const message = createBaseMsgVoteWeighted();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.voter = object.voter ?? \"\";\n    message.options =\n      object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgVoteWeightedResponse(): MsgVoteWeightedResponse {\n  return {};\n}\n\nexport const MsgVoteWeightedResponse = {\n  encode(\n    _: MsgVoteWeightedResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgVoteWeightedResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgVoteWeightedResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgVoteWeightedResponse {\n    return {};\n  },\n\n  toJSON(_: MsgVoteWeightedResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgVoteWeightedResponse>, I>>(\n    _: I\n  ): MsgVoteWeightedResponse {\n    const message = createBaseMsgVoteWeightedResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDeposit(): MsgDeposit {\n  return { proposalId: Long.UZERO, depositor: \"\", amount: [] };\n}\n\nexport const MsgDeposit = {\n  encode(\n    message: MsgDeposit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.proposalId.isZero()) {\n      writer.uint32(8).uint64(message.proposalId);\n    }\n    if (message.depositor !== \"\") {\n      writer.uint32(18).string(message.depositor);\n    }\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeposit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDeposit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.proposalId = reader.uint64() as Long;\n          break;\n        case 2:\n          message.depositor = reader.string();\n          break;\n        case 3:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDeposit {\n    return {\n      proposalId: isSet(object.proposalId)\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO,\n      depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MsgDeposit): unknown {\n    const obj: any = {};\n    message.proposalId !== undefined &&\n      (obj.proposalId = (message.proposalId || Long.UZERO).toString());\n    message.depositor !== undefined && (obj.depositor = message.depositor);\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDeposit>, I>>(\n    object: I\n  ): MsgDeposit {\n    const message = createBaseMsgDeposit();\n    message.proposalId =\n      object.proposalId !== undefined && object.proposalId !== null\n        ? Long.fromValue(object.proposalId)\n        : Long.UZERO;\n    message.depositor = object.depositor ?? \"\";\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMsgDepositResponse(): MsgDepositResponse {\n  return {};\n}\n\nexport const MsgDepositResponse = {\n  encode(\n    _: MsgDepositResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDepositResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDepositResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDepositResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDepositResponse>, I>>(\n    _: I\n  ): MsgDepositResponse {\n    const message = createBaseMsgDepositResponse();\n    return message;\n  },\n};\n\n/** Msg defines the bank Msg service. */\nexport interface Msg {\n  /** SubmitProposal defines a method to create new proposal given a content. */\n  SubmitProposal(\n    request: DeepPartial<MsgSubmitProposal>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitProposalResponse>;\n  /** Vote defines a method to add a vote on a specific proposal. */\n  Vote(\n    request: DeepPartial<MsgVote>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteResponse>;\n  /**\n   * VoteWeighted defines a method to add a weighted vote on a specific\n   * proposal.\n   */\n  VoteWeighted(\n    request: DeepPartial<MsgVoteWeighted>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteWeightedResponse>;\n  /** Deposit defines a method to add deposit on a specific proposal. */\n  Deposit(\n    request: DeepPartial<MsgDeposit>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDepositResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.SubmitProposal = this.SubmitProposal.bind(this);\n    this.Vote = this.Vote.bind(this);\n    this.VoteWeighted = this.VoteWeighted.bind(this);\n    this.Deposit = this.Deposit.bind(this);\n  }\n\n  SubmitProposal(\n    request: DeepPartial<MsgSubmitProposal>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSubmitProposalResponse> {\n    return this.rpc.unary(\n      MsgSubmitProposalDesc,\n      MsgSubmitProposal.fromPartial(request),\n      metadata\n    );\n  }\n\n  Vote(\n    request: DeepPartial<MsgVote>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteResponse> {\n    return this.rpc.unary(MsgVoteDesc, MsgVote.fromPartial(request), metadata);\n  }\n\n  VoteWeighted(\n    request: DeepPartial<MsgVoteWeighted>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgVoteWeightedResponse> {\n    return this.rpc.unary(\n      MsgVoteWeightedDesc,\n      MsgVoteWeighted.fromPartial(request),\n      metadata\n    );\n  }\n\n  Deposit(\n    request: DeepPartial<MsgDeposit>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDepositResponse> {\n    return this.rpc.unary(\n      MsgDepositDesc,\n      MsgDeposit.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.gov.v1beta1.Msg\",\n};\n\nexport const MsgSubmitProposalDesc: UnaryMethodDefinitionish = {\n  methodName: \"SubmitProposal\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSubmitProposal.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSubmitProposalResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgVoteDesc: UnaryMethodDefinitionish = {\n  methodName: \"Vote\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVote.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVoteResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgVoteWeightedDesc: UnaryMethodDefinitionish = {\n  methodName: \"VoteWeighted\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgVoteWeighted.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgVoteWeightedResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDepositDesc: UnaryMethodDefinitionish = {\n  methodName: \"Deposit\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDeposit.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDepositResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from './BaseMsg';\nimport {\n  protobufPackage,\n  MsgSubmitProposal as MsgSubmitProposal_pb,\n  MsgVote as MsgVote_pb,\n  MsgVoteWeighted as MsgVoteWeighted_pb,\n  MsgDeposit as MsgDeposit_pb,\n} from \"../proto/cosmos/gov/v1beta1/tx\";\nimport {EncodeObject} from \"@cosmjs/proto-signing\";\n\nexport class MsgSubmitProposal extends BaseMsg {\n  public protoMsg: MsgSubmitProposal_pb;\n  constructor(msg: MsgSubmitProposal_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSubmitProposal.typeUrl,\n      value: MsgSubmitProposal_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSubmitProposal {\n  export const typeUrl: string = `/${protobufPackage}.MsgSubmitProposal`;\n  export const Proto = MsgSubmitProposal_pb;\n  export interface Proto extends MsgSubmitProposal_pb {}\n}\n\nexport class MsgDeposit extends BaseMsg {\n  public static TYPE_URL = `/${protobufPackage}.MsgDeposit`;\n  public protoMsg: MsgDeposit_pb;\n  constructor(msg: MsgDeposit_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDeposit.TYPE_URL,\n      value: MsgDeposit_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDeposit {\n  export const typeUrl: string = `/${protobufPackage}.MsgDeposit`;\n  export const Proto = MsgDeposit_pb;\n  export interface Proto extends MsgDeposit_pb {}\n}\n\nexport class MsgVote extends BaseMsg {\n  public protoMsg: MsgVote_pb;\n  constructor(msg: MsgVote_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVote.typeUrl,\n      value: MsgVote_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVote {\n  export const typeUrl: string = `/${protobufPackage}.MsgVote`;\n  export const Proto = MsgVote_pb;\n  export interface Proto extends MsgVote_pb {}\n}\n\nexport class MsgVoteWeighted extends BaseMsg {\n  public protoMsg: MsgVoteWeighted_pb;\n  constructor(msg: MsgVoteWeighted_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgVoteWeighted.typeUrl,\n      value: MsgVoteWeighted_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgVoteWeighted {\n  export const typeUrl: string = `/${protobufPackage}.MsgVoteWeighted`;\n  export const Proto = MsgVoteWeighted_pb;\n  export interface Proto extends MsgVoteWeighted_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.crypto\";\n\nexport interface Proof {\n  total: Long;\n  index: Long;\n  leafHash: Uint8Array;\n  aunts: Uint8Array[];\n}\n\nexport interface ValueOp {\n  /** Encoded in ProofOp.Key. */\n  key: Uint8Array;\n  /** To encode in ProofOp.Data */\n  proof?: Proof;\n}\n\nexport interface DominoOp {\n  key: string;\n  input: string;\n  output: string;\n}\n\n/**\n * ProofOp defines an operation used for calculating Merkle root\n * The data could be arbitrary format, providing nessecary data\n * for example neighbouring node hash\n */\nexport interface ProofOp {\n  type: string;\n  key: Uint8Array;\n  data: Uint8Array;\n}\n\n/** ProofOps is Merkle proof defined by the list of ProofOps */\nexport interface ProofOps {\n  ops: ProofOp[];\n}\n\nfunction createBaseProof(): Proof {\n  return {\n    total: Long.ZERO,\n    index: Long.ZERO,\n    leafHash: new Uint8Array(),\n    aunts: [],\n  };\n}\n\nexport const Proof = {\n  encode(message: Proof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.total.isZero()) {\n      writer.uint32(8).int64(message.total);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(16).int64(message.index);\n    }\n    if (message.leafHash.length !== 0) {\n      writer.uint32(26).bytes(message.leafHash);\n    }\n    for (const v of message.aunts) {\n      writer.uint32(34).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proof {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.int64() as Long;\n          break;\n        case 2:\n          message.index = reader.int64() as Long;\n          break;\n        case 3:\n          message.leafHash = reader.bytes();\n          break;\n        case 4:\n          message.aunts.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proof {\n    return {\n      total: isSet(object.total) ? Long.fromValue(object.total) : Long.ZERO,\n      index: isSet(object.index) ? Long.fromValue(object.index) : Long.ZERO,\n      leafHash: isSet(object.leafHash)\n        ? bytesFromBase64(object.leafHash)\n        : new Uint8Array(),\n      aunts: Array.isArray(object?.aunts)\n        ? object.aunts.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Proof): unknown {\n    const obj: any = {};\n    message.total !== undefined &&\n      (obj.total = (message.total || Long.ZERO).toString());\n    message.index !== undefined &&\n      (obj.index = (message.index || Long.ZERO).toString());\n    message.leafHash !== undefined &&\n      (obj.leafHash = base64FromBytes(\n        message.leafHash !== undefined ? message.leafHash : new Uint8Array()\n      ));\n    if (message.aunts) {\n      obj.aunts = message.aunts.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.aunts = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proof>, I>>(object: I): Proof {\n    const message = createBaseProof();\n    message.total =\n      object.total !== undefined && object.total !== null\n        ? Long.fromValue(object.total)\n        : Long.ZERO;\n    message.index =\n      object.index !== undefined && object.index !== null\n        ? Long.fromValue(object.index)\n        : Long.ZERO;\n    message.leafHash = object.leafHash ?? new Uint8Array();\n    message.aunts = object.aunts?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseValueOp(): ValueOp {\n  return { key: new Uint8Array(), proof: undefined };\n}\n\nexport const ValueOp = {\n  encode(\n    message: ValueOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValueOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValueOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValueOp {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: ValueOp): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValueOp>, I>>(object: I): ValueOp {\n    const message = createBaseValueOp();\n    message.key = object.key ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseDominoOp(): DominoOp {\n  return { key: \"\", input: \"\", output: \"\" };\n}\n\nexport const DominoOp = {\n  encode(\n    message: DominoOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.input !== \"\") {\n      writer.uint32(18).string(message.input);\n    }\n    if (message.output !== \"\") {\n      writer.uint32(26).string(message.output);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DominoOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDominoOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.input = reader.string();\n          break;\n        case 3:\n          message.output = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DominoOp {\n    return {\n      key: isSet(object.key) ? String(object.key) : \"\",\n      input: isSet(object.input) ? String(object.input) : \"\",\n      output: isSet(object.output) ? String(object.output) : \"\",\n    };\n  },\n\n  toJSON(message: DominoOp): unknown {\n    const obj: any = {};\n    message.key !== undefined && (obj.key = message.key);\n    message.input !== undefined && (obj.input = message.input);\n    message.output !== undefined && (obj.output = message.output);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DominoOp>, I>>(object: I): DominoOp {\n    const message = createBaseDominoOp();\n    message.key = object.key ?? \"\";\n    message.input = object.input ?? \"\";\n    message.output = object.output ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseProofOp(): ProofOp {\n  return { type: \"\", key: new Uint8Array(), data: new Uint8Array() };\n}\n\nexport const ProofOp = {\n  encode(\n    message: ProofOp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.key.length !== 0) {\n      writer.uint32(18).bytes(message.key);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(26).bytes(message.data);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofOp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.key = reader.bytes();\n          break;\n        case 3:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ProofOp {\n    return {\n      type: isSet(object.type) ? String(object.type) : \"\",\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: ProofOp): unknown {\n    const obj: any = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ProofOp>, I>>(object: I): ProofOp {\n    const message = createBaseProofOp();\n    message.type = object.type ?? \"\";\n    message.key = object.key ?? new Uint8Array();\n    message.data = object.data ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseProofOps(): ProofOps {\n  return { ops: [] };\n}\n\nexport const ProofOps = {\n  encode(\n    message: ProofOps,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.ops) {\n      ProofOp.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOps {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProofOps();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ops.push(ProofOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ProofOps {\n    return {\n      ops: Array.isArray(object?.ops)\n        ? object.ops.map((e: any) => ProofOp.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ProofOps): unknown {\n    const obj: any = {};\n    if (message.ops) {\n      obj.ops = message.ops.map((e) => (e ? ProofOp.toJSON(e) : undefined));\n    } else {\n      obj.ops = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ProofOps>, I>>(object: I): ProofOps {\n    const message = createBaseProofOps();\n    message.ops = object.ops?.map((e) => ProofOp.fromPartial(e)) || [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.version\";\n\n/**\n * App includes the protocol and software version for the application.\n * This information is included in ResponseInfo. The App.Protocol can be\n * updated in ResponseEndBlock.\n */\nexport interface App {\n  protocol: Long;\n  software: string;\n}\n\n/**\n * Consensus captures the consensus rules for processing a block in the\n * blockchain, including all blockchain data structures and the rules of the\n * application's state transition machine.\n */\nexport interface Consensus {\n  block: Long;\n  app: Long;\n}\n\nfunction createBaseApp(): App {\n  return { protocol: Long.UZERO, software: \"\" };\n}\n\nexport const App = {\n  encode(message: App, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (!message.protocol.isZero()) {\n      writer.uint32(8).uint64(message.protocol);\n    }\n    if (message.software !== \"\") {\n      writer.uint32(18).string(message.software);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): App {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseApp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.protocol = reader.uint64() as Long;\n          break;\n        case 2:\n          message.software = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): App {\n    return {\n      protocol: isSet(object.protocol)\n        ? Long.fromValue(object.protocol)\n        : Long.UZERO,\n      software: isSet(object.software) ? String(object.software) : \"\",\n    };\n  },\n\n  toJSON(message: App): unknown {\n    const obj: any = {};\n    message.protocol !== undefined &&\n      (obj.protocol = (message.protocol || Long.UZERO).toString());\n    message.software !== undefined && (obj.software = message.software);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<App>, I>>(object: I): App {\n    const message = createBaseApp();\n    message.protocol =\n      object.protocol !== undefined && object.protocol !== null\n        ? Long.fromValue(object.protocol)\n        : Long.UZERO;\n    message.software = object.software ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseConsensus(): Consensus {\n  return { block: Long.UZERO, app: Long.UZERO };\n}\n\nexport const Consensus = {\n  encode(\n    message: Consensus,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.block.isZero()) {\n      writer.uint32(8).uint64(message.block);\n    }\n    if (!message.app.isZero()) {\n      writer.uint32(16).uint64(message.app);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Consensus {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseConsensus();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.block = reader.uint64() as Long;\n          break;\n        case 2:\n          message.app = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Consensus {\n    return {\n      block: isSet(object.block) ? Long.fromValue(object.block) : Long.UZERO,\n      app: isSet(object.app) ? Long.fromValue(object.app) : Long.UZERO,\n    };\n  },\n\n  toJSON(message: Consensus): unknown {\n    const obj: any = {};\n    message.block !== undefined &&\n      (obj.block = (message.block || Long.UZERO).toString());\n    message.app !== undefined &&\n      (obj.app = (message.app || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Consensus>, I>>(\n    object: I\n  ): Consensus {\n    const message = createBaseConsensus();\n    message.block =\n      object.block !== undefined && object.block !== null\n        ? Long.fromValue(object.block)\n        : Long.UZERO;\n    message.app =\n      object.app !== undefined && object.app !== null\n        ? Long.fromValue(object.app)\n        : Long.UZERO;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"tendermint.crypto\";\n\n/** PublicKey defines the keys available for use with Tendermint Validators */\nexport interface PublicKey {\n  ed25519: Uint8Array | undefined;\n  secp256k1: Uint8Array | undefined;\n}\n\nfunction createBasePublicKey(): PublicKey {\n  return { ed25519: undefined, secp256k1: undefined };\n}\n\nexport const PublicKey = {\n  encode(\n    message: PublicKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.ed25519 !== undefined) {\n      writer.uint32(10).bytes(message.ed25519);\n    }\n    if (message.secp256k1 !== undefined) {\n      writer.uint32(18).bytes(message.secp256k1);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PublicKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePublicKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ed25519 = reader.bytes();\n          break;\n        case 2:\n          message.secp256k1 = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PublicKey {\n    return {\n      ed25519: isSet(object.ed25519)\n        ? bytesFromBase64(object.ed25519)\n        : undefined,\n      secp256k1: isSet(object.secp256k1)\n        ? bytesFromBase64(object.secp256k1)\n        : undefined,\n    };\n  },\n\n  toJSON(message: PublicKey): unknown {\n    const obj: any = {};\n    message.ed25519 !== undefined &&\n      (obj.ed25519 =\n        message.ed25519 !== undefined\n          ? base64FromBytes(message.ed25519)\n          : undefined);\n    message.secp256k1 !== undefined &&\n      (obj.secp256k1 =\n        message.secp256k1 !== undefined\n          ? base64FromBytes(message.secp256k1)\n          : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PublicKey>, I>>(\n    object: I\n  ): PublicKey {\n    const message = createBasePublicKey();\n    message.ed25519 = object.ed25519 ?? undefined;\n    message.secp256k1 = object.secp256k1 ?? undefined;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { PublicKey } from \"../crypto/keys\";\n\nexport const protobufPackage = \"tendermint.types\";\n\nexport interface ValidatorSet {\n  validators: Validator[];\n  proposer?: Validator;\n  totalVotingPower: Long;\n}\n\nexport interface Validator {\n  address: Uint8Array;\n  pubKey?: PublicKey;\n  votingPower: Long;\n  proposerPriority: Long;\n}\n\nexport interface SimpleValidator {\n  pubKey?: PublicKey;\n  votingPower: Long;\n}\n\nfunction createBaseValidatorSet(): ValidatorSet {\n  return { validators: [], proposer: undefined, totalVotingPower: Long.ZERO };\n}\n\nexport const ValidatorSet = {\n  encode(\n    message: ValidatorSet,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.validators) {\n      Validator.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proposer !== undefined) {\n      Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.totalVotingPower.isZero()) {\n      writer.uint32(24).int64(message.totalVotingPower);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValidatorSet {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidatorSet();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validators.push(Validator.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.proposer = Validator.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.totalVotingPower = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValidatorSet {\n    return {\n      validators: Array.isArray(object?.validators)\n        ? object.validators.map((e: any) => Validator.fromJSON(e))\n        : [],\n      proposer: isSet(object.proposer)\n        ? Validator.fromJSON(object.proposer)\n        : undefined,\n      totalVotingPower: isSet(object.totalVotingPower)\n        ? Long.fromValue(object.totalVotingPower)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: ValidatorSet): unknown {\n    const obj: any = {};\n    if (message.validators) {\n      obj.validators = message.validators.map((e) =>\n        e ? Validator.toJSON(e) : undefined\n      );\n    } else {\n      obj.validators = [];\n    }\n    message.proposer !== undefined &&\n      (obj.proposer = message.proposer\n        ? Validator.toJSON(message.proposer)\n        : undefined);\n    message.totalVotingPower !== undefined &&\n      (obj.totalVotingPower = (\n        message.totalVotingPower || Long.ZERO\n      ).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValidatorSet>, I>>(\n    object: I\n  ): ValidatorSet {\n    const message = createBaseValidatorSet();\n    message.validators =\n      object.validators?.map((e) => Validator.fromPartial(e)) || [];\n    message.proposer =\n      object.proposer !== undefined && object.proposer !== null\n        ? Validator.fromPartial(object.proposer)\n        : undefined;\n    message.totalVotingPower =\n      object.totalVotingPower !== undefined && object.totalVotingPower !== null\n        ? Long.fromValue(object.totalVotingPower)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseValidator(): Validator {\n  return {\n    address: new Uint8Array(),\n    pubKey: undefined,\n    votingPower: Long.ZERO,\n    proposerPriority: Long.ZERO,\n  };\n}\n\nexport const Validator = {\n  encode(\n    message: Validator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.address.length !== 0) {\n      writer.uint32(10).bytes(message.address);\n    }\n    if (message.pubKey !== undefined) {\n      PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.votingPower.isZero()) {\n      writer.uint32(24).int64(message.votingPower);\n    }\n    if (!message.proposerPriority.isZero()) {\n      writer.uint32(32).int64(message.proposerPriority);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.bytes();\n          break;\n        case 2:\n          message.pubKey = PublicKey.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.votingPower = reader.int64() as Long;\n          break;\n        case 4:\n          message.proposerPriority = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Validator {\n    return {\n      address: isSet(object.address)\n        ? bytesFromBase64(object.address)\n        : new Uint8Array(),\n      pubKey: isSet(object.pubKey)\n        ? PublicKey.fromJSON(object.pubKey)\n        : undefined,\n      votingPower: isSet(object.votingPower)\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO,\n      proposerPriority: isSet(object.proposerPriority)\n        ? Long.fromValue(object.proposerPriority)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: Validator): unknown {\n    const obj: any = {};\n    message.address !== undefined &&\n      (obj.address = base64FromBytes(\n        message.address !== undefined ? message.address : new Uint8Array()\n      ));\n    message.pubKey !== undefined &&\n      (obj.pubKey = message.pubKey\n        ? PublicKey.toJSON(message.pubKey)\n        : undefined);\n    message.votingPower !== undefined &&\n      (obj.votingPower = (message.votingPower || Long.ZERO).toString());\n    message.proposerPriority !== undefined &&\n      (obj.proposerPriority = (\n        message.proposerPriority || Long.ZERO\n      ).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Validator>, I>>(\n    object: I\n  ): Validator {\n    const message = createBaseValidator();\n    message.address = object.address ?? new Uint8Array();\n    message.pubKey =\n      object.pubKey !== undefined && object.pubKey !== null\n        ? PublicKey.fromPartial(object.pubKey)\n        : undefined;\n    message.votingPower =\n      object.votingPower !== undefined && object.votingPower !== null\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO;\n    message.proposerPriority =\n      object.proposerPriority !== undefined && object.proposerPriority !== null\n        ? Long.fromValue(object.proposerPriority)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseSimpleValidator(): SimpleValidator {\n  return { pubKey: undefined, votingPower: Long.ZERO };\n}\n\nexport const SimpleValidator = {\n  encode(\n    message: SimpleValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.pubKey !== undefined) {\n      PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.votingPower.isZero()) {\n      writer.uint32(16).int64(message.votingPower);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SimpleValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSimpleValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pubKey = PublicKey.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.votingPower = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SimpleValidator {\n    return {\n      pubKey: isSet(object.pubKey)\n        ? PublicKey.fromJSON(object.pubKey)\n        : undefined,\n      votingPower: isSet(object.votingPower)\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO,\n    };\n  },\n\n  toJSON(message: SimpleValidator): unknown {\n    const obj: any = {};\n    message.pubKey !== undefined &&\n      (obj.pubKey = message.pubKey\n        ? PublicKey.toJSON(message.pubKey)\n        : undefined);\n    message.votingPower !== undefined &&\n      (obj.votingPower = (message.votingPower || Long.ZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SimpleValidator>, I>>(\n    object: I\n  ): SimpleValidator {\n    const message = createBaseSimpleValidator();\n    message.pubKey =\n      object.pubKey !== undefined && object.pubKey !== null\n        ? PublicKey.fromPartial(object.pubKey)\n        : undefined;\n    message.votingPower =\n      object.votingPower !== undefined && object.votingPower !== null\n        ? Long.fromValue(object.votingPower)\n        : Long.ZERO;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Proof } from \"../crypto/proof\";\nimport { Consensus } from \"../version/types\";\nimport { ValidatorSet } from \"./validator\";\nimport { Timestamp } from \"../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"tendermint.types\";\n\n/** BlockIdFlag indicates which BlcokID the signature is for */\nexport enum BlockIDFlag {\n  BLOCK_ID_FLAG_UNKNOWN = 0,\n  BLOCK_ID_FLAG_ABSENT = 1,\n  BLOCK_ID_FLAG_COMMIT = 2,\n  BLOCK_ID_FLAG_NIL = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function blockIDFlagFromJSON(object: any): BlockIDFlag {\n  switch (object) {\n    case 0:\n    case \"BLOCK_ID_FLAG_UNKNOWN\":\n      return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n    case 1:\n    case \"BLOCK_ID_FLAG_ABSENT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n    case 2:\n    case \"BLOCK_ID_FLAG_COMMIT\":\n      return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n    case 3:\n    case \"BLOCK_ID_FLAG_NIL\":\n      return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BlockIDFlag.UNRECOGNIZED;\n  }\n}\n\nexport function blockIDFlagToJSON(object: BlockIDFlag): string {\n  switch (object) {\n    case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:\n      return \"BLOCK_ID_FLAG_UNKNOWN\";\n    case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:\n      return \"BLOCK_ID_FLAG_ABSENT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:\n      return \"BLOCK_ID_FLAG_COMMIT\";\n    case BlockIDFlag.BLOCK_ID_FLAG_NIL:\n      return \"BLOCK_ID_FLAG_NIL\";\n    case BlockIDFlag.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignedMsgType is a type of signed message in the consensus. */\nexport enum SignedMsgType {\n  SIGNED_MSG_TYPE_UNKNOWN = 0,\n  /** SIGNED_MSG_TYPE_PREVOTE - Votes */\n  SIGNED_MSG_TYPE_PREVOTE = 1,\n  SIGNED_MSG_TYPE_PRECOMMIT = 2,\n  /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */\n  SIGNED_MSG_TYPE_PROPOSAL = 32,\n  UNRECOGNIZED = -1,\n}\n\nexport function signedMsgTypeFromJSON(object: any): SignedMsgType {\n  switch (object) {\n    case 0:\n    case \"SIGNED_MSG_TYPE_UNKNOWN\":\n      return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n    case 1:\n    case \"SIGNED_MSG_TYPE_PREVOTE\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n    case 2:\n    case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n    case 32:\n    case \"SIGNED_MSG_TYPE_PROPOSAL\":\n      return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignedMsgType.UNRECOGNIZED;\n  }\n}\n\nexport function signedMsgTypeToJSON(object: SignedMsgType): string {\n  switch (object) {\n    case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:\n      return \"SIGNED_MSG_TYPE_UNKNOWN\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:\n      return \"SIGNED_MSG_TYPE_PREVOTE\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:\n      return \"SIGNED_MSG_TYPE_PRECOMMIT\";\n    case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:\n      return \"SIGNED_MSG_TYPE_PROPOSAL\";\n    case SignedMsgType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** PartsetHeader */\nexport interface PartSetHeader {\n  total: number;\n  hash: Uint8Array;\n}\n\nexport interface Part {\n  index: number;\n  bytes: Uint8Array;\n  proof?: Proof;\n}\n\n/** BlockID */\nexport interface BlockID {\n  hash: Uint8Array;\n  partSetHeader?: PartSetHeader;\n}\n\n/** Header defines the structure of a Tendermint block header. */\nexport interface Header {\n  /** basic block info */\n  version?: Consensus;\n  chainId: string;\n  height: Long;\n  time?: Date;\n  /** prev block info */\n  lastBlockId?: BlockID;\n  /** hashes of block data */\n  lastCommitHash: Uint8Array;\n  /** transactions */\n  dataHash: Uint8Array;\n  /** hashes from the app output from the prev block */\n  validatorsHash: Uint8Array;\n  /** validators for the next block */\n  nextValidatorsHash: Uint8Array;\n  /** consensus params for current block */\n  consensusHash: Uint8Array;\n  /** state after txs from the previous block */\n  appHash: Uint8Array;\n  /** root hash of all results from the txs from the previous block */\n  lastResultsHash: Uint8Array;\n  /** consensus info */\n  evidenceHash: Uint8Array;\n  /** original proposer of the block */\n  proposerAddress: Uint8Array;\n}\n\n/** Data contains the set of transactions included in the block */\nexport interface Data {\n  /**\n   * Txs that will be applied by state @ block.Height+1.\n   * NOTE: not all txs here are valid.  We're just agreeing on the order first.\n   * This means that block.AppHash does not include these txs.\n   */\n  txs: Uint8Array[];\n}\n\n/**\n * Vote represents a prevote, precommit, or commit vote from validators for\n * consensus.\n */\nexport interface Vote {\n  type: SignedMsgType;\n  height: Long;\n  round: number;\n  /** zero if vote is nil. */\n  blockId?: BlockID;\n  timestamp?: Date;\n  validatorAddress: Uint8Array;\n  validatorIndex: number;\n  signature: Uint8Array;\n}\n\n/**\n * Commit contains the evidence that a block was committed by a set of\n * validators.\n */\nexport interface Commit {\n  height: Long;\n  round: number;\n  blockId?: BlockID;\n  signatures: CommitSig[];\n}\n\n/** CommitSig is a part of the Vote included in a Commit. */\nexport interface CommitSig {\n  blockIdFlag: BlockIDFlag;\n  validatorAddress: Uint8Array;\n  timestamp?: Date;\n  signature: Uint8Array;\n}\n\nexport interface Proposal {\n  type: SignedMsgType;\n  height: Long;\n  round: number;\n  polRound: number;\n  blockId?: BlockID;\n  timestamp?: Date;\n  signature: Uint8Array;\n}\n\nexport interface SignedHeader {\n  header?: Header;\n  commit?: Commit;\n}\n\nexport interface LightBlock {\n  signedHeader?: SignedHeader;\n  validatorSet?: ValidatorSet;\n}\n\nexport interface BlockMeta {\n  blockId?: BlockID;\n  blockSize: Long;\n  header?: Header;\n  numTxs: Long;\n}\n\n/**\n * TxProof represents a Merkle proof of the presence of a transaction in the\n * Merkle tree.\n */\nexport interface TxProof {\n  rootHash: Uint8Array;\n  data: Uint8Array;\n  proof?: Proof;\n}\n\nfunction createBasePartSetHeader(): PartSetHeader {\n  return { total: 0, hash: new Uint8Array() };\n}\n\nexport const PartSetHeader = {\n  encode(\n    message: PartSetHeader,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.total !== 0) {\n      writer.uint32(8).uint32(message.total);\n    }\n    if (message.hash.length !== 0) {\n      writer.uint32(18).bytes(message.hash);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PartSetHeader {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePartSetHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.uint32();\n          break;\n        case 2:\n          message.hash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PartSetHeader {\n    return {\n      total: isSet(object.total) ? Number(object.total) : 0,\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PartSetHeader): unknown {\n    const obj: any = {};\n    message.total !== undefined && (obj.total = Math.round(message.total));\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PartSetHeader>, I>>(\n    object: I\n  ): PartSetHeader {\n    const message = createBasePartSetHeader();\n    message.total = object.total ?? 0;\n    message.hash = object.hash ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePart(): Part {\n  return { index: 0, bytes: new Uint8Array(), proof: undefined };\n}\n\nexport const Part = {\n  encode(message: Part, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.index !== 0) {\n      writer.uint32(8).uint32(message.index);\n    }\n    if (message.bytes.length !== 0) {\n      writer.uint32(18).bytes(message.bytes);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Part {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePart();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.uint32();\n          break;\n        case 2:\n          message.bytes = reader.bytes();\n          break;\n        case 3:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Part {\n    return {\n      index: isSet(object.index) ? Number(object.index) : 0,\n      bytes: isSet(object.bytes)\n        ? bytesFromBase64(object.bytes)\n        : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: Part): unknown {\n    const obj: any = {};\n    message.index !== undefined && (obj.index = Math.round(message.index));\n    message.bytes !== undefined &&\n      (obj.bytes = base64FromBytes(\n        message.bytes !== undefined ? message.bytes : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Part>, I>>(object: I): Part {\n    const message = createBasePart();\n    message.index = object.index ?? 0;\n    message.bytes = object.bytes ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseBlockID(): BlockID {\n  return { hash: new Uint8Array(), partSetHeader: undefined };\n}\n\nexport const BlockID = {\n  encode(\n    message: BlockID,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    if (message.partSetHeader !== undefined) {\n      PartSetHeader.encode(\n        message.partSetHeader,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): BlockID {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBlockID();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        case 2:\n          message.partSetHeader = PartSetHeader.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): BlockID {\n    return {\n      hash: isSet(object.hash)\n        ? bytesFromBase64(object.hash)\n        : new Uint8Array(),\n      partSetHeader: isSet(object.partSetHeader)\n        ? PartSetHeader.fromJSON(object.partSetHeader)\n        : undefined,\n    };\n  },\n\n  toJSON(message: BlockID): unknown {\n    const obj: any = {};\n    message.hash !== undefined &&\n      (obj.hash = base64FromBytes(\n        message.hash !== undefined ? message.hash : new Uint8Array()\n      ));\n    message.partSetHeader !== undefined &&\n      (obj.partSetHeader = message.partSetHeader\n        ? PartSetHeader.toJSON(message.partSetHeader)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<BlockID>, I>>(object: I): BlockID {\n    const message = createBaseBlockID();\n    message.hash = object.hash ?? new Uint8Array();\n    message.partSetHeader =\n      object.partSetHeader !== undefined && object.partSetHeader !== null\n        ? PartSetHeader.fromPartial(object.partSetHeader)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseHeader(): Header {\n  return {\n    version: undefined,\n    chainId: \"\",\n    height: Long.ZERO,\n    time: undefined,\n    lastBlockId: undefined,\n    lastCommitHash: new Uint8Array(),\n    dataHash: new Uint8Array(),\n    validatorsHash: new Uint8Array(),\n    nextValidatorsHash: new Uint8Array(),\n    consensusHash: new Uint8Array(),\n    appHash: new Uint8Array(),\n    lastResultsHash: new Uint8Array(),\n    evidenceHash: new Uint8Array(),\n    proposerAddress: new Uint8Array(),\n  };\n}\n\nexport const Header = {\n  encode(\n    message: Header,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.version !== undefined) {\n      Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.time !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.time),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    if (message.lastBlockId !== undefined) {\n      BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.lastCommitHash.length !== 0) {\n      writer.uint32(50).bytes(message.lastCommitHash);\n    }\n    if (message.dataHash.length !== 0) {\n      writer.uint32(58).bytes(message.dataHash);\n    }\n    if (message.validatorsHash.length !== 0) {\n      writer.uint32(66).bytes(message.validatorsHash);\n    }\n    if (message.nextValidatorsHash.length !== 0) {\n      writer.uint32(74).bytes(message.nextValidatorsHash);\n    }\n    if (message.consensusHash.length !== 0) {\n      writer.uint32(82).bytes(message.consensusHash);\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(90).bytes(message.appHash);\n    }\n    if (message.lastResultsHash.length !== 0) {\n      writer.uint32(98).bytes(message.lastResultsHash);\n    }\n    if (message.evidenceHash.length !== 0) {\n      writer.uint32(106).bytes(message.evidenceHash);\n    }\n    if (message.proposerAddress.length !== 0) {\n      writer.uint32(114).bytes(message.proposerAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Header {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.version = Consensus.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.chainId = reader.string();\n          break;\n        case 3:\n          message.height = reader.int64() as Long;\n          break;\n        case 4:\n          message.time = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 5:\n          message.lastBlockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.lastCommitHash = reader.bytes();\n          break;\n        case 7:\n          message.dataHash = reader.bytes();\n          break;\n        case 8:\n          message.validatorsHash = reader.bytes();\n          break;\n        case 9:\n          message.nextValidatorsHash = reader.bytes();\n          break;\n        case 10:\n          message.consensusHash = reader.bytes();\n          break;\n        case 11:\n          message.appHash = reader.bytes();\n          break;\n        case 12:\n          message.lastResultsHash = reader.bytes();\n          break;\n        case 13:\n          message.evidenceHash = reader.bytes();\n          break;\n        case 14:\n          message.proposerAddress = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Header {\n    return {\n      version: isSet(object.version)\n        ? Consensus.fromJSON(object.version)\n        : undefined,\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,\n      lastBlockId: isSet(object.lastBlockId)\n        ? BlockID.fromJSON(object.lastBlockId)\n        : undefined,\n      lastCommitHash: isSet(object.lastCommitHash)\n        ? bytesFromBase64(object.lastCommitHash)\n        : new Uint8Array(),\n      dataHash: isSet(object.dataHash)\n        ? bytesFromBase64(object.dataHash)\n        : new Uint8Array(),\n      validatorsHash: isSet(object.validatorsHash)\n        ? bytesFromBase64(object.validatorsHash)\n        : new Uint8Array(),\n      nextValidatorsHash: isSet(object.nextValidatorsHash)\n        ? bytesFromBase64(object.nextValidatorsHash)\n        : new Uint8Array(),\n      consensusHash: isSet(object.consensusHash)\n        ? bytesFromBase64(object.consensusHash)\n        : new Uint8Array(),\n      appHash: isSet(object.appHash)\n        ? bytesFromBase64(object.appHash)\n        : new Uint8Array(),\n      lastResultsHash: isSet(object.lastResultsHash)\n        ? bytesFromBase64(object.lastResultsHash)\n        : new Uint8Array(),\n      evidenceHash: isSet(object.evidenceHash)\n        ? bytesFromBase64(object.evidenceHash)\n        : new Uint8Array(),\n      proposerAddress: isSet(object.proposerAddress)\n        ? bytesFromBase64(object.proposerAddress)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Header): unknown {\n    const obj: any = {};\n    message.version !== undefined &&\n      (obj.version = message.version\n        ? Consensus.toJSON(message.version)\n        : undefined);\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.time !== undefined && (obj.time = message.time.toISOString());\n    message.lastBlockId !== undefined &&\n      (obj.lastBlockId = message.lastBlockId\n        ? BlockID.toJSON(message.lastBlockId)\n        : undefined);\n    message.lastCommitHash !== undefined &&\n      (obj.lastCommitHash = base64FromBytes(\n        message.lastCommitHash !== undefined\n          ? message.lastCommitHash\n          : new Uint8Array()\n      ));\n    message.dataHash !== undefined &&\n      (obj.dataHash = base64FromBytes(\n        message.dataHash !== undefined ? message.dataHash : new Uint8Array()\n      ));\n    message.validatorsHash !== undefined &&\n      (obj.validatorsHash = base64FromBytes(\n        message.validatorsHash !== undefined\n          ? message.validatorsHash\n          : new Uint8Array()\n      ));\n    message.nextValidatorsHash !== undefined &&\n      (obj.nextValidatorsHash = base64FromBytes(\n        message.nextValidatorsHash !== undefined\n          ? message.nextValidatorsHash\n          : new Uint8Array()\n      ));\n    message.consensusHash !== undefined &&\n      (obj.consensusHash = base64FromBytes(\n        message.consensusHash !== undefined\n          ? message.consensusHash\n          : new Uint8Array()\n      ));\n    message.appHash !== undefined &&\n      (obj.appHash = base64FromBytes(\n        message.appHash !== undefined ? message.appHash : new Uint8Array()\n      ));\n    message.lastResultsHash !== undefined &&\n      (obj.lastResultsHash = base64FromBytes(\n        message.lastResultsHash !== undefined\n          ? message.lastResultsHash\n          : new Uint8Array()\n      ));\n    message.evidenceHash !== undefined &&\n      (obj.evidenceHash = base64FromBytes(\n        message.evidenceHash !== undefined\n          ? message.evidenceHash\n          : new Uint8Array()\n      ));\n    message.proposerAddress !== undefined &&\n      (obj.proposerAddress = base64FromBytes(\n        message.proposerAddress !== undefined\n          ? message.proposerAddress\n          : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {\n    const message = createBaseHeader();\n    message.version =\n      object.version !== undefined && object.version !== null\n        ? Consensus.fromPartial(object.version)\n        : undefined;\n    message.chainId = object.chainId ?? \"\";\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.time = object.time ?? undefined;\n    message.lastBlockId =\n      object.lastBlockId !== undefined && object.lastBlockId !== null\n        ? BlockID.fromPartial(object.lastBlockId)\n        : undefined;\n    message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();\n    message.dataHash = object.dataHash ?? new Uint8Array();\n    message.validatorsHash = object.validatorsHash ?? new Uint8Array();\n    message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();\n    message.consensusHash = object.consensusHash ?? new Uint8Array();\n    message.appHash = object.appHash ?? new Uint8Array();\n    message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();\n    message.evidenceHash = object.evidenceHash ?? new Uint8Array();\n    message.proposerAddress = object.proposerAddress ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseData(): Data {\n  return { txs: [] };\n}\n\nexport const Data = {\n  encode(message: Data, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.txs) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.txs.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Data {\n    return {\n      txs: Array.isArray(object?.txs)\n        ? object.txs.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Data): unknown {\n    const obj: any = {};\n    if (message.txs) {\n      obj.txs = message.txs.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.txs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Data>, I>>(object: I): Data {\n    const message = createBaseData();\n    message.txs = object.txs?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseVote(): Vote {\n  return {\n    type: 0,\n    height: Long.ZERO,\n    round: 0,\n    blockId: undefined,\n    timestamp: undefined,\n    validatorAddress: new Uint8Array(),\n    validatorIndex: 0,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const Vote = {\n  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(42).fork()\n      ).ldelim();\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(50).bytes(message.validatorAddress);\n    }\n    if (message.validatorIndex !== 0) {\n      writer.uint32(56).int32(message.validatorIndex);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(66).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseVote();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32() as any;\n          break;\n        case 2:\n          message.height = reader.int64() as Long;\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 6:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 7:\n          message.validatorIndex = reader.int32();\n          break;\n        case 8:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Vote {\n    return {\n      type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      validatorAddress: isSet(object.validatorAddress)\n        ? bytesFromBase64(object.validatorAddress)\n        : new Uint8Array(),\n      validatorIndex: isSet(object.validatorIndex)\n        ? Number(object.validatorIndex)\n        : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Vote): unknown {\n    const obj: any = {};\n    message.type !== undefined &&\n      (obj.type = signedMsgTypeToJSON(message.type));\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = base64FromBytes(\n        message.validatorAddress !== undefined\n          ? message.validatorAddress\n          : new Uint8Array()\n      ));\n    message.validatorIndex !== undefined &&\n      (obj.validatorIndex = Math.round(message.validatorIndex));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {\n    const message = createBaseVote();\n    message.type = object.type ?? 0;\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.timestamp = object.timestamp ?? undefined;\n    message.validatorAddress = object.validatorAddress ?? new Uint8Array();\n    message.validatorIndex = object.validatorIndex ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseCommit(): Commit {\n  return { height: Long.ZERO, round: 0, blockId: undefined, signatures: [] };\n}\n\nexport const Commit = {\n  encode(\n    message: Commit,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(16).int32(message.round);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      CommitSig.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Commit {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommit();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64() as Long;\n          break;\n        case 2:\n          message.round = reader.int32();\n          break;\n        case 3:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signatures.push(CommitSig.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Commit {\n    return {\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => CommitSig.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Commit): unknown {\n    const obj: any = {};\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? CommitSig.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Commit>, I>>(object: I): Commit {\n    const message = createBaseCommit();\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => CommitSig.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCommitSig(): CommitSig {\n  return {\n    blockIdFlag: 0,\n    validatorAddress: new Uint8Array(),\n    timestamp: undefined,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const CommitSig = {\n  encode(\n    message: CommitSig,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.blockIdFlag !== 0) {\n      writer.uint32(8).int32(message.blockIdFlag);\n    }\n    if (message.validatorAddress.length !== 0) {\n      writer.uint32(18).bytes(message.validatorAddress);\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(26).fork()\n      ).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(34).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CommitSig {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommitSig();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockIdFlag = reader.int32() as any;\n          break;\n        case 2:\n          message.validatorAddress = reader.bytes();\n          break;\n        case 3:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 4:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CommitSig {\n    return {\n      blockIdFlag: isSet(object.blockIdFlag)\n        ? blockIDFlagFromJSON(object.blockIdFlag)\n        : 0,\n      validatorAddress: isSet(object.validatorAddress)\n        ? bytesFromBase64(object.validatorAddress)\n        : new Uint8Array(),\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CommitSig): unknown {\n    const obj: any = {};\n    message.blockIdFlag !== undefined &&\n      (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = base64FromBytes(\n        message.validatorAddress !== undefined\n          ? message.validatorAddress\n          : new Uint8Array()\n      ));\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CommitSig>, I>>(\n    object: I\n  ): CommitSig {\n    const message = createBaseCommitSig();\n    message.blockIdFlag = object.blockIdFlag ?? 0;\n    message.validatorAddress = object.validatorAddress ?? new Uint8Array();\n    message.timestamp = object.timestamp ?? undefined;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseProposal(): Proposal {\n  return {\n    type: 0,\n    height: Long.ZERO,\n    round: 0,\n    polRound: 0,\n    blockId: undefined,\n    timestamp: undefined,\n    signature: new Uint8Array(),\n  };\n}\n\nexport const Proposal = {\n  encode(\n    message: Proposal,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(16).int64(message.height);\n    }\n    if (message.round !== 0) {\n      writer.uint32(24).int32(message.round);\n    }\n    if (message.polRound !== 0) {\n      writer.uint32(32).int32(message.polRound);\n    }\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.timestamp !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.timestamp),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(58).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseProposal();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32() as any;\n          break;\n        case 2:\n          message.height = reader.int64() as Long;\n          break;\n        case 3:\n          message.round = reader.int32();\n          break;\n        case 4:\n          message.polRound = reader.int32();\n          break;\n        case 5:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.timestamp = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 7:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Proposal {\n    return {\n      type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,\n      round: isSet(object.round) ? Number(object.round) : 0,\n      polRound: isSet(object.polRound) ? Number(object.polRound) : 0,\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      timestamp: isSet(object.timestamp)\n        ? fromJsonTimestamp(object.timestamp)\n        : undefined,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Proposal): unknown {\n    const obj: any = {};\n    message.type !== undefined &&\n      (obj.type = signedMsgTypeToJSON(message.type));\n    message.height !== undefined &&\n      (obj.height = (message.height || Long.ZERO).toString());\n    message.round !== undefined && (obj.round = Math.round(message.round));\n    message.polRound !== undefined &&\n      (obj.polRound = Math.round(message.polRound));\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.timestamp !== undefined &&\n      (obj.timestamp = message.timestamp.toISOString());\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {\n    const message = createBaseProposal();\n    message.type = object.type ?? 0;\n    message.height =\n      object.height !== undefined && object.height !== null\n        ? Long.fromValue(object.height)\n        : Long.ZERO;\n    message.round = object.round ?? 0;\n    message.polRound = object.polRound ?? 0;\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.timestamp = object.timestamp ?? undefined;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignedHeader(): SignedHeader {\n  return { header: undefined, commit: undefined };\n}\n\nexport const SignedHeader = {\n  encode(\n    message: SignedHeader,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignedHeader {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignedHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commit = Commit.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignedHeader {\n    return {\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      commit: isSet(object.commit) ? Commit.fromJSON(object.commit) : undefined,\n    };\n  },\n\n  toJSON(message: SignedHeader): unknown {\n    const obj: any = {};\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    message.commit !== undefined &&\n      (obj.commit = message.commit ? Commit.toJSON(message.commit) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignedHeader>, I>>(\n    object: I\n  ): SignedHeader {\n    const message = createBaseSignedHeader();\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.commit =\n      object.commit !== undefined && object.commit !== null\n        ? Commit.fromPartial(object.commit)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseLightBlock(): LightBlock {\n  return { signedHeader: undefined, validatorSet: undefined };\n}\n\nexport const LightBlock = {\n  encode(\n    message: LightBlock,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.signedHeader !== undefined) {\n      SignedHeader.encode(\n        message.signedHeader,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.validatorSet !== undefined) {\n      ValidatorSet.encode(\n        message.validatorSet,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): LightBlock {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseLightBlock();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signedHeader = SignedHeader.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorSet = ValidatorSet.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): LightBlock {\n    return {\n      signedHeader: isSet(object.signedHeader)\n        ? SignedHeader.fromJSON(object.signedHeader)\n        : undefined,\n      validatorSet: isSet(object.validatorSet)\n        ? ValidatorSet.fromJSON(object.validatorSet)\n        : undefined,\n    };\n  },\n\n  toJSON(message: LightBlock): unknown {\n    const obj: any = {};\n    message.signedHeader !== undefined &&\n      (obj.signedHeader = message.signedHeader\n        ? SignedHeader.toJSON(message.signedHeader)\n        : undefined);\n    message.validatorSet !== undefined &&\n      (obj.validatorSet = message.validatorSet\n        ? ValidatorSet.toJSON(message.validatorSet)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<LightBlock>, I>>(\n    object: I\n  ): LightBlock {\n    const message = createBaseLightBlock();\n    message.signedHeader =\n      object.signedHeader !== undefined && object.signedHeader !== null\n        ? SignedHeader.fromPartial(object.signedHeader)\n        : undefined;\n    message.validatorSet =\n      object.validatorSet !== undefined && object.validatorSet !== null\n        ? ValidatorSet.fromPartial(object.validatorSet)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseBlockMeta(): BlockMeta {\n  return {\n    blockId: undefined,\n    blockSize: Long.ZERO,\n    header: undefined,\n    numTxs: Long.ZERO,\n  };\n}\n\nexport const BlockMeta = {\n  encode(\n    message: BlockMeta,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.blockId !== undefined) {\n      BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.blockSize.isZero()) {\n      writer.uint32(16).int64(message.blockSize);\n    }\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.numTxs.isZero()) {\n      writer.uint32(32).int64(message.numTxs);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): BlockMeta {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBlockMeta();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.blockId = BlockID.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.blockSize = reader.int64() as Long;\n          break;\n        case 3:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.numTxs = reader.int64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): BlockMeta {\n    return {\n      blockId: isSet(object.blockId)\n        ? BlockID.fromJSON(object.blockId)\n        : undefined,\n      blockSize: isSet(object.blockSize)\n        ? Long.fromValue(object.blockSize)\n        : Long.ZERO,\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      numTxs: isSet(object.numTxs) ? Long.fromValue(object.numTxs) : Long.ZERO,\n    };\n  },\n\n  toJSON(message: BlockMeta): unknown {\n    const obj: any = {};\n    message.blockId !== undefined &&\n      (obj.blockId = message.blockId\n        ? BlockID.toJSON(message.blockId)\n        : undefined);\n    message.blockSize !== undefined &&\n      (obj.blockSize = (message.blockSize || Long.ZERO).toString());\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    message.numTxs !== undefined &&\n      (obj.numTxs = (message.numTxs || Long.ZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<BlockMeta>, I>>(\n    object: I\n  ): BlockMeta {\n    const message = createBaseBlockMeta();\n    message.blockId =\n      object.blockId !== undefined && object.blockId !== null\n        ? BlockID.fromPartial(object.blockId)\n        : undefined;\n    message.blockSize =\n      object.blockSize !== undefined && object.blockSize !== null\n        ? Long.fromValue(object.blockSize)\n        : Long.ZERO;\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.numTxs =\n      object.numTxs !== undefined && object.numTxs !== null\n        ? Long.fromValue(object.numTxs)\n        : Long.ZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxProof(): TxProof {\n  return {\n    rootHash: new Uint8Array(),\n    data: new Uint8Array(),\n    proof: undefined,\n  };\n}\n\nexport const TxProof = {\n  encode(\n    message: TxProof,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.rootHash.length !== 0) {\n      writer.uint32(10).bytes(message.rootHash);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.proof !== undefined) {\n      Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxProof {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxProof();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rootHash = reader.bytes();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.proof = Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxProof {\n    return {\n      rootHash: isSet(object.rootHash)\n        ? bytesFromBase64(object.rootHash)\n        : new Uint8Array(),\n      data: isSet(object.data)\n        ? bytesFromBase64(object.data)\n        : new Uint8Array(),\n      proof: isSet(object.proof) ? Proof.fromJSON(object.proof) : undefined,\n    };\n  },\n\n  toJSON(message: TxProof): unknown {\n    const obj: any = {};\n    message.rootHash !== undefined &&\n      (obj.rootHash = base64FromBytes(\n        message.rootHash !== undefined ? message.rootHash : new Uint8Array()\n      ));\n    message.data !== undefined &&\n      (obj.data = base64FromBytes(\n        message.data !== undefined ? message.data : new Uint8Array()\n      ));\n    message.proof !== undefined &&\n      (obj.proof = message.proof ? Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxProof>, I>>(object: I): TxProof {\n    const message = createBaseTxProof();\n    message.rootHash = object.rootHash ?? new Uint8Array();\n    message.data = object.data ?? new Uint8Array();\n    message.proof =\n      object.proof !== undefined && object.proof !== null\n        ? Proof.fromPartial(object.proof)\n        : undefined;\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Header } from \"../../../tendermint/types/types\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Duration } from \"../../../google/protobuf/duration\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.staking.v1beta1\";\n\n/** BondStatus is the status of a validator. */\nexport enum BondStatus {\n  /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */\n  BOND_STATUS_UNSPECIFIED = 0,\n  /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */\n  BOND_STATUS_UNBONDED = 1,\n  /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */\n  BOND_STATUS_UNBONDING = 2,\n  /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */\n  BOND_STATUS_BONDED = 3,\n  UNRECOGNIZED = -1,\n}\n\nexport function bondStatusFromJSON(object: any): BondStatus {\n  switch (object) {\n    case 0:\n    case \"BOND_STATUS_UNSPECIFIED\":\n      return BondStatus.BOND_STATUS_UNSPECIFIED;\n    case 1:\n    case \"BOND_STATUS_UNBONDED\":\n      return BondStatus.BOND_STATUS_UNBONDED;\n    case 2:\n    case \"BOND_STATUS_UNBONDING\":\n      return BondStatus.BOND_STATUS_UNBONDING;\n    case 3:\n    case \"BOND_STATUS_BONDED\":\n      return BondStatus.BOND_STATUS_BONDED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BondStatus.UNRECOGNIZED;\n  }\n}\n\nexport function bondStatusToJSON(object: BondStatus): string {\n  switch (object) {\n    case BondStatus.BOND_STATUS_UNSPECIFIED:\n      return \"BOND_STATUS_UNSPECIFIED\";\n    case BondStatus.BOND_STATUS_UNBONDED:\n      return \"BOND_STATUS_UNBONDED\";\n    case BondStatus.BOND_STATUS_UNBONDING:\n      return \"BOND_STATUS_UNBONDING\";\n    case BondStatus.BOND_STATUS_BONDED:\n      return \"BOND_STATUS_BONDED\";\n    case BondStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/**\n * HistoricalInfo contains header and validator information for a given block.\n * It is stored as part of staking module's state, which persists the `n` most\n * recent HistoricalInfo\n * (`n` is set by the staking module's `historical_entries` parameter).\n */\nexport interface HistoricalInfo {\n  header?: Header;\n  valset: Validator[];\n}\n\n/**\n * CommissionRates defines the initial commission rates to be used for creating\n * a validator.\n */\nexport interface CommissionRates {\n  /** rate is the commission rate charged to delegators, as a fraction. */\n  rate: string;\n  /**\n   * max_rate defines the maximum commission rate which validator can ever\n   * charge, as a fraction.\n   */\n  maxRate: string;\n  /**\n   * max_change_rate defines the maximum daily increase of the validator\n   * commission, as a fraction.\n   */\n  maxChangeRate: string;\n}\n\n/** Commission defines commission parameters for a given validator. */\nexport interface Commission {\n  /**\n   * commission_rates defines the initial commission rates to be used for\n   * creating a validator.\n   */\n  commissionRates?: CommissionRates;\n  /** update_time is the last time the commission rate was changed. */\n  updateTime?: Date;\n}\n\n/** Description defines a validator description. */\nexport interface Description {\n  /** moniker defines a human-readable name for the validator. */\n  moniker: string;\n  /** identity defines an optional identity signature (ex. UPort or Keybase). */\n  identity: string;\n  /** website defines an optional website link. */\n  website: string;\n  /** security_contact defines an optional email for security contact. */\n  securityContact: string;\n  /** details define other optional details. */\n  details: string;\n}\n\n/**\n * Validator defines a validator, together with the total amount of the\n * Validator's bond shares and their exchange rate to coins. Slashing results in\n * a decrease in the exchange rate, allowing correct calculation of future\n * undelegations without iterating over delegators. When coins are delegated to\n * this validator, the validator is credited with a delegation whose number of\n * bond shares is based on the amount of coins delegated divided by the current\n * exchange rate. Voting power can be calculated as total bonded shares\n * multiplied by exchange rate.\n */\nexport interface Validator {\n  /**\n   * operator_address defines the address of the validator's operator; bech\n   * encoded in JSON.\n   */\n  operatorAddress: string;\n  /**\n   * consensus_pubkey is the consensus public key of the validator, as a\n   * Protobuf Any.\n   */\n  consensusPubkey?: Any;\n  /**\n   * jailed defined whether the validator has been jailed from bonded status or\n   * not.\n   */\n  jailed: boolean;\n  /** status is the validator status (bonded/unbonding/unbonded). */\n  status: BondStatus;\n  /** tokens define the delegated tokens (incl. self-delegation). */\n  tokens: string;\n  /** delegator_shares defines total shares issued to a validator's delegators. */\n  delegatorShares: string;\n  /** description defines the description terms for the validator. */\n  description?: Description;\n  /**\n   * unbonding_height defines, if unbonding, the height at which this validator\n   * has begun unbonding.\n   */\n  unbondingHeight: Long;\n  /**\n   * unbonding_time defines, if unbonding, the min time for the validator to\n   * complete unbonding.\n   */\n  unbondingTime?: Date;\n  /** commission defines the commission parameters. */\n  commission?: Commission;\n  /**\n   * min_self_delegation is the validator's self declared minimum self\n   * delegation.\n   */\n  minSelfDelegation: string;\n}\n\n/** ValAddresses defines a repeated set of validator addresses. */\nexport interface ValAddresses {\n  addresses: string[];\n}\n\n/**\n * DVPair is struct that just has a delegator-validator pair with no other data.\n * It is intended to be used as a marshalable pointer. For example, a DVPair can\n * be used to construct the key to getting an UnbondingDelegation from state.\n */\nexport interface DVPair {\n  delegatorAddress: string;\n  validatorAddress: string;\n}\n\n/** DVPairs defines an array of DVPair objects. */\nexport interface DVPairs {\n  pairs: DVPair[];\n}\n\n/**\n * DVVTriplet is struct that just has a delegator-validator-validator triplet\n * with no other data. It is intended to be used as a marshalable pointer. For\n * example, a DVVTriplet can be used to construct the key to getting a\n * Redelegation from state.\n */\nexport interface DVVTriplet {\n  delegatorAddress: string;\n  validatorSrcAddress: string;\n  validatorDstAddress: string;\n}\n\n/** DVVTriplets defines an array of DVVTriplet objects. */\nexport interface DVVTriplets {\n  triplets: DVVTriplet[];\n}\n\n/**\n * Delegation represents the bond with tokens held by an account. It is\n * owned by one delegator, and is associated with the voting power of one\n * validator.\n */\nexport interface Delegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_address is the bech32-encoded address of the validator. */\n  validatorAddress: string;\n  /** shares define the delegation shares received. */\n  shares: string;\n}\n\n/**\n * UnbondingDelegation stores all of a single delegator's unbonding bonds\n * for a single validator in an time-ordered list.\n */\nexport interface UnbondingDelegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /** validator_address is the bech32-encoded address of the validator. */\n  validatorAddress: string;\n  /** entries are the unbonding delegation entries. */\n  entries: UnbondingDelegationEntry[];\n}\n\n/** UnbondingDelegationEntry defines an unbonding object with relevant metadata. */\nexport interface UnbondingDelegationEntry {\n  /** creation_height is the height which the unbonding took place. */\n  creationHeight: Long;\n  /** completion_time is the unix time for unbonding completion. */\n  completionTime?: Date;\n  /**\n   * initial_balance defines the tokens initially scheduled to receive at\n   * completion.\n   */\n  initialBalance: string;\n  /** balance defines the tokens to receive at completion. */\n  balance: string;\n}\n\n/** RedelegationEntry defines a redelegation object with relevant metadata. */\nexport interface RedelegationEntry {\n  /** creation_height  defines the height which the redelegation took place. */\n  creationHeight: Long;\n  /** completion_time defines the unix time for redelegation completion. */\n  completionTime?: Date;\n  /** initial_balance defines the initial balance when redelegation started. */\n  initialBalance: string;\n  /**\n   * shares_dst is the amount of destination-validator shares created by\n   * redelegation.\n   */\n  sharesDst: string;\n}\n\n/**\n * Redelegation contains the list of a particular delegator's redelegating bonds\n * from a particular source validator to a particular destination validator.\n */\nexport interface Redelegation {\n  /** delegator_address is the bech32-encoded address of the delegator. */\n  delegatorAddress: string;\n  /**\n   * validator_src_address is the validator redelegation source operator\n   * address.\n   */\n  validatorSrcAddress: string;\n  /**\n   * validator_dst_address is the validator redelegation destination operator\n   * address.\n   */\n  validatorDstAddress: string;\n  /** entries are the redelegation entries. */\n  entries: RedelegationEntry[];\n}\n\n/** Params defines the parameters for the staking module. */\nexport interface Params {\n  /** unbonding_time is the time duration of unbonding. */\n  unbondingTime?: Duration;\n  /** max_validators is the maximum number of validators. */\n  maxValidators: number;\n  /**\n   * max_entries is the max entries for either unbonding delegation or\n   * redelegation (per pair/trio).\n   */\n  maxEntries: number;\n  /** historical_entries is the number of historical entries to persist. */\n  historicalEntries: number;\n  /** bond_denom defines the bondable coin denomination. */\n  bondDenom: string;\n}\n\n/**\n * DelegationResponse is equivalent to Delegation except that it contains a\n * balance in addition to shares which is more suitable for client responses.\n */\nexport interface DelegationResponse {\n  delegation?: Delegation;\n  balance?: Coin;\n}\n\n/**\n * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\n * contains a balance in addition to shares which is more suitable for client\n * responses.\n */\nexport interface RedelegationEntryResponse {\n  redelegationEntry?: RedelegationEntry;\n  balance: string;\n}\n\n/**\n * RedelegationResponse is equivalent to a Redelegation except that its entries\n * contain a balance in addition to shares which is more suitable for client\n * responses.\n */\nexport interface RedelegationResponse {\n  redelegation?: Redelegation;\n  entries: RedelegationEntryResponse[];\n}\n\n/**\n * Pool is used for tracking bonded and not-bonded token supply of the bond\n * denomination.\n */\nexport interface Pool {\n  notBondedTokens: string;\n  bondedTokens: string;\n}\n\nfunction createBaseHistoricalInfo(): HistoricalInfo {\n  return { header: undefined, valset: [] };\n}\n\nexport const HistoricalInfo = {\n  encode(\n    message: HistoricalInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.header !== undefined) {\n      Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.valset) {\n      Validator.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): HistoricalInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHistoricalInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.valset.push(Validator.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): HistoricalInfo {\n    return {\n      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,\n      valset: Array.isArray(object?.valset)\n        ? object.valset.map((e: any) => Validator.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: HistoricalInfo): unknown {\n    const obj: any = {};\n    message.header !== undefined &&\n      (obj.header = message.header ? Header.toJSON(message.header) : undefined);\n    if (message.valset) {\n      obj.valset = message.valset.map((e) =>\n        e ? Validator.toJSON(e) : undefined\n      );\n    } else {\n      obj.valset = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<HistoricalInfo>, I>>(\n    object: I\n  ): HistoricalInfo {\n    const message = createBaseHistoricalInfo();\n    message.header =\n      object.header !== undefined && object.header !== null\n        ? Header.fromPartial(object.header)\n        : undefined;\n    message.valset = object.valset?.map((e) => Validator.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCommissionRates(): CommissionRates {\n  return { rate: \"\", maxRate: \"\", maxChangeRate: \"\" };\n}\n\nexport const CommissionRates = {\n  encode(\n    message: CommissionRates,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.rate !== \"\") {\n      writer.uint32(10).string(message.rate);\n    }\n    if (message.maxRate !== \"\") {\n      writer.uint32(18).string(message.maxRate);\n    }\n    if (message.maxChangeRate !== \"\") {\n      writer.uint32(26).string(message.maxChangeRate);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CommissionRates {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommissionRates();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rate = reader.string();\n          break;\n        case 2:\n          message.maxRate = reader.string();\n          break;\n        case 3:\n          message.maxChangeRate = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CommissionRates {\n    return {\n      rate: isSet(object.rate) ? String(object.rate) : \"\",\n      maxRate: isSet(object.maxRate) ? String(object.maxRate) : \"\",\n      maxChangeRate: isSet(object.maxChangeRate)\n        ? String(object.maxChangeRate)\n        : \"\",\n    };\n  },\n\n  toJSON(message: CommissionRates): unknown {\n    const obj: any = {};\n    message.rate !== undefined && (obj.rate = message.rate);\n    message.maxRate !== undefined && (obj.maxRate = message.maxRate);\n    message.maxChangeRate !== undefined &&\n      (obj.maxChangeRate = message.maxChangeRate);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CommissionRates>, I>>(\n    object: I\n  ): CommissionRates {\n    const message = createBaseCommissionRates();\n    message.rate = object.rate ?? \"\";\n    message.maxRate = object.maxRate ?? \"\";\n    message.maxChangeRate = object.maxChangeRate ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseCommission(): Commission {\n  return { commissionRates: undefined, updateTime: undefined };\n}\n\nexport const Commission = {\n  encode(\n    message: Commission,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.commissionRates !== undefined) {\n      CommissionRates.encode(\n        message.commissionRates,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.updateTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.updateTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Commission {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCommission();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.commissionRates = CommissionRates.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.updateTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Commission {\n    return {\n      commissionRates: isSet(object.commissionRates)\n        ? CommissionRates.fromJSON(object.commissionRates)\n        : undefined,\n      updateTime: isSet(object.updateTime)\n        ? fromJsonTimestamp(object.updateTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: Commission): unknown {\n    const obj: any = {};\n    message.commissionRates !== undefined &&\n      (obj.commissionRates = message.commissionRates\n        ? CommissionRates.toJSON(message.commissionRates)\n        : undefined);\n    message.updateTime !== undefined &&\n      (obj.updateTime = message.updateTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Commission>, I>>(\n    object: I\n  ): Commission {\n    const message = createBaseCommission();\n    message.commissionRates =\n      object.commissionRates !== undefined && object.commissionRates !== null\n        ? CommissionRates.fromPartial(object.commissionRates)\n        : undefined;\n    message.updateTime = object.updateTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseDescription(): Description {\n  return {\n    moniker: \"\",\n    identity: \"\",\n    website: \"\",\n    securityContact: \"\",\n    details: \"\",\n  };\n}\n\nexport const Description = {\n  encode(\n    message: Description,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.moniker !== \"\") {\n      writer.uint32(10).string(message.moniker);\n    }\n    if (message.identity !== \"\") {\n      writer.uint32(18).string(message.identity);\n    }\n    if (message.website !== \"\") {\n      writer.uint32(26).string(message.website);\n    }\n    if (message.securityContact !== \"\") {\n      writer.uint32(34).string(message.securityContact);\n    }\n    if (message.details !== \"\") {\n      writer.uint32(42).string(message.details);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Description {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDescription();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.moniker = reader.string();\n          break;\n        case 2:\n          message.identity = reader.string();\n          break;\n        case 3:\n          message.website = reader.string();\n          break;\n        case 4:\n          message.securityContact = reader.string();\n          break;\n        case 5:\n          message.details = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Description {\n    return {\n      moniker: isSet(object.moniker) ? String(object.moniker) : \"\",\n      identity: isSet(object.identity) ? String(object.identity) : \"\",\n      website: isSet(object.website) ? String(object.website) : \"\",\n      securityContact: isSet(object.securityContact)\n        ? String(object.securityContact)\n        : \"\",\n      details: isSet(object.details) ? String(object.details) : \"\",\n    };\n  },\n\n  toJSON(message: Description): unknown {\n    const obj: any = {};\n    message.moniker !== undefined && (obj.moniker = message.moniker);\n    message.identity !== undefined && (obj.identity = message.identity);\n    message.website !== undefined && (obj.website = message.website);\n    message.securityContact !== undefined &&\n      (obj.securityContact = message.securityContact);\n    message.details !== undefined && (obj.details = message.details);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Description>, I>>(\n    object: I\n  ): Description {\n    const message = createBaseDescription();\n    message.moniker = object.moniker ?? \"\";\n    message.identity = object.identity ?? \"\";\n    message.website = object.website ?? \"\";\n    message.securityContact = object.securityContact ?? \"\";\n    message.details = object.details ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseValidator(): Validator {\n  return {\n    operatorAddress: \"\",\n    consensusPubkey: undefined,\n    jailed: false,\n    status: 0,\n    tokens: \"\",\n    delegatorShares: \"\",\n    description: undefined,\n    unbondingHeight: Long.ZERO,\n    unbondingTime: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n  };\n}\n\nexport const Validator = {\n  encode(\n    message: Validator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.operatorAddress !== \"\") {\n      writer.uint32(10).string(message.operatorAddress);\n    }\n    if (message.consensusPubkey !== undefined) {\n      Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.jailed === true) {\n      writer.uint32(24).bool(message.jailed);\n    }\n    if (message.status !== 0) {\n      writer.uint32(32).int32(message.status);\n    }\n    if (message.tokens !== \"\") {\n      writer.uint32(42).string(message.tokens);\n    }\n    if (message.delegatorShares !== \"\") {\n      writer.uint32(50).string(message.delegatorShares);\n    }\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    if (!message.unbondingHeight.isZero()) {\n      writer.uint32(64).int64(message.unbondingHeight);\n    }\n    if (message.unbondingTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.unbondingTime),\n        writer.uint32(74).fork()\n      ).ldelim();\n    }\n    if (message.commission !== undefined) {\n      Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(90).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.operatorAddress = reader.string();\n          break;\n        case 2:\n          message.consensusPubkey = Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.jailed = reader.bool();\n          break;\n        case 4:\n          message.status = reader.int32() as any;\n          break;\n        case 5:\n          message.tokens = reader.string();\n          break;\n        case 6:\n          message.delegatorShares = reader.string();\n          break;\n        case 7:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.unbondingHeight = reader.int64() as Long;\n          break;\n        case 9:\n          message.unbondingTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 10:\n          message.commission = Commission.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Validator {\n    return {\n      operatorAddress: isSet(object.operatorAddress)\n        ? String(object.operatorAddress)\n        : \"\",\n      consensusPubkey: isSet(object.consensusPubkey)\n        ? Any.fromJSON(object.consensusPubkey)\n        : undefined,\n      jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,\n      status: isSet(object.status) ? bondStatusFromJSON(object.status) : 0,\n      tokens: isSet(object.tokens) ? String(object.tokens) : \"\",\n      delegatorShares: isSet(object.delegatorShares)\n        ? String(object.delegatorShares)\n        : \"\",\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      unbondingHeight: isSet(object.unbondingHeight)\n        ? Long.fromValue(object.unbondingHeight)\n        : Long.ZERO,\n      unbondingTime: isSet(object.unbondingTime)\n        ? fromJsonTimestamp(object.unbondingTime)\n        : undefined,\n      commission: isSet(object.commission)\n        ? Commission.fromJSON(object.commission)\n        : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n    };\n  },\n\n  toJSON(message: Validator): unknown {\n    const obj: any = {};\n    message.operatorAddress !== undefined &&\n      (obj.operatorAddress = message.operatorAddress);\n    message.consensusPubkey !== undefined &&\n      (obj.consensusPubkey = message.consensusPubkey\n        ? Any.toJSON(message.consensusPubkey)\n        : undefined);\n    message.jailed !== undefined && (obj.jailed = message.jailed);\n    message.status !== undefined &&\n      (obj.status = bondStatusToJSON(message.status));\n    message.tokens !== undefined && (obj.tokens = message.tokens);\n    message.delegatorShares !== undefined &&\n      (obj.delegatorShares = message.delegatorShares);\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.unbondingHeight !== undefined &&\n      (obj.unbondingHeight = (message.unbondingHeight || Long.ZERO).toString());\n    message.unbondingTime !== undefined &&\n      (obj.unbondingTime = message.unbondingTime.toISOString());\n    message.commission !== undefined &&\n      (obj.commission = message.commission\n        ? Commission.toJSON(message.commission)\n        : undefined);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Validator>, I>>(\n    object: I\n  ): Validator {\n    const message = createBaseValidator();\n    message.operatorAddress = object.operatorAddress ?? \"\";\n    message.consensusPubkey =\n      object.consensusPubkey !== undefined && object.consensusPubkey !== null\n        ? Any.fromPartial(object.consensusPubkey)\n        : undefined;\n    message.jailed = object.jailed ?? false;\n    message.status = object.status ?? 0;\n    message.tokens = object.tokens ?? \"\";\n    message.delegatorShares = object.delegatorShares ?? \"\";\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.unbondingHeight =\n      object.unbondingHeight !== undefined && object.unbondingHeight !== null\n        ? Long.fromValue(object.unbondingHeight)\n        : Long.ZERO;\n    message.unbondingTime = object.unbondingTime ?? undefined;\n    message.commission =\n      object.commission !== undefined && object.commission !== null\n        ? Commission.fromPartial(object.commission)\n        : undefined;\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseValAddresses(): ValAddresses {\n  return { addresses: [] };\n}\n\nexport const ValAddresses = {\n  encode(\n    message: ValAddresses,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.addresses) {\n      writer.uint32(10).string(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ValAddresses {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValAddresses();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.addresses.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ValAddresses {\n    return {\n      addresses: Array.isArray(object?.addresses)\n        ? object.addresses.map((e: any) => String(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ValAddresses): unknown {\n    const obj: any = {};\n    if (message.addresses) {\n      obj.addresses = message.addresses.map((e) => e);\n    } else {\n      obj.addresses = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ValAddresses>, I>>(\n    object: I\n  ): ValAddresses {\n    const message = createBaseValAddresses();\n    message.addresses = object.addresses?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseDVPair(): DVPair {\n  return { delegatorAddress: \"\", validatorAddress: \"\" };\n}\n\nexport const DVPair = {\n  encode(\n    message: DVPair,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVPair {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVPair();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVPair {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: DVPair): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVPair>, I>>(object: I): DVPair {\n    const message = createBaseDVPair();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDVPairs(): DVPairs {\n  return { pairs: [] };\n}\n\nexport const DVPairs = {\n  encode(\n    message: DVPairs,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.pairs) {\n      DVPair.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVPairs {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVPairs();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pairs.push(DVPair.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVPairs {\n    return {\n      pairs: Array.isArray(object?.pairs)\n        ? object.pairs.map((e: any) => DVPair.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DVPairs): unknown {\n    const obj: any = {};\n    if (message.pairs) {\n      obj.pairs = message.pairs.map((e) => (e ? DVPair.toJSON(e) : undefined));\n    } else {\n      obj.pairs = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVPairs>, I>>(object: I): DVPairs {\n    const message = createBaseDVPairs();\n    message.pairs = object.pairs?.map((e) => DVPair.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDVVTriplet(): DVVTriplet {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n  };\n}\n\nexport const DVVTriplet = {\n  encode(\n    message: DVVTriplet,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVVTriplet {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVVTriplet();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVVTriplet {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n    };\n  },\n\n  toJSON(message: DVVTriplet): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVVTriplet>, I>>(\n    object: I\n  ): DVVTriplet {\n    const message = createBaseDVVTriplet();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDVVTriplets(): DVVTriplets {\n  return { triplets: [] };\n}\n\nexport const DVVTriplets = {\n  encode(\n    message: DVVTriplets,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.triplets) {\n      DVVTriplet.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DVVTriplets {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDVVTriplets();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.triplets.push(DVVTriplet.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DVVTriplets {\n    return {\n      triplets: Array.isArray(object?.triplets)\n        ? object.triplets.map((e: any) => DVVTriplet.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: DVVTriplets): unknown {\n    const obj: any = {};\n    if (message.triplets) {\n      obj.triplets = message.triplets.map((e) =>\n        e ? DVVTriplet.toJSON(e) : undefined\n      );\n    } else {\n      obj.triplets = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DVVTriplets>, I>>(\n    object: I\n  ): DVVTriplets {\n    const message = createBaseDVVTriplets();\n    message.triplets =\n      object.triplets?.map((e) => DVVTriplet.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseDelegation(): Delegation {\n  return { delegatorAddress: \"\", validatorAddress: \"\", shares: \"\" };\n}\n\nexport const Delegation = {\n  encode(\n    message: Delegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.shares !== \"\") {\n      writer.uint32(26).string(message.shares);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Delegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.shares = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Delegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      shares: isSet(object.shares) ? String(object.shares) : \"\",\n    };\n  },\n\n  toJSON(message: Delegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.shares !== undefined && (obj.shares = message.shares);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Delegation>, I>>(\n    object: I\n  ): Delegation {\n    const message = createBaseDelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.shares = object.shares ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseUnbondingDelegation(): UnbondingDelegation {\n  return { delegatorAddress: \"\", validatorAddress: \"\", entries: [] };\n}\n\nexport const UnbondingDelegation = {\n  encode(\n    message: UnbondingDelegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    for (const v of message.entries) {\n      UnbondingDelegationEntry.encode(v!, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): UnbondingDelegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUnbondingDelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.entries.push(\n            UnbondingDelegationEntry.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UnbondingDelegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => UnbondingDelegationEntry.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: UnbondingDelegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? UnbondingDelegationEntry.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<UnbondingDelegation>, I>>(\n    object: I\n  ): UnbondingDelegation {\n    const message = createBaseUnbondingDelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.entries =\n      object.entries?.map((e) => UnbondingDelegationEntry.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseUnbondingDelegationEntry(): UnbondingDelegationEntry {\n  return {\n    creationHeight: Long.ZERO,\n    completionTime: undefined,\n    initialBalance: \"\",\n    balance: \"\",\n  };\n}\n\nexport const UnbondingDelegationEntry = {\n  encode(\n    message: UnbondingDelegationEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): UnbondingDelegationEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUnbondingDelegationEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64() as Long;\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UnbondingDelegationEntry {\n    return {\n      creationHeight: isSet(object.creationHeight)\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO,\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n      initialBalance: isSet(object.initialBalance)\n        ? String(object.initialBalance)\n        : \"\",\n      balance: isSet(object.balance) ? String(object.balance) : \"\",\n    };\n  },\n\n  toJSON(message: UnbondingDelegationEntry): unknown {\n    const obj: any = {};\n    message.creationHeight !== undefined &&\n      (obj.creationHeight = (message.creationHeight || Long.ZERO).toString());\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined &&\n      (obj.initialBalance = message.initialBalance);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<UnbondingDelegationEntry>, I>>(\n    object: I\n  ): UnbondingDelegationEntry {\n    const message = createBaseUnbondingDelegationEntry();\n    message.creationHeight =\n      object.creationHeight !== undefined && object.creationHeight !== null\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO;\n    message.completionTime = object.completionTime ?? undefined;\n    message.initialBalance = object.initialBalance ?? \"\";\n    message.balance = object.balance ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegationEntry(): RedelegationEntry {\n  return {\n    creationHeight: Long.ZERO,\n    completionTime: undefined,\n    initialBalance: \"\",\n    sharesDst: \"\",\n  };\n}\n\nexport const RedelegationEntry = {\n  encode(\n    message: RedelegationEntry,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.sharesDst !== \"\") {\n      writer.uint32(34).string(message.sharesDst);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): RedelegationEntry {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64() as Long;\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.sharesDst = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationEntry {\n    return {\n      creationHeight: isSet(object.creationHeight)\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO,\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n      initialBalance: isSet(object.initialBalance)\n        ? String(object.initialBalance)\n        : \"\",\n      sharesDst: isSet(object.sharesDst) ? String(object.sharesDst) : \"\",\n    };\n  },\n\n  toJSON(message: RedelegationEntry): unknown {\n    const obj: any = {};\n    message.creationHeight !== undefined &&\n      (obj.creationHeight = (message.creationHeight || Long.ZERO).toString());\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined &&\n      (obj.initialBalance = message.initialBalance);\n    message.sharesDst !== undefined && (obj.sharesDst = message.sharesDst);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationEntry>, I>>(\n    object: I\n  ): RedelegationEntry {\n    const message = createBaseRedelegationEntry();\n    message.creationHeight =\n      object.creationHeight !== undefined && object.creationHeight !== null\n        ? Long.fromValue(object.creationHeight)\n        : Long.ZERO;\n    message.completionTime = object.completionTime ?? undefined;\n    message.initialBalance = object.initialBalance ?? \"\";\n    message.sharesDst = object.sharesDst ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegation(): Redelegation {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    entries: [],\n  };\n}\n\nexport const Redelegation = {\n  encode(\n    message: Redelegation,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    for (const v of message.entries) {\n      RedelegationEntry.encode(v!, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Redelegation {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.entries.push(\n            RedelegationEntry.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Redelegation {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => RedelegationEntry.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Redelegation): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? RedelegationEntry.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Redelegation>, I>>(\n    object: I\n  ): Redelegation {\n    const message = createBaseRedelegation();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    message.entries =\n      object.entries?.map((e) => RedelegationEntry.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseParams(): Params {\n  return {\n    unbondingTime: undefined,\n    maxValidators: 0,\n    maxEntries: 0,\n    historicalEntries: 0,\n    bondDenom: \"\",\n  };\n}\n\nexport const Params = {\n  encode(\n    message: Params,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.unbondingTime !== undefined) {\n      Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxValidators !== 0) {\n      writer.uint32(16).uint32(message.maxValidators);\n    }\n    if (message.maxEntries !== 0) {\n      writer.uint32(24).uint32(message.maxEntries);\n    }\n    if (message.historicalEntries !== 0) {\n      writer.uint32(32).uint32(message.historicalEntries);\n    }\n    if (message.bondDenom !== \"\") {\n      writer.uint32(42).string(message.bondDenom);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Params {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseParams();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.unbondingTime = Duration.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.maxValidators = reader.uint32();\n          break;\n        case 3:\n          message.maxEntries = reader.uint32();\n          break;\n        case 4:\n          message.historicalEntries = reader.uint32();\n          break;\n        case 5:\n          message.bondDenom = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Params {\n    return {\n      unbondingTime: isSet(object.unbondingTime)\n        ? Duration.fromJSON(object.unbondingTime)\n        : undefined,\n      maxValidators: isSet(object.maxValidators)\n        ? Number(object.maxValidators)\n        : 0,\n      maxEntries: isSet(object.maxEntries) ? Number(object.maxEntries) : 0,\n      historicalEntries: isSet(object.historicalEntries)\n        ? Number(object.historicalEntries)\n        : 0,\n      bondDenom: isSet(object.bondDenom) ? String(object.bondDenom) : \"\",\n    };\n  },\n\n  toJSON(message: Params): unknown {\n    const obj: any = {};\n    message.unbondingTime !== undefined &&\n      (obj.unbondingTime = message.unbondingTime\n        ? Duration.toJSON(message.unbondingTime)\n        : undefined);\n    message.maxValidators !== undefined &&\n      (obj.maxValidators = Math.round(message.maxValidators));\n    message.maxEntries !== undefined &&\n      (obj.maxEntries = Math.round(message.maxEntries));\n    message.historicalEntries !== undefined &&\n      (obj.historicalEntries = Math.round(message.historicalEntries));\n    message.bondDenom !== undefined && (obj.bondDenom = message.bondDenom);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {\n    const message = createBaseParams();\n    message.unbondingTime =\n      object.unbondingTime !== undefined && object.unbondingTime !== null\n        ? Duration.fromPartial(object.unbondingTime)\n        : undefined;\n    message.maxValidators = object.maxValidators ?? 0;\n    message.maxEntries = object.maxEntries ?? 0;\n    message.historicalEntries = object.historicalEntries ?? 0;\n    message.bondDenom = object.bondDenom ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDelegationResponse(): DelegationResponse {\n  return { delegation: undefined, balance: undefined };\n}\n\nexport const DelegationResponse = {\n  encode(\n    message: DelegationResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegation !== undefined) {\n      Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.balance !== undefined) {\n      Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DelegationResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDelegationResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegation = Delegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.balance = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DelegationResponse {\n    return {\n      delegation: isSet(object.delegation)\n        ? Delegation.fromJSON(object.delegation)\n        : undefined,\n      balance: isSet(object.balance)\n        ? Coin.fromJSON(object.balance)\n        : undefined,\n    };\n  },\n\n  toJSON(message: DelegationResponse): unknown {\n    const obj: any = {};\n    message.delegation !== undefined &&\n      (obj.delegation = message.delegation\n        ? Delegation.toJSON(message.delegation)\n        : undefined);\n    message.balance !== undefined &&\n      (obj.balance = message.balance\n        ? Coin.toJSON(message.balance)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DelegationResponse>, I>>(\n    object: I\n  ): DelegationResponse {\n    const message = createBaseDelegationResponse();\n    message.delegation =\n      object.delegation !== undefined && object.delegation !== null\n        ? Delegation.fromPartial(object.delegation)\n        : undefined;\n    message.balance =\n      object.balance !== undefined && object.balance !== null\n        ? Coin.fromPartial(object.balance)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseRedelegationEntryResponse(): RedelegationEntryResponse {\n  return { redelegationEntry: undefined, balance: \"\" };\n}\n\nexport const RedelegationEntryResponse = {\n  encode(\n    message: RedelegationEntryResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.redelegationEntry !== undefined) {\n      RedelegationEntry.encode(\n        message.redelegationEntry,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RedelegationEntryResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationEntryResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegationEntry = RedelegationEntry.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationEntryResponse {\n    return {\n      redelegationEntry: isSet(object.redelegationEntry)\n        ? RedelegationEntry.fromJSON(object.redelegationEntry)\n        : undefined,\n      balance: isSet(object.balance) ? String(object.balance) : \"\",\n    };\n  },\n\n  toJSON(message: RedelegationEntryResponse): unknown {\n    const obj: any = {};\n    message.redelegationEntry !== undefined &&\n      (obj.redelegationEntry = message.redelegationEntry\n        ? RedelegationEntry.toJSON(message.redelegationEntry)\n        : undefined);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationEntryResponse>, I>>(\n    object: I\n  ): RedelegationEntryResponse {\n    const message = createBaseRedelegationEntryResponse();\n    message.redelegationEntry =\n      object.redelegationEntry !== undefined &&\n      object.redelegationEntry !== null\n        ? RedelegationEntry.fromPartial(object.redelegationEntry)\n        : undefined;\n    message.balance = object.balance ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRedelegationResponse(): RedelegationResponse {\n  return { redelegation: undefined, entries: [] };\n}\n\nexport const RedelegationResponse = {\n  encode(\n    message: RedelegationResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.redelegation !== undefined) {\n      Redelegation.encode(\n        message.redelegation,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.entries) {\n      RedelegationEntryResponse.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): RedelegationResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRedelegationResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegation = Redelegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.entries.push(\n            RedelegationEntryResponse.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): RedelegationResponse {\n    return {\n      redelegation: isSet(object.redelegation)\n        ? Redelegation.fromJSON(object.redelegation)\n        : undefined,\n      entries: Array.isArray(object?.entries)\n        ? object.entries.map((e: any) => RedelegationEntryResponse.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: RedelegationResponse): unknown {\n    const obj: any = {};\n    message.redelegation !== undefined &&\n      (obj.redelegation = message.redelegation\n        ? Redelegation.toJSON(message.redelegation)\n        : undefined);\n    if (message.entries) {\n      obj.entries = message.entries.map((e) =>\n        e ? RedelegationEntryResponse.toJSON(e) : undefined\n      );\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<RedelegationResponse>, I>>(\n    object: I\n  ): RedelegationResponse {\n    const message = createBaseRedelegationResponse();\n    message.redelegation =\n      object.redelegation !== undefined && object.redelegation !== null\n        ? Redelegation.fromPartial(object.redelegation)\n        : undefined;\n    message.entries =\n      object.entries?.map((e) => RedelegationEntryResponse.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\nfunction createBasePool(): Pool {\n  return { notBondedTokens: \"\", bondedTokens: \"\" };\n}\n\nexport const Pool = {\n  encode(message: Pool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.notBondedTokens !== \"\") {\n      writer.uint32(10).string(message.notBondedTokens);\n    }\n    if (message.bondedTokens !== \"\") {\n      writer.uint32(18).string(message.bondedTokens);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Pool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.notBondedTokens = reader.string();\n          break;\n        case 2:\n          message.bondedTokens = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Pool {\n    return {\n      notBondedTokens: isSet(object.notBondedTokens)\n        ? String(object.notBondedTokens)\n        : \"\",\n      bondedTokens: isSet(object.bondedTokens)\n        ? String(object.bondedTokens)\n        : \"\",\n    };\n  },\n\n  toJSON(message: Pool): unknown {\n    const obj: any = {};\n    message.notBondedTokens !== undefined &&\n      (obj.notBondedTokens = message.notBondedTokens);\n    message.bondedTokens !== undefined &&\n      (obj.bondedTokens = message.bondedTokens);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Pool>, I>>(object: I): Pool {\n    const message = createBasePool();\n    message.notBondedTokens = object.notBondedTokens ?? \"\";\n    message.bondedTokens = object.bondedTokens ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Description, CommissionRates } from \"./staking\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport { Coin } from \"../../base/v1beta1/coin\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../../../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"cosmos.staking.v1beta1\";\n\n/** MsgCreateValidator defines a SDK message for creating a new validator. */\nexport interface MsgCreateValidator {\n  description?: Description;\n  commission?: CommissionRates;\n  minSelfDelegation: string;\n  delegatorAddress: string;\n  validatorAddress: string;\n  pubkey?: Any;\n  value?: Coin;\n}\n\n/** MsgCreateValidatorResponse defines the Msg/CreateValidator response type. */\nexport interface MsgCreateValidatorResponse {}\n\n/** MsgEditValidator defines a SDK message for editing an existing validator. */\nexport interface MsgEditValidator {\n  description?: Description;\n  validatorAddress: string;\n  /**\n   * We pass a reference to the new commission rate and min self delegation as\n   * it's not mandatory to update. If not updated, the deserialized rate will be\n   * zero with no way to distinguish if an update was intended.\n   * REF: #2373\n   */\n  commissionRate: string;\n  minSelfDelegation: string;\n}\n\n/** MsgEditValidatorResponse defines the Msg/EditValidator response type. */\nexport interface MsgEditValidatorResponse {}\n\n/**\n * MsgDelegate defines a SDK message for performing a delegation of coins\n * from a delegator to a validator.\n */\nexport interface MsgDelegate {\n  delegatorAddress: string;\n  validatorAddress: string;\n  amount?: Coin;\n}\n\n/** MsgDelegateResponse defines the Msg/Delegate response type. */\nexport interface MsgDelegateResponse {}\n\n/**\n * MsgBeginRedelegate defines a SDK message for performing a redelegation\n * of coins from a delegator and source validator to a destination validator.\n */\nexport interface MsgBeginRedelegate {\n  delegatorAddress: string;\n  validatorSrcAddress: string;\n  validatorDstAddress: string;\n  amount?: Coin;\n}\n\n/** MsgBeginRedelegateResponse defines the Msg/BeginRedelegate response type. */\nexport interface MsgBeginRedelegateResponse {\n  completionTime?: Date;\n}\n\n/**\n * MsgUndelegate defines a SDK message for performing an undelegation from a\n * delegate and a validator.\n */\nexport interface MsgUndelegate {\n  delegatorAddress: string;\n  validatorAddress: string;\n  amount?: Coin;\n}\n\n/** MsgUndelegateResponse defines the Msg/Undelegate response type. */\nexport interface MsgUndelegateResponse {\n  completionTime?: Date;\n}\n\nfunction createBaseMsgCreateValidator(): MsgCreateValidator {\n  return {\n    description: undefined,\n    commission: undefined,\n    minSelfDelegation: \"\",\n    delegatorAddress: \"\",\n    validatorAddress: \"\",\n    pubkey: undefined,\n    value: undefined,\n  };\n}\n\nexport const MsgCreateValidator = {\n  encode(\n    message: MsgCreateValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.commission !== undefined) {\n      CommissionRates.encode(\n        message.commission,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(26).string(message.minSelfDelegation);\n    }\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(34).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(42).string(message.validatorAddress);\n    }\n    if (message.pubkey !== undefined) {\n      Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.value !== undefined) {\n      Coin.encode(message.value, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.commission = CommissionRates.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.minSelfDelegation = reader.string();\n          break;\n        case 4:\n          message.delegatorAddress = reader.string();\n          break;\n        case 5:\n          message.validatorAddress = reader.string();\n          break;\n        case 6:\n          message.pubkey = Any.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.value = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreateValidator {\n    return {\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      commission: isSet(object.commission)\n        ? CommissionRates.fromJSON(object.commission)\n        : undefined,\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      pubkey: isSet(object.pubkey) ? Any.fromJSON(object.pubkey) : undefined,\n      value: isSet(object.value) ? Coin.fromJSON(object.value) : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreateValidator): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.commission !== undefined &&\n      (obj.commission = message.commission\n        ? CommissionRates.toJSON(message.commission)\n        : undefined);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.pubkey !== undefined &&\n      (obj.pubkey = message.pubkey ? Any.toJSON(message.pubkey) : undefined);\n    message.value !== undefined &&\n      (obj.value = message.value ? Coin.toJSON(message.value) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateValidator>, I>>(\n    object: I\n  ): MsgCreateValidator {\n    const message = createBaseMsgCreateValidator();\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.commission =\n      object.commission !== undefined && object.commission !== null\n        ? CommissionRates.fromPartial(object.commission)\n        : undefined;\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.pubkey =\n      object.pubkey !== undefined && object.pubkey !== null\n        ? Any.fromPartial(object.pubkey)\n        : undefined;\n    message.value =\n      object.value !== undefined && object.value !== null\n        ? Coin.fromPartial(object.value)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreateValidatorResponse(): MsgCreateValidatorResponse {\n  return {};\n}\n\nexport const MsgCreateValidatorResponse = {\n  encode(\n    _: MsgCreateValidatorResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreateValidatorResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreateValidatorResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreateValidatorResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreateValidatorResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreateValidatorResponse>, I>>(\n    _: I\n  ): MsgCreateValidatorResponse {\n    const message = createBaseMsgCreateValidatorResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgEditValidator(): MsgEditValidator {\n  return {\n    description: undefined,\n    validatorAddress: \"\",\n    commissionRate: \"\",\n    minSelfDelegation: \"\",\n  };\n}\n\nexport const MsgEditValidator = {\n  encode(\n    message: MsgEditValidator,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.description !== undefined) {\n      Description.encode(\n        message.description,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.commissionRate !== \"\") {\n      writer.uint32(26).string(message.commissionRate);\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(34).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditValidator {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEditValidator();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.description = Description.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.commissionRate = reader.string();\n          break;\n        case 4:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgEditValidator {\n    return {\n      description: isSet(object.description)\n        ? Description.fromJSON(object.description)\n        : undefined,\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      commissionRate: isSet(object.commissionRate)\n        ? String(object.commissionRate)\n        : \"\",\n      minSelfDelegation: isSet(object.minSelfDelegation)\n        ? String(object.minSelfDelegation)\n        : \"\",\n    };\n  },\n\n  toJSON(message: MsgEditValidator): unknown {\n    const obj: any = {};\n    message.description !== undefined &&\n      (obj.description = message.description\n        ? Description.toJSON(message.description)\n        : undefined);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.commissionRate !== undefined &&\n      (obj.commissionRate = message.commissionRate);\n    message.minSelfDelegation !== undefined &&\n      (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEditValidator>, I>>(\n    object: I\n  ): MsgEditValidator {\n    const message = createBaseMsgEditValidator();\n    message.description =\n      object.description !== undefined && object.description !== null\n        ? Description.fromPartial(object.description)\n        : undefined;\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.commissionRate = object.commissionRate ?? \"\";\n    message.minSelfDelegation = object.minSelfDelegation ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgEditValidatorResponse(): MsgEditValidatorResponse {\n  return {};\n}\n\nexport const MsgEditValidatorResponse = {\n  encode(\n    _: MsgEditValidatorResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgEditValidatorResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgEditValidatorResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgEditValidatorResponse {\n    return {};\n  },\n\n  toJSON(_: MsgEditValidatorResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgEditValidatorResponse>, I>>(\n    _: I\n  ): MsgEditValidatorResponse {\n    const message = createBaseMsgEditValidatorResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDelegate(): MsgDelegate {\n  return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\n\nexport const MsgDelegate = {\n  encode(\n    message: MsgDelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgDelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDelegate>, I>>(\n    object: I\n  ): MsgDelegate {\n    const message = createBaseMsgDelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDelegateResponse(): MsgDelegateResponse {\n  return {};\n}\n\nexport const MsgDelegateResponse = {\n  encode(\n    _: MsgDelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDelegateResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDelegateResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDelegateResponse>, I>>(\n    _: I\n  ): MsgDelegateResponse {\n    const message = createBaseMsgDelegateResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgBeginRedelegate(): MsgBeginRedelegate {\n  return {\n    delegatorAddress: \"\",\n    validatorSrcAddress: \"\",\n    validatorDstAddress: \"\",\n    amount: undefined,\n  };\n}\n\nexport const MsgBeginRedelegate = {\n  encode(\n    message: MsgBeginRedelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBeginRedelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBeginRedelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBeginRedelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorSrcAddress: isSet(object.validatorSrcAddress)\n        ? String(object.validatorSrcAddress)\n        : \"\",\n      validatorDstAddress: isSet(object.validatorDstAddress)\n        ? String(object.validatorDstAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgBeginRedelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined &&\n      (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined &&\n      (obj.validatorDstAddress = message.validatorDstAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBeginRedelegate>, I>>(\n    object: I\n  ): MsgBeginRedelegate {\n    const message = createBaseMsgBeginRedelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorSrcAddress = object.validatorSrcAddress ?? \"\";\n    message.validatorDstAddress = object.validatorDstAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgBeginRedelegateResponse(): MsgBeginRedelegateResponse {\n  return { completionTime: undefined };\n}\n\nexport const MsgBeginRedelegateResponse = {\n  encode(\n    message: MsgBeginRedelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgBeginRedelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgBeginRedelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgBeginRedelegateResponse {\n    return {\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgBeginRedelegateResponse): unknown {\n    const obj: any = {};\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgBeginRedelegateResponse>, I>>(\n    object: I\n  ): MsgBeginRedelegateResponse {\n    const message = createBaseMsgBeginRedelegateResponse();\n    message.completionTime = object.completionTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUndelegate(): MsgUndelegate {\n  return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\n\nexport const MsgUndelegate = {\n  encode(\n    message: MsgUndelegate,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.amount !== undefined) {\n      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUndelegate {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUndelegate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.amount = Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUndelegate {\n    return {\n      delegatorAddress: isSet(object.delegatorAddress)\n        ? String(object.delegatorAddress)\n        : \"\",\n      validatorAddress: isSet(object.validatorAddress)\n        ? String(object.validatorAddress)\n        : \"\",\n      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,\n    };\n  },\n\n  toJSON(message: MsgUndelegate): unknown {\n    const obj: any = {};\n    message.delegatorAddress !== undefined &&\n      (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined &&\n      (obj.validatorAddress = message.validatorAddress);\n    message.amount !== undefined &&\n      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUndelegate>, I>>(\n    object: I\n  ): MsgUndelegate {\n    const message = createBaseMsgUndelegate();\n    message.delegatorAddress = object.delegatorAddress ?? \"\";\n    message.validatorAddress = object.validatorAddress ?? \"\";\n    message.amount =\n      object.amount !== undefined && object.amount !== null\n        ? Coin.fromPartial(object.amount)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgUndelegateResponse(): MsgUndelegateResponse {\n  return { completionTime: undefined };\n}\n\nexport const MsgUndelegateResponse = {\n  encode(\n    message: MsgUndelegateResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.completionTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.completionTime),\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgUndelegateResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgUndelegateResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.completionTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgUndelegateResponse {\n    return {\n      completionTime: isSet(object.completionTime)\n        ? fromJsonTimestamp(object.completionTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgUndelegateResponse): unknown {\n    const obj: any = {};\n    message.completionTime !== undefined &&\n      (obj.completionTime = message.completionTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgUndelegateResponse>, I>>(\n    object: I\n  ): MsgUndelegateResponse {\n    const message = createBaseMsgUndelegateResponse();\n    message.completionTime = object.completionTime ?? undefined;\n    return message;\n  },\n};\n\n/** Msg defines the staking Msg service. */\nexport interface Msg {\n  /** CreateValidator defines a method for creating a new validator. */\n  CreateValidator(\n    request: DeepPartial<MsgCreateValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateValidatorResponse>;\n  /** EditValidator defines a method for editing an existing validator. */\n  EditValidator(\n    request: DeepPartial<MsgEditValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEditValidatorResponse>;\n  /**\n   * Delegate defines a method for performing a delegation of coins\n   * from a delegator to a validator.\n   */\n  Delegate(\n    request: DeepPartial<MsgDelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDelegateResponse>;\n  /**\n   * BeginRedelegate defines a method for performing a redelegation\n   * of coins from a delegator and source validator to a destination validator.\n   */\n  BeginRedelegate(\n    request: DeepPartial<MsgBeginRedelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBeginRedelegateResponse>;\n  /**\n   * Undelegate defines a method for performing an undelegation from a\n   * delegate and a validator.\n   */\n  Undelegate(\n    request: DeepPartial<MsgUndelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUndelegateResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreateValidator = this.CreateValidator.bind(this);\n    this.EditValidator = this.EditValidator.bind(this);\n    this.Delegate = this.Delegate.bind(this);\n    this.BeginRedelegate = this.BeginRedelegate.bind(this);\n    this.Undelegate = this.Undelegate.bind(this);\n  }\n\n  CreateValidator(\n    request: DeepPartial<MsgCreateValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreateValidatorResponse> {\n    return this.rpc.unary(\n      MsgCreateValidatorDesc,\n      MsgCreateValidator.fromPartial(request),\n      metadata\n    );\n  }\n\n  EditValidator(\n    request: DeepPartial<MsgEditValidator>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgEditValidatorResponse> {\n    return this.rpc.unary(\n      MsgEditValidatorDesc,\n      MsgEditValidator.fromPartial(request),\n      metadata\n    );\n  }\n\n  Delegate(\n    request: DeepPartial<MsgDelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDelegateResponse> {\n    return this.rpc.unary(\n      MsgDelegateDesc,\n      MsgDelegate.fromPartial(request),\n      metadata\n    );\n  }\n\n  BeginRedelegate(\n    request: DeepPartial<MsgBeginRedelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgBeginRedelegateResponse> {\n    return this.rpc.unary(\n      MsgBeginRedelegateDesc,\n      MsgBeginRedelegate.fromPartial(request),\n      metadata\n    );\n  }\n\n  Undelegate(\n    request: DeepPartial<MsgUndelegate>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgUndelegateResponse> {\n    return this.rpc.unary(\n      MsgUndelegateDesc,\n      MsgUndelegate.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"cosmos.staking.v1beta1.Msg\",\n};\n\nexport const MsgCreateValidatorDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreateValidator\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreateValidator.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreateValidatorResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgEditValidatorDesc: UnaryMethodDefinitionish = {\n  methodName: \"EditValidator\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgEditValidator.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgEditValidatorResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"Delegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgBeginRedelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"BeginRedelegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgBeginRedelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgBeginRedelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgUndelegateDesc: UnaryMethodDefinitionish = {\n  methodName: \"Undelegate\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgUndelegate.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgUndelegateResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { BaseMsg } from './BaseMsg';\nimport {\n  protobufPackage,\n  MsgCreateValidator as MsgCreateValidator_pb,\n  MsgEditValidator as MsgEditValidator_pb,\n  MsgDelegate as MsgDelegate_pb,\n  MsgBeginRedelegate as MsgBeginRedelegate_pb,\n  MsgUndelegate as MsgUndelegate_pb\n} from \"../proto/cosmos/staking/v1beta1/tx\";\nimport {EncodeObject} from \"@cosmjs/proto-signing\";\n\nexport class MsgCreateValidator extends BaseMsg {\n  public static TYPE_URL = `/${protobufPackage}.MsgCreateValidator`;\n  public protoMsg: MsgCreateValidator_pb;\n  constructor(msg: MsgCreateValidator_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreateValidator.TYPE_URL,\n      value: MsgCreateValidator_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport class MsgEditValidator extends BaseMsg {\n  public static TYPE_URL = `/${protobufPackage}.MsgEditValidator`;\n  public protoMsg: MsgEditValidator_pb;\n  constructor(msg: MsgEditValidator_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgEditValidator.TYPE_URL,\n      value: MsgEditValidator_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport class MsgDelegate extends BaseMsg {\n  public static TYPE_URL = `/${protobufPackage}.MsgDelegate`;\n  public protoMsg: MsgDelegate_pb;\n  constructor(msg: MsgDelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDelegate.TYPE_URL,\n      value: MsgDelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport class MsgBeginRedelegate extends BaseMsg {\n  public static TYPE_URL = `/${protobufPackage}.MsgBeginRedelegate`;\n  public protoMsg: MsgBeginRedelegate_pb;\n  constructor(msg: MsgBeginRedelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgBeginRedelegate.TYPE_URL,\n      value: MsgBeginRedelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport class MsgUndelegate extends BaseMsg {\n  public static TYPE_URL = `/${protobufPackage}.MsgUndelegate`;\n  public protoMsg: MsgUndelegate_pb;\n  constructor(msg: MsgUndelegate_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgUndelegate.TYPE_URL,\n      value: MsgUndelegate_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.secp256k1\";\n\n/**\n * PubKey defines a secp256k1 public key\n * Key is the compressed form of the pubkey. The first byte depends is a 0x02\n * byte if the y-coordinate is the lexicographically largest of the two\n * associated with the x-coordinate. Otherwise the first byte is a 0x03. This\n * prefix is followed with the x-coordinate.\n */\nexport interface PubKey {\n  key: Uint8Array;\n}\n\n/** PrivKey defines a secp256k1 private key. */\nexport interface PrivKey {\n  key: Uint8Array;\n}\n\nfunction createBasePubKey(): PubKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PubKey = {\n  encode(\n    message: PubKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PubKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePubKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PubKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PubKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PubKey>, I>>(object: I): PubKey {\n    const message = createBasePubKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePrivKey(): PrivKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PrivKey = {\n  encode(\n    message: PrivKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PrivKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePrivKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PrivKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PrivKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PrivKey>, I>>(object: I): PrivKey {\n    const message = createBasePrivKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.multisig.v1beta1\";\n\n/**\n * MultiSignature wraps the signatures from a multisig.LegacyAminoPubKey.\n * See cosmos.tx.v1betata1.ModeInfo.Multi for how to specify which signers\n * signed and with which modes.\n */\nexport interface MultiSignature {\n  signatures: Uint8Array[];\n}\n\n/**\n * CompactBitArray is an implementation of a space efficient bit array.\n * This is used to ensure that the encoded data takes up a minimal amount of\n * space after proto encoding.\n * This is not thread safe, and is not intended for concurrent usage.\n */\nexport interface CompactBitArray {\n  extraBitsStored: number;\n  elems: Uint8Array;\n}\n\nfunction createBaseMultiSignature(): MultiSignature {\n  return { signatures: [] };\n}\n\nexport const MultiSignature = {\n  encode(\n    message: MultiSignature,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MultiSignature {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMultiSignature();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MultiSignature {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MultiSignature): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MultiSignature>, I>>(\n    object: I\n  ): MultiSignature {\n    const message = createBaseMultiSignature();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseCompactBitArray(): CompactBitArray {\n  return { extraBitsStored: 0, elems: new Uint8Array() };\n}\n\nexport const CompactBitArray = {\n  encode(\n    message: CompactBitArray,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.extraBitsStored !== 0) {\n      writer.uint32(8).uint32(message.extraBitsStored);\n    }\n    if (message.elems.length !== 0) {\n      writer.uint32(18).bytes(message.elems);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CompactBitArray {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompactBitArray();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.extraBitsStored = reader.uint32();\n          break;\n        case 2:\n          message.elems = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CompactBitArray {\n    return {\n      extraBitsStored: isSet(object.extraBitsStored)\n        ? Number(object.extraBitsStored)\n        : 0,\n      elems: isSet(object.elems)\n        ? bytesFromBase64(object.elems)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CompactBitArray): unknown {\n    const obj: any = {};\n    message.extraBitsStored !== undefined &&\n      (obj.extraBitsStored = Math.round(message.extraBitsStored));\n    message.elems !== undefined &&\n      (obj.elems = base64FromBytes(\n        message.elems !== undefined ? message.elems : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CompactBitArray>, I>>(\n    object: I\n  ): CompactBitArray {\n    const message = createBaseCompactBitArray();\n    message.extraBitsStored = object.extraBitsStored ?? 0;\n    message.elems = object.elems ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../../google/protobuf/any\";\nimport { CompactBitArray } from \"../../../crypto/multisig/v1beta1/multisig\";\n\nexport const protobufPackage = \"cosmos.tx.signing.v1beta1\";\n\n/** SignMode represents a signing mode with its own security guarantees. */\nexport enum SignMode {\n  /**\n   * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n   * rejected\n   */\n  SIGN_MODE_UNSPECIFIED = 0,\n  /**\n   * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n   * verified with raw bytes from Tx\n   */\n  SIGN_MODE_DIRECT = 1,\n  /**\n   * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n   * human-readable textual representation on top of the binary representation\n   * from SIGN_MODE_DIRECT\n   */\n  SIGN_MODE_TEXTUAL = 2,\n  /**\n   * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n   * Amino JSON and will be removed in the future\n   */\n  SIGN_MODE_LEGACY_AMINO_JSON = 127,\n  UNRECOGNIZED = -1,\n}\n\nexport function signModeFromJSON(object: any): SignMode {\n  switch (object) {\n    case 0:\n    case \"SIGN_MODE_UNSPECIFIED\":\n      return SignMode.SIGN_MODE_UNSPECIFIED;\n    case 1:\n    case \"SIGN_MODE_DIRECT\":\n      return SignMode.SIGN_MODE_DIRECT;\n    case 2:\n    case \"SIGN_MODE_TEXTUAL\":\n      return SignMode.SIGN_MODE_TEXTUAL;\n    case 127:\n    case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n      return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignMode.UNRECOGNIZED;\n  }\n}\n\nexport function signModeToJSON(object: SignMode): string {\n  switch (object) {\n    case SignMode.SIGN_MODE_UNSPECIFIED:\n      return \"SIGN_MODE_UNSPECIFIED\";\n    case SignMode.SIGN_MODE_DIRECT:\n      return \"SIGN_MODE_DIRECT\";\n    case SignMode.SIGN_MODE_TEXTUAL:\n      return \"SIGN_MODE_TEXTUAL\";\n    case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n      return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    case SignMode.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignatureDescriptors wraps multiple SignatureDescriptor's. */\nexport interface SignatureDescriptors {\n  /** signatures are the signature descriptors */\n  signatures: SignatureDescriptor[];\n}\n\n/**\n * SignatureDescriptor is a convenience type which represents the full data for\n * a signature including the public key of the signer, signing modes and the\n * signature itself. It is primarily used for coordinating signatures between\n * clients.\n */\nexport interface SignatureDescriptor {\n  /** public_key is the public key of the signer */\n  publicKey?: Any;\n  data?: SignatureDescriptor_Data;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to\n   * prevent replay attacks.\n   */\n  sequence: Long;\n}\n\n/** Data represents signature data */\nexport interface SignatureDescriptor_Data {\n  /** single represents a single signer */\n  single?: SignatureDescriptor_Data_Single | undefined;\n  /** multi represents a multisig signer */\n  multi?: SignatureDescriptor_Data_Multi | undefined;\n}\n\n/** Single is the signature data for a single signer */\nexport interface SignatureDescriptor_Data_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n  /** signature is the raw signature bytes */\n  signature: Uint8Array;\n}\n\n/** Multi is the signature data for a multisig public key */\nexport interface SignatureDescriptor_Data_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /** signatures is the signatures of the multi-signature */\n  signatures: SignatureDescriptor_Data[];\n}\n\nfunction createBaseSignatureDescriptors(): SignatureDescriptors {\n  return { signatures: [] };\n}\n\nexport const SignatureDescriptors = {\n  encode(\n    message: SignatureDescriptors,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      SignatureDescriptor.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptors {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptors();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(\n            SignatureDescriptor.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptors {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => SignatureDescriptor.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptors): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptors>, I>>(\n    object: I\n  ): SignatureDescriptors {\n    const message = createBaseSignatureDescriptors();\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor(): SignatureDescriptor {\n  return { publicKey: undefined, data: undefined, sequence: Long.UZERO };\n}\n\nexport const SignatureDescriptor = {\n  encode(\n    message: SignatureDescriptor,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.data !== undefined) {\n      SignatureDescriptor_Data.encode(\n        message.data,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureDescriptor {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.data = SignatureDescriptor_Data.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      data: isSet(object.data)\n        ? SignatureDescriptor_Data.fromJSON(object.data)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.data !== undefined &&\n      (obj.data = message.data\n        ? SignatureDescriptor_Data.toJSON(message.data)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor>, I>>(\n    object: I\n  ): SignatureDescriptor {\n    const message = createBaseSignatureDescriptor();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.data =\n      object.data !== undefined && object.data !== null\n        ? SignatureDescriptor_Data.fromPartial(object.data)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data(): SignatureDescriptor_Data {\n  return { single: undefined, multi: undefined };\n}\n\nexport const SignatureDescriptor_Data = {\n  encode(\n    message: SignatureDescriptor_Data,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      SignatureDescriptor_Data_Single.encode(\n        message.single,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.multi !== undefined) {\n      SignatureDescriptor_Data_Multi.encode(\n        message.multi,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = SignatureDescriptor_Data_Single.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.multi = SignatureDescriptor_Data_Multi.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data {\n    return {\n      single: isSet(object.single)\n        ? SignatureDescriptor_Data_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? SignatureDescriptor_Data_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? SignatureDescriptor_Data_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? SignatureDescriptor_Data_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data>, I>>(\n    object: I\n  ): SignatureDescriptor_Data {\n    const message = createBaseSignatureDescriptor_Data();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? SignatureDescriptor_Data_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? SignatureDescriptor_Data_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Single(): SignatureDescriptor_Data_Single {\n  return { mode: 0, signature: new Uint8Array() };\n}\n\nexport const SignatureDescriptor_Data_Single = {\n  encode(\n    message: SignatureDescriptor_Data_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(18).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        case 2:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Single>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Single {\n    const message = createBaseSignatureDescriptor_Data_Single();\n    message.mode = object.mode ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Multi(): SignatureDescriptor_Data_Multi {\n  return { bitarray: undefined, signatures: [] };\n}\n\nexport const SignatureDescriptor_Data_Multi = {\n  encode(\n    message: SignatureDescriptor_Data_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.signatures) {\n      SignatureDescriptor_Data.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signatures.push(\n            SignatureDescriptor_Data.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) =>\n            SignatureDescriptor_Data.fromJSON(e)\n          )\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor_Data.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Multi>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Multi {\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor_Data.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  SignMode,\n  signModeFromJSON,\n  signModeToJSON,\n} from \"../signing/v1beta1/signing\";\nimport { CompactBitArray } from \"../../crypto/multisig/v1beta1/multisig\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.tx.v1beta1\";\n\n/** Tx is the standard type used for broadcasting transactions. */\nexport interface Tx {\n  /** body is the processable content of the transaction */\n  body?: TxBody;\n  /**\n   * auth_info is the authorization related content of the transaction,\n   * specifically signers, signer modes and fee\n   */\n  authInfo?: AuthInfo;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/**\n * TxRaw is a variant of Tx that pins the signer's exact binary representation\n * of body and auth_info. This is used for signing, broadcasting and\n * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and\n * the hash `sha256(serialize(tx: TxRaw))` becomes the \"txhash\", commonly used\n * as the transaction ID.\n */\nexport interface TxRaw {\n  /**\n   * body_bytes is a protobuf serialization of a TxBody that matches the\n   * representation in SignDoc.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in SignDoc.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/** SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT. */\nexport interface SignDoc {\n  /**\n   * body_bytes is protobuf serialization of a TxBody that matches the\n   * representation in TxRaw.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in TxRaw.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * chain_id is the unique identifier of the chain this transaction targets.\n   * It prevents signed transactions from being used on another chain by an\n   * attacker\n   */\n  chainId: string;\n  /** account_number is the account number of the account in state */\n  accountNumber: Long;\n}\n\n/** TxBody is the body of a transaction that all signers sign over. */\nexport interface TxBody {\n  /**\n   * messages is a list of messages to be executed. The required signers of\n   * those messages define the number and order of elements in AuthInfo's\n   * signer_infos and Tx's signatures. Each required signer address is added to\n   * the list only the first time it occurs.\n   * By convention, the first required signer (usually from the first message)\n   * is referred to as the primary signer and pays the fee for the whole\n   * transaction.\n   */\n  messages: Any[];\n  /**\n   * memo is any arbitrary note/comment to be added to the transaction.\n   * WARNING: in clients, any publicly exposed text should not be called memo,\n   * but should be called `note` instead (see\n   * https://github.com/cosmos/cosmos-sdk/issues/9122).\n   */\n  memo: string;\n  /**\n   * timeout is the block height after which this transaction will not\n   * be processed by the chain\n   */\n  timeoutHeight: Long;\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, the transaction will be rejected\n   */\n  extensionOptions: Any[];\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, they will be ignored\n   */\n  nonCriticalExtensionOptions: Any[];\n}\n\n/**\n * AuthInfo describes the fee and signer modes that are used to sign a\n * transaction.\n */\nexport interface AuthInfo {\n  /**\n   * signer_infos defines the signing modes for the required signers. The number\n   * and order of elements must match the required signers from TxBody's\n   * messages. The first element is the primary signer and the one which pays\n   * the fee.\n   */\n  signerInfos: SignerInfo[];\n  /**\n   * Fee is the fee and gas limit for the transaction. The first signer is the\n   * primary signer and the one which pays the fee. The fee can be calculated\n   * based on the cost of evaluating the body and doing signature verification\n   * of the signers. This can be estimated via simulation.\n   */\n  fee?: Fee;\n}\n\n/**\n * SignerInfo describes the public key and signing mode of a single top-level\n * signer.\n */\nexport interface SignerInfo {\n  /**\n   * public_key is the public key of the signer. It is optional for accounts\n   * that already exist in state. If unset, the verifier can use the required \\\n   * signer address for this position and lookup the public key.\n   */\n  publicKey?: Any;\n  /**\n   * mode_info describes the signing mode of the signer and is a nested\n   * structure to support nested multisig pubkey's\n   */\n  modeInfo?: ModeInfo;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to\n   * prevent replay attacks.\n   */\n  sequence: Long;\n}\n\n/** ModeInfo describes the signing mode of a single or nested multisig signer. */\nexport interface ModeInfo {\n  /** single represents a single signer */\n  single?: ModeInfo_Single | undefined;\n  /** multi represents a nested multisig signer */\n  multi?: ModeInfo_Multi | undefined;\n}\n\n/**\n * Single is the mode info for a single signer. It is structured as a message\n * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\n * future\n */\nexport interface ModeInfo_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n}\n\n/** Multi is the mode info for a multisig public key */\nexport interface ModeInfo_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /**\n   * mode_infos is the corresponding modes of the signers of the multisig\n   * which could include nested multisig public keys\n   */\n  modeInfos: ModeInfo[];\n}\n\n/**\n * Fee includes the amount of coins paid in fees and the maximum\n * gas to be used by the transaction. The ratio yields an effective \"gasprice\",\n * which must be above some miminum to be accepted into the mempool.\n */\nexport interface Fee {\n  /** amount is the amount of coins to be paid as a fee */\n  amount: Coin[];\n  /**\n   * gas_limit is the maximum gas that can be used in transaction processing\n   * before an out of gas error occurs\n   */\n  gasLimit: Long;\n  /**\n   * if unset, the first signer is responsible for paying the fees. If set, the\n   * specified account must pay the fees. the payer must be a tx signer (and\n   * thus have signed this field in AuthInfo). setting this field does *not*\n   * change the ordering of required signers for the transaction.\n   */\n  payer: string;\n  /**\n   * if set, the fee payer (either the first signer or the value of the payer\n   * field) requests that a fee grant be used to pay fees instead of the fee\n   * payer's own balance. If an appropriate fee grant does not exist or the\n   * chain does not support fee grants, this will fail\n   */\n  granter: string;\n}\n\nfunction createBaseTx(): Tx {\n  return { body: undefined, authInfo: undefined, signatures: [] };\n}\n\nexport const Tx = {\n  encode(message: Tx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.body !== undefined) {\n      TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.authInfo !== undefined) {\n      AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Tx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.body = TxBody.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.authInfo = AuthInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Tx {\n    return {\n      body: isSet(object.body) ? TxBody.fromJSON(object.body) : undefined,\n      authInfo: isSet(object.authInfo)\n        ? AuthInfo.fromJSON(object.authInfo)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Tx): unknown {\n    const obj: any = {};\n    message.body !== undefined &&\n      (obj.body = message.body ? TxBody.toJSON(message.body) : undefined);\n    message.authInfo !== undefined &&\n      (obj.authInfo = message.authInfo\n        ? AuthInfo.toJSON(message.authInfo)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Tx>, I>>(object: I): Tx {\n    const message = createBaseTx();\n    message.body =\n      object.body !== undefined && object.body !== null\n        ? TxBody.fromPartial(object.body)\n        : undefined;\n    message.authInfo =\n      object.authInfo !== undefined && object.authInfo !== null\n        ? AuthInfo.fromPartial(object.authInfo)\n        : undefined;\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseTxRaw(): TxRaw {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    signatures: [],\n  };\n}\n\nexport const TxRaw = {\n  encode(message: TxRaw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxRaw {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxRaw();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxRaw {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxRaw): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxRaw>, I>>(object: I): TxRaw {\n    const message = createBaseTxRaw();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignDoc(): SignDoc {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    chainId: \"\",\n    accountNumber: Long.UZERO,\n  };\n}\n\nexport const SignDoc = {\n  encode(\n    message: SignDoc,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(26).string(message.chainId);\n    }\n    if (!message.accountNumber.isZero()) {\n      writer.uint32(32).uint64(message.accountNumber);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignDoc {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignDoc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.chainId = reader.string();\n          break;\n        case 4:\n          message.accountNumber = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignDoc {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      accountNumber: isSet(object.accountNumber)\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignDoc): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.accountNumber !== undefined &&\n      (obj.accountNumber = (message.accountNumber || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignDoc>, I>>(object: I): SignDoc {\n    const message = createBaseSignDoc();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.chainId = object.chainId ?? \"\";\n    message.accountNumber =\n      object.accountNumber !== undefined && object.accountNumber !== null\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxBody(): TxBody {\n  return {\n    messages: [],\n    memo: \"\",\n    timeoutHeight: Long.UZERO,\n    extensionOptions: [],\n    nonCriticalExtensionOptions: [],\n  };\n}\n\nexport const TxBody = {\n  encode(\n    message: TxBody,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.messages) {\n      Any.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.memo !== \"\") {\n      writer.uint32(18).string(message.memo);\n    }\n    if (!message.timeoutHeight.isZero()) {\n      writer.uint32(24).uint64(message.timeoutHeight);\n    }\n    for (const v of message.extensionOptions) {\n      Any.encode(v!, writer.uint32(8186).fork()).ldelim();\n    }\n    for (const v of message.nonCriticalExtensionOptions) {\n      Any.encode(v!, writer.uint32(16378).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxBody {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxBody();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.messages.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.memo = reader.string();\n          break;\n        case 3:\n          message.timeoutHeight = reader.uint64() as Long;\n          break;\n        case 1023:\n          message.extensionOptions.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2047:\n          message.nonCriticalExtensionOptions.push(\n            Any.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxBody {\n    return {\n      messages: Array.isArray(object?.messages)\n        ? object.messages.map((e: any) => Any.fromJSON(e))\n        : [],\n      memo: isSet(object.memo) ? String(object.memo) : \"\",\n      timeoutHeight: isSet(object.timeoutHeight)\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO,\n      extensionOptions: Array.isArray(object?.extensionOptions)\n        ? object.extensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n      nonCriticalExtensionOptions: Array.isArray(\n        object?.nonCriticalExtensionOptions\n      )\n        ? object.nonCriticalExtensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxBody): unknown {\n    const obj: any = {};\n    if (message.messages) {\n      obj.messages = message.messages.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.messages = [];\n    }\n    message.memo !== undefined && (obj.memo = message.memo);\n    message.timeoutHeight !== undefined &&\n      (obj.timeoutHeight = (message.timeoutHeight || Long.UZERO).toString());\n    if (message.extensionOptions) {\n      obj.extensionOptions = message.extensionOptions.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.extensionOptions = [];\n    }\n    if (message.nonCriticalExtensionOptions) {\n      obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(\n        (e) => (e ? Any.toJSON(e) : undefined)\n      );\n    } else {\n      obj.nonCriticalExtensionOptions = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxBody>, I>>(object: I): TxBody {\n    const message = createBaseTxBody();\n    message.messages = object.messages?.map((e) => Any.fromPartial(e)) || [];\n    message.memo = object.memo ?? \"\";\n    message.timeoutHeight =\n      object.timeoutHeight !== undefined && object.timeoutHeight !== null\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO;\n    message.extensionOptions =\n      object.extensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    message.nonCriticalExtensionOptions =\n      object.nonCriticalExtensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseAuthInfo(): AuthInfo {\n  return { signerInfos: [], fee: undefined };\n}\n\nexport const AuthInfo = {\n  encode(\n    message: AuthInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signerInfos) {\n      SignerInfo.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.fee !== undefined) {\n      Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AuthInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAuthInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signerInfos.push(SignerInfo.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.fee = Fee.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AuthInfo {\n    return {\n      signerInfos: Array.isArray(object?.signerInfos)\n        ? object.signerInfos.map((e: any) => SignerInfo.fromJSON(e))\n        : [],\n      fee: isSet(object.fee) ? Fee.fromJSON(object.fee) : undefined,\n    };\n  },\n\n  toJSON(message: AuthInfo): unknown {\n    const obj: any = {};\n    if (message.signerInfos) {\n      obj.signerInfos = message.signerInfos.map((e) =>\n        e ? SignerInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.signerInfos = [];\n    }\n    message.fee !== undefined &&\n      (obj.fee = message.fee ? Fee.toJSON(message.fee) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AuthInfo>, I>>(object: I): AuthInfo {\n    const message = createBaseAuthInfo();\n    message.signerInfos =\n      object.signerInfos?.map((e) => SignerInfo.fromPartial(e)) || [];\n    message.fee =\n      object.fee !== undefined && object.fee !== null\n        ? Fee.fromPartial(object.fee)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignerInfo(): SignerInfo {\n  return { publicKey: undefined, modeInfo: undefined, sequence: Long.UZERO };\n}\n\nexport const SignerInfo = {\n  encode(\n    message: SignerInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.modeInfo !== undefined) {\n      ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignerInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignerInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfo = ModeInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignerInfo {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      modeInfo: isSet(object.modeInfo)\n        ? ModeInfo.fromJSON(object.modeInfo)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignerInfo): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.modeInfo !== undefined &&\n      (obj.modeInfo = message.modeInfo\n        ? ModeInfo.toJSON(message.modeInfo)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignerInfo>, I>>(\n    object: I\n  ): SignerInfo {\n    const message = createBaseSignerInfo();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.modeInfo =\n      object.modeInfo !== undefined && object.modeInfo !== null\n        ? ModeInfo.fromPartial(object.modeInfo)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo(): ModeInfo {\n  return { single: undefined, multi: undefined };\n}\n\nexport const ModeInfo = {\n  encode(\n    message: ModeInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.multi !== undefined) {\n      ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = ModeInfo_Single.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.multi = ModeInfo_Multi.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo {\n    return {\n      single: isSet(object.single)\n        ? ModeInfo_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? ModeInfo_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: ModeInfo): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? ModeInfo_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? ModeInfo_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo>, I>>(object: I): ModeInfo {\n    const message = createBaseModeInfo();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? ModeInfo_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? ModeInfo_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Single(): ModeInfo_Single {\n  return { mode: 0 };\n}\n\nexport const ModeInfo_Single = {\n  encode(\n    message: ModeInfo_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n    };\n  },\n\n  toJSON(message: ModeInfo_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Single>, I>>(\n    object: I\n  ): ModeInfo_Single {\n    const message = createBaseModeInfo_Single();\n    message.mode = object.mode ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Multi(): ModeInfo_Multi {\n  return { bitarray: undefined, modeInfos: [] };\n}\n\nexport const ModeInfo_Multi = {\n  encode(\n    message: ModeInfo_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.modeInfos) {\n      ModeInfo.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfos.push(ModeInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      modeInfos: Array.isArray(object?.modeInfos)\n        ? object.modeInfos.map((e: any) => ModeInfo.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ModeInfo_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.modeInfos) {\n      obj.modeInfos = message.modeInfos.map((e) =>\n        e ? ModeInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.modeInfos = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Multi>, I>>(\n    object: I\n  ): ModeInfo_Multi {\n    const message = createBaseModeInfo_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.modeInfos =\n      object.modeInfos?.map((e) => ModeInfo.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseFee(): Fee {\n  return { amount: [], gasLimit: Long.UZERO, payer: \"\", granter: \"\" };\n}\n\nexport const Fee = {\n  encode(message: Fee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.gasLimit.isZero()) {\n      writer.uint32(16).uint64(message.gasLimit);\n    }\n    if (message.payer !== \"\") {\n      writer.uint32(26).string(message.payer);\n    }\n    if (message.granter !== \"\") {\n      writer.uint32(34).string(message.granter);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Fee {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseFee();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.gasLimit = reader.uint64() as Long;\n          break;\n        case 3:\n          message.payer = reader.string();\n          break;\n        case 4:\n          message.granter = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Fee {\n    return {\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n      gasLimit: isSet(object.gasLimit)\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO,\n      payer: isSet(object.payer) ? String(object.payer) : \"\",\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n    };\n  },\n\n  toJSON(message: Fee): unknown {\n    const obj: any = {};\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    message.gasLimit !== undefined &&\n      (obj.gasLimit = (message.gasLimit || Long.UZERO).toString());\n    message.payer !== undefined && (obj.payer = message.payer);\n    message.granter !== undefined && (obj.granter = message.granter);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Fee>, I>>(object: I): Fee {\n    const message = createBaseFee();\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    message.gasLimit =\n      object.gasLimit !== undefined && object.gasLimit !== null\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO;\n    message.payer = object.payer ?? \"\";\n    message.granter = object.granter ?? \"\";\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { Keccak } from \"sha3\";\nimport invariant from \"tiny-invariant\";\nimport {APIClient} from \"./APIClient\";\nimport { Buffer } from \"buffer\";\nimport { CONFIG_CHAIN_SOPHON } from \"../constants\";\nimport {\n  EncodeObject,\n  GeneratedType,\n  OfflineSigner,\n  Registry,\n  TxBodyEncodeObject,\n} from \"@cosmjs/proto-signing\";\nimport { Any } from \"cosmjs-types/google/protobuf/any\";\nimport {\n  BaseMsg,\n  MsgCollect,\n  MsgCollectReward,\n  MsgCreatePool,\n  MsgCreatePosition,\n  MsgDecreaseLiquidity,\n  MsgIncreaseLiquidity,\n  MsgSwapExactIn,\n  MsgSwapExactOut,\n  MsgSubmitProposal,\n  MsgDeposit,\n  MsgVote,\n  MsgVoteWeighted\n} from \"../msgs\";\nimport { SigningStargateClient } from \"@cosmjs/stargate\";\nimport { PubKey } from \"../proto/cosmos/crypto/secp256k1/keys\";\nimport {\n  SignerInfo,\n  ModeInfo,\n  ModeInfo_Single,\n  TxBody,\n  Fee,\n  AuthInfo,\n  SignDoc,\n  TxRaw,\n} from \"../proto/cosmos/tx/v1beta1/tx\";\nimport { SignMode } from \"../proto/cosmos/tx/signing/v1beta1/signing\";\nimport { Coin } from \"../proto/cosmos/base/v1beta1/coin\";\nimport { fromBase64 } from \"@cosmjs/encoding\";\n\nexport interface ISender {\n  address: string;\n  pubkey: Uint8Array;\n  accountNumber: number;\n  sequence: number;\n}\n\n// FIXME\nexport interface TxGenerated {\n  signDirect: {\n    body: TxBodyEncodeObject;\n    authInfo: AuthInfo;\n    signBytes: string;\n  };\n}\n\nexport const SIGN_DIRECT = SignMode.SIGN_MODE_DIRECT;\n\n// const defaultFee: StdFee = {\n//   amount: [],\n//   gas: CONFIG_CHAIN_SOPHON.DEFAULT_GAS,\n// };\n\nconst defaultFee = {\n  amount: \"\",\n  denom: CONFIG_CHAIN_SOPHON.COIN_DENOM,\n  gas: CONFIG_CHAIN_SOPHON.DEFAULT_GAS as number,\n};\n\nexport class TxClient {\n  public apiClient: APIClient;\n  public rpcUrl: string;\n  public accountAddress: string;\n  public signer: OfflineSigner;\n  public registry: Registry;\n\n  // public walletClient: SigningStargateClient | null = null;\n  // public sender: ISender | null = null;\n\n  constructor(\n    apiClient: APIClient,\n    rpcUrl: string,\n    signer: OfflineSigner,\n    accountAddress: string\n  ) {\n    invariant(!!signer, \"wallet is required!\");\n\n    this.apiClient = apiClient;\n    this.rpcUrl = rpcUrl;\n    this.signer = signer;\n    this.accountAddress = accountAddress;\n\n    const registryTypes = new Map<string, GeneratedType>();\n    registryTypes.set(MsgCollect.typeUrl, MsgCollect.Proto);\n    registryTypes.set(MsgCollectReward.typeUrl, MsgCollectReward.Proto);\n    registryTypes.set(MsgCreatePool.typeUrl, MsgCreatePool.Proto);\n    registryTypes.set(MsgCreatePosition.typeUrl, MsgCreatePosition.Proto);\n    registryTypes.set(MsgDecreaseLiquidity.typeUrl, MsgDecreaseLiquidity.Proto);\n    registryTypes.set(MsgIncreaseLiquidity.typeUrl, MsgIncreaseLiquidity.Proto);\n    registryTypes.set(MsgSwapExactIn.typeUrl, MsgSwapExactIn.Proto);\n    registryTypes.set(MsgSwapExactOut.typeUrl, MsgSwapExactOut.Proto);\n    registryTypes.set(MsgSubmitProposal.typeUrl, MsgSubmitProposal.Proto);\n    registryTypes.set(MsgDeposit.typeUrl, MsgDeposit.Proto);\n    registryTypes.set(MsgVote.typeUrl, MsgVote.Proto);\n    registryTypes.set(MsgVoteWeighted.typeUrl, MsgVoteWeighted.Proto);\n\n    this.registry = new Registry(registryTypes);\n  }\n\n  public async getSender(): Promise<ISender> {\n    const { authAPI } = this.apiClient;\n    const {\n      account: {\n        base_account: {\n          pub_key,\n          account_number,\n          sequence,\n        },\n      },\n    } = await authAPI.apiAccountInfo(this.accountAddress);\n    const { address, pubkey } = (await this.signer.getAccounts())[0];\n    return {\n      address: this.accountAddress,\n      pubkey,\n      accountNumber: parseInt(account_number),\n      sequence: parseInt(sequence),\n    } as ISender;\n  }\n\n  public async sendTransaction(\n    messages: BaseMsg | Array<BaseMsg>,\n    memo: string = \"\"\n    // fee: string,\n    // denom: string,\n    // gasLimit: number,\n  ) {\n    const sender = await this.getSender();\n    // const pubKeyDecoded = Buffer.from(sender.pubkey, \"base64\");\n\n    // 1. SignDirect\n    const signInfoDirect = createSignerInfo(\n      sender.pubkey,\n      sender.sequence,\n      SIGN_DIRECT\n    );\n\n    // 2. Fee\n    const feeMessage = createFee(\n      defaultFee.amount,\n      defaultFee.denom,\n      defaultFee.gas\n    );\n\n    // 3. authInfo\n    const authInfoDirect = createAuthInfo(signInfoDirect, feeMessage);\n\n    // console.log(AuthInfo.encode(authInfoDirect).finish());\n\n    // 4. txbody\n    // const body = createBodyWithMultipleMessages(messages, memo);\n    const _messages = messages instanceof Array ? messages : [messages];\n    const body = createTxBodyEncodeObject(_messages, memo);\n\n    // 5. signDoc\n    const signDocDirect = createSigDoc(\n      this.registry.encode(body),\n      AuthInfo.encode(authInfoDirect).finish(),\n      CONFIG_CHAIN_SOPHON.CHAIN_ID,\n      sender.accountNumber\n    );\n\n    let walletClient;\n    walletClient = await SigningStargateClient.connectWithSigner(\n      this.rpcUrl,\n      this.signer,\n      {\n        registry: this.registry,\n        prefix: CONFIG_CHAIN_SOPHON.COIN_MINIMAL_DENOM.toLowerCase(),\n      }\n    );\n    // @ts-ignore\n    const { signed, signature } = await walletClient.signer.signDirect(\n      this.accountAddress,\n      signDocDirect\n    );\n\n    const txRaw = TxRaw.fromPartial({\n      bodyBytes: signed.bodyBytes,\n      authInfoBytes: signed.authInfoBytes,\n      signatures: [fromBase64(signature.signature)],\n    });\n    const txBytes = TxRaw.encode(txRaw).finish();\n\n    return walletClient.broadcastTx(txBytes);\n  }\n\n  // public async signTransaction(\n  //   tx: TxGenerated,\n  //   broadcastMode: string = 'BROADCAST_MODE_BLOCK',\n  // ) {\n  //   const dataToSign = `0x${Buffer.from(\n  //     tx.signDirect.signBytes,\n  //     'base64',\n  //   ).toString('hex')}`\n  //\n  //   /* eslint-disable no-underscore-dangle */\n  //   const signatureRaw = wallet._signingKey().signDigest(dataToSign)\n  //   const splitedSignature = splitSignature(signatureRaw)\n  //   const signature = arrayify(concat([splitedSignature.r, splitedSignature.s]))\n  //\n  //   const signedTx = createTxRaw(\n  //     tx.signDirect.body.serializeBinary(),\n  //     tx.signDirect.authInfo.serializeBinary(),\n  //     [signature],\n  //   )\n  //   const body = `{ \"tx_bytes\": [${signedTx.message\n  //     .serializeBinary()\n  //     .toString()}], \"mode\": \"${broadcastMode}\" }`\n  //\n  //   return body\n  // }\n}\n\nexport function createTxBodyEncodeObject(\n  messages: Array<BaseMsg>,\n  memo: string\n): TxBodyEncodeObject {\n  const results = messages.map((item) => {\n    return item.generateMessage();\n  });\n  return {\n    typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n    value: {\n      messages: results,\n      memo: memo,\n    },\n  };\n}\n\nexport function createSigDoc(\n  bodyBytes: Uint8Array,\n  authInfoBytes: Uint8Array,\n  chainId: string,\n  accountNumber: number\n) {\n  return SignDoc.fromPartial({\n    bodyBytes,\n    authInfoBytes,\n    chainId,\n    accountNumber,\n  });\n}\n\nfunction createAuthInfo(signerInfo: SignerInfo, fee: Fee) {\n  return AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee,\n  });\n}\n\nfunction createFee(fee: string, denom: string, gasLimit: number) {\n  return Fee.fromPartial({\n    amount: [\n      Coin.fromPartial({\n        denom,\n        amount: fee,\n      }),\n    ],\n    gasLimit,\n  });\n}\n\nfunction createSignerInfo(\n  publicKey: Uint8Array,\n  sequence: number,\n  mode: number\n) {\n  const pubkey = Any.fromPartial({\n    typeUrl: \"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\n    value: PubKey.encode({\n      key: publicKey,\n    }).finish(),\n  });\n  const signerInfo = SignerInfo.fromPartial({\n    publicKey: pubkey,\n    modeInfo: ModeInfo.fromPartial({\n      single: ModeInfo_Single.fromPartial({\n        mode,\n      }),\n    }),\n    sequence,\n  });\n\n  return signerInfo;\n}\n"],"names":["APIRequester","baseURL","axios","Axios","create","headers","Accept","timeout","get","endpoint","params","then","d","data","post","BaseAPI","request","BankAPI","apiTokenBalance","token","accountAddress","denom","apiAccountBalance","AuthAPI","apiAccountInfo","SwapAPI","apiPoolListByAddresses","addresses","join","apiPoolMetadataByAddress","address","apiPoolMetadataPriceByAddress","apiLiquidityPositionById","tokenId","apiLiquidityRewardsByIds","tokenIds","apiTickImagePath","apiActiveFarmList","apiLiquidityPositionList","TxAPI","txInfo","txHash","_broadcast","tx","mode","broadcast","to32","value","arr","split","len","length","result","forEach","item","push","i","unshift","deepCopy","source","JSON","parse","stringify","encrypt","prefix","suffix","substr","creator","name","symbol","totalSupply","decimal","logoURI","findTokenByDenom","tokenDenom","tokens","DEFAULT_TOKEN_LIST","find","findTokenBySymbol","toUpperCase","ONE_DAY_TO_SECONDS","ONE_YEAR_TO_DAYS","Fee_Amount","FEE_AMOUNT_DETAIL","LOW","label","description","MEDIUM","HIGH","ETH","BSC","OEC","HOO","XDAI","HECO","POLYGON","FANTOM","KCC","AVALANCHE","SOPHON","ETH_CHAIN_NAME","BSC_CHAIN_NAME","OEC_CHAIN_NAME","HOO_CHAIN_NAME","XDAI_CHAIN_NAME","HECO_CHAIN_NAME","POLYGON_CHAIN_NAME","FANTOM_CHAIN_NAME","KCC_CHAIN_NAME","AVALANCHE_CHAIN_NAME","SOPHON_TEST_CHAIN_NAME","ETH_NETWORK_ID","BSC_NETWORK_ID","BSC_NETWORK_TEST_ID","OEC_NETWORK_ID","HOO_NETWORK_ID","XDAI_NETWORK_ID","HECO_NETWORK_ID","POLYGON_NETWORK_ID","FANTOM_NETWORK_ID","KCC_NETWORK_ID","AVALANCHE_NETWORK_ID","ETH_TEST_NETWORK_ID","SOPHON_TEST_NETWORK_ID","ETH_CHAIN_ID","BSC_CHAIN_ID","BSC_CHAIN_ID_TEST","OEC_CHAIN_ID","HOO_CHAIN_ID","XDAI_CHAIN_ID","HECO_CHAIN_ID","POLYGON_CHAIN_ID","FANTOM_CHAIN_ID","KCC_CHAIN_ID","AVALANCHE_CHAIN_ID","SOPHON_TEST_CHAIN_ID","ETH_SYMBOL","BNB_SYMBOL","OKT_SYMBOL","HOO_SYMBOL","XDAI_SYMBOL","HT_SYMBOL","POLYGON_SYMBOL","FANTOM_SYMBOL","KCC_SYMBOL","AVALANCHE_SYMBOL","SOPHON_SYMBOL","SUPPORTED_CHAIN_IDS","NETWORK_MAP","networkId","chainId","chainName","providerType","ticker","CONFIG_CHAIN_SOPHON","RPC_URL","REST_URL","EXPLORER_URL","NETWORK_NAME","NETWORK_TYPE","CHAIN_ID","CHAIN_NAME","COIN_DENOM","COIN_MINIMAL_DENOM","COIN_DECIMALS","PREFIX","COIN_TYPE","COINGECKO_ID","DEFAULT_GAS","GAS_PRICE_STEP_LOW","GAS_PRICE_STEP_AVERAGE","GAS_PRICE_STEP_HIGH","FEATURES","CHAIN_ETH","CHAIN_SOP","ZERO","DEFAULT_USER_PRECISION","DEFAULT_PRECISION","MAX_PRECISION","REG_NUMBER","RegExp","REG_DECIMAL_SIMPLE","REG_DECIMAL","TICK_SPACINGS","BASE_UNIT_TICK","toDecimalPlaces","precision","Decimal","ROUND_UP","toString","e","String","toAmountString","roundingMode","ROUND_DOWN","toSignificantDigits","toAmountFloor","toAmountCeil","toAmountFee","isEmptyAmount","_value","mul","Math","pow","floor","isZero","toExactAmount","CosmosDecimal","fromUserInput","formatNumber","seperator","fixed","div","toFixed","moment","locale","formatMoment","pattern","format","formatUnixMoment","formatTime","time","formatDiffTime","fromNow","toUsd","getPoolAddress","denom0","denom1","fee","key","Bech32","encode","sha256","toUtf8","slice","getPercentByFeeAmount","isNumeric","isNaN","parseFloat","checkInputNumber","test","plus","value1","value2","minus","multipliedBy","isGreaterThan","greaterThanOrEqualTo","isLessThan","lessThan","isEqualTo","equals","pow18","round","ceil","powM18","shift","isPositive","greaterThan","objectToMap","Map","Object","entries","arrayToMap","array","property","map","set","sortsBefore","baseToken","quoteToken","toLowerCase","percentage","toPercent","decimalNumber","number","replace","int","float","Number","Bound","Tip_Level","Swap_Direction","Transaction_Status","longToNumber","long","gt","MAX_SAFE_INTEGER","globalThis","Error","toNumber","LiquidityMath","getRightSideLiquidity","leftRangeValue","rightRangeValue","priceValue","amount","numerator","_value1","sqrt","_value2","denominator","sub","getLeftSideLiquidity","getLiquidityFromAmount0","amount0","pc","deltaX","_getDiverForDeltaX","lower","upper","_getDiverForDeltaY","getLiquidityFromAmount1","amount1","deltaY","getAmount1FromAmount0","token0","liquidity","console","log","getAmount0FromAmount1","token1","getAmountByLiquidity","deltaXDiver","deltaYDiver","TickMath","priceToClosestTick","price","log2","getNearestTickByPrice","feeAmount","trim","INVALID_TICK","MIN_TICK_VALUE","MIN_TICK","MAX_TICK_VALUE","MAX_TICK","tick","nearestUsableTick","getFormattedPriceByTick","isLowestTick","isHighestTick","base","getPriceByTick","getNearestPriceByInput","nearestTick","getPriceBySqrtPrice","sqrtPrice","getSqrtPriceByPrice","getBaseTickRange","fromToken","toToken","leftRange","rightRange","tickLower","tickUpper","getNearestLowestTick","getNearestHighestTick","getNearestPricesByFullTick","lowestPrice","highestPrice","highestTick","lowestTick","tickSpacing","rounded","TransactionLooper","status","onTransactionSuccess","transactionHash","counter","APIClient","URL","apiRequester","bankAPI","authAPI","swapAPI","txAPI","nodeUrl","BaseMsg","createBaseTimestamp","seconds","Long","nanos","Timestamp","message","writer","_m0","uint32","int64","int32","decode","input","reader","end","undefined","pos","tag","skipType","fromJSON","object","isSet","fromValue","toJSON","obj","fromPartial","protobufPackage","createBaseMsgCreatePool","MsgCreatePool","string","createBaseMsgCreatePosition","amount0Desired","amount1Desired","amount0Min","amount1Min","recipient","deadline","MsgCreatePosition","toTimestamp","fork","ldelim","fromTimestamp","fromJsonTimestamp","toISOString","createBaseMsgIncreaseLiquidity","MsgIncreaseLiquidity","createBaseMsgDecreaseLiquidity","MsgDecreaseLiquidity","createBaseMsgCollect","amount0Max","amount1Max","collectOnly","MsgCollect","bool","Boolean","createBaseMsgSwapExactIn","amountIn","amountOutMin","denoms","fees","MsgSwapExactIn","v","end2","Array","isArray","createBaseMsgSwapExactOut","amountOut","amountInMax","MsgSwapExactOut","createBaseMsgCollectReward","MsgCollectReward","date","numberToLong","getTime","t","millis","Date","o","fromNumber","msg","protoMsg","generateMessage","typeUrl","MsgCollectReward_pb","MsgSwapExactOut_pb","MsgSwapExactIn_pb","MsgCreatePool_pb","MsgCollect_pb","MsgCreatePosition_pb","MsgDecreaseLiquidity_pb","MsgIncreaseLiquidity_pb","createBaseAny","Uint8Array","Any","bytes","bytesFromBase64","base64FromBytes","self","window","global","atob","b64","Buffer","from","bin","charCodeAt","btoa","byte","fromCharCode","createBaseCoin","Coin","VoteOption","voteOptionFromJSON","VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO","UNRECOGNIZED","voteOptionToJSON","ProposalStatus","createBaseWeightedVoteOption","option","weight","WeightedVoteOption","createBaseMsgSubmitProposal","content","initialDeposit","proposer","MsgSubmitProposal","createBaseMsgVote","proposalId","UZERO","voter","MsgVote","uint64","createBaseMsgVoteWeighted","options","MsgVoteWeighted","createBaseMsgDeposit","depositor","MsgDeposit","MsgSubmitProposal_pb","TYPE_URL","MsgDeposit_pb","MsgVote_pb","MsgVoteWeighted_pb","BlockIDFlag","SignedMsgType","BondStatus","createBaseCommissionRates","rate","maxRate","maxChangeRate","CommissionRates","createBaseDescription","moniker","identity","website","securityContact","details","Description","createBaseMsgCreateValidator","commission","minSelfDelegation","delegatorAddress","validatorAddress","pubkey","MsgCreateValidator","createBaseMsgEditValidator","commissionRate","MsgEditValidator","createBaseMsgDelegate","MsgDelegate","createBaseMsgBeginRedelegate","validatorSrcAddress","validatorDstAddress","MsgBeginRedelegate","createBaseMsgUndelegate","MsgUndelegate","MsgCreateValidator_pb","MsgEditValidator_pb","MsgDelegate_pb","MsgBeginRedelegate_pb","MsgUndelegate_pb","createBasePubKey","PubKey","createBaseCompactBitArray","extraBitsStored","elems","CompactBitArray","SignMode","signModeFromJSON","SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_LEGACY_AMINO_JSON","signModeToJSON","createBaseTxRaw","bodyBytes","authInfoBytes","signatures","TxRaw","createBaseSignDoc","accountNumber","SignDoc","createBaseAuthInfo","signerInfos","AuthInfo","SignerInfo","Fee","createBaseSignerInfo","publicKey","modeInfo","sequence","ModeInfo","createBaseModeInfo","single","multi","ModeInfo_Single","ModeInfo_Multi","createBaseModeInfo_Single","createBaseModeInfo_Multi","bitarray","modeInfos","createBaseFee","gasLimit","payer","granter","SIGN_DIRECT","defaultFee","gas","TxClient","apiClient","rpcUrl","signer","registry","invariant","registryTypes","Proto","Registry","getSender","account","base_account","account_number","getAccounts","parseInt","sendTransaction","messages","memo","sender","signInfoDirect","createSignerInfo","feeMessage","createFee","authInfoDirect","createAuthInfo","_messages","body","createTxBodyEncodeObject","signDocDirect","createSigDoc","finish","SigningStargateClient","connectWithSigner","walletClient","signDirect","signed","signature","txRaw","fromBase64","txBytes","broadcastTx","results","signerInfo"],"mappings":"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"}