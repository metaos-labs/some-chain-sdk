{"version":3,"file":"some-chain-sdk.cjs.production.min.js","sources":["../src/constants/fee.ts","../src/api/APIRequester.ts","../src/api/BaseAPI.ts","../src/api/BankAPI.ts","../src/api/AuthAPI.ts","../src/api/SwapAPI.ts","../src/api/TxAPI.ts","../src/constants/tokenlist.default.ts","../src/types/ICommon.ts","../src/constants/network.ts","../src/constants/precision.ts","../src/constants/tick.ts","../src/utils/formatCurrencyAmount.ts","../src/utils/isNumberic.ts","../src/utils/sort.ts","../src/utils/formatMoment.ts","../src/core/LiquidityMath.ts","../src/core/TickMath.ts","../src/msgs/BaseMsg.ts","../src/proto/google/protobuf/timestamp.ts","../src/proto/swap/tx.ts","../src/msgs/SwapMsg.ts","../src/proto/google/protobuf/any.ts","../src/proto/cosmos/crypto/secp256k1/keys.ts","../src/proto/cosmos/crypto/multisig/v1beta1/multisig.ts","../src/proto/cosmos/tx/signing/v1beta1/signing.ts","../src/proto/cosmos/base/v1beta1/coin.ts","../src/proto/cosmos/tx/v1beta1/tx.ts","../src/clients/TxClient.ts","../src/clients/APIClient.ts","../src/constants/date.ts","../src/core/TransactionLooper.ts","../src/constants/number.ts","../src/utils/parseToMap.ts","../src/utils/decimalNumber.ts","../src/utils/deepCopy.ts","../src/utils/mathUtil.ts","../src/utils/encrypt.ts","../src/utils/findToken.ts","../src/utils/getToPercent.ts","../src/utils/getPoolAddress.ts","../src/types/IWallet.ts","../src/utils/toPercent.ts","../src/utils/crypto.ts","../src/utils/formatPrice.ts"],"sourcesContent":["export enum Fee_Amount {\n  LOW = 500,\n  MEDIUM = 3000,\n  HIGH = 10000,\n}\n\nexport const FEE_AMOUNT_DETAIL: Record<\n  Fee_Amount,\n  { label: string; value: Fee_Amount; description: string }\n> = {\n  [Fee_Amount.LOW]: {\n    label: \"0.05\",\n    value: Fee_Amount.LOW,\n    description: \"Best for stable pairs.\",\n  },\n  [Fee_Amount.MEDIUM]: {\n    label: \"0.3\",\n    value: Fee_Amount.MEDIUM,\n    description: \"Best for most pairs.\",\n  },\n  [Fee_Amount.HIGH]: {\n    label: \"1\",\n    value: Fee_Amount.HIGH,\n    description: \"Best for exotic pairs.\",\n  },\n};\n","import Axios, { AxiosInstance } from \"axios\";\nimport { OrderBy } from \"../proto/cosmos/tx/v1beta1/service\";\n\nexport type APIParams = Record<string, string | number | null | undefined>;\n\nexport interface PaginationOptions {\n  \"pagination.limit\": string;\n  \"pagination.offset\": string;\n  \"pagination.key\": string;\n  \"pagination.count_total\": \"true\" | \"false\";\n  \"pagination.reverse\": \"true\" | \"false\";\n  order_by: keyof typeof OrderBy;\n}\n\nexport interface Pagination {\n  next_key: string | null;\n  total: number;\n}\n\nexport class APIRequester {\n  private axios: AxiosInstance;\n\n  constructor(baseURL: string) {\n    this.axios = Axios.create({\n      baseURL,\n      headers: {\n        Accept: \"application/json\",\n      },\n      timeout: 60000,\n    });\n  }\n\n  public async get<T>(\n    endpoint: string,\n    params: URLSearchParams | APIParams = {}\n  ): Promise<T> {\n    return this.axios.get(endpoint, { params }).then((d) => d.data);\n  }\n\n  public async post<T>(endpoint: string, data?: APIParams): Promise<T> {\n    return this.axios.post(endpoint, data).then((d) => d.data);\n  }\n}\n","import { APIRequester } from \"./APIRequester\";\n\nexport abstract class BaseAPI {\n  constructor(protected request: APIRequester) {}\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { IToken } from \"../types\";\n\nexport interface IResBalances {\n  balance: {\n    denom: string;\n    amount: string;\n  };\n}\n\nexport class BankAPI extends BaseAPI {\n  public async apiTokenBalance(\n    token: IToken,\n    accountAddress: string\n  ): Promise<IResBalances> {\n    return this.request.get<IResBalances>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}/by_denom`,\n      {\n        denom: token.denom,\n      }\n    );\n  }\n\n  public async apiAccountBalance(\n    accountAddress: string\n  ): Promise<IResBalances> {\n    return this.request.get<IResBalances>(\n      `/cosmos/bank/v1beta1/balances/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\n\nexport interface IResAccountInfo {\n  account: {\n    \"@type\": string;\n    base_account: {\n      address: string;\n      pub_key: {\n        \"@type\": string;\n        key: string;\n      };\n      account_number: string;\n      sequence: string;\n    };\n    code_hash: string;\n  };\n}\n\nexport class AuthAPI extends BaseAPI {\n  public async apiAccountInfo(\n    accountAddress: string\n  ): Promise<IResAccountInfo> {\n    return this.request.get<IResAccountInfo>(\n      `/cosmos/auth/v1beta1/accounts/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { ILiquidityPosition, IPool, IPoolPrice } from \"../types\";\n\nexport interface IResPoolInfo {\n  pool: IPool;\n  pool_slot0: IPoolPrice;\n}\n\nexport interface IResPoolMetadataNew {\n  [pool: string]: IPool;\n}\n\nexport interface IFarmV3 {\n  address: string;\n}\n\nexport interface IResFarmList {\n  activatingPool: Array<IFarmV3>;\n  pagination: {\n    next_key: null | string;\n    total: string;\n  };\n}\n\nexport interface IResLiquidityPositionList {\n  liquidity_positions: Array<ILiquidityPosition>;\n}\n\nexport class SwapAPI extends BaseAPI {\n  /**\n   * find pool list by address array\n   * @param addresses\n   */\n  public async apiPoolListByAddresses(\n    addresses: Array<string>\n  ): Promise<{ pool_slot0_aggregations: Array<IResPoolInfo> }> {\n    return this.request.get<{ pool_slot0_aggregations: Array<IResPoolInfo> }>(\n      `/sophon-labs/sophon/swap/pool_slot0_aggregations?${addresses.join(\"&\")}`\n    );\n  }\n\n  public async apiPoolMetadataByAddress(\n    address: string\n  ): Promise<IResPoolMetadataNew> {\n    return this.request.get<IResPoolMetadataNew>(\n      `/sophon-labs/sophon/swap/pools/${address}`\n    );\n  }\n\n  public async apiPoolMetadataPriceByAddress(\n    address: string\n  ): Promise<{ pool_slot0: IPoolPrice }> {\n    return this.request.get<{ pool_slot0: IPoolPrice }>(\n      `/sophon-labs/sophon/swap/pools/${address}/slot0`\n    );\n  }\n\n  public async apiLiquidityPositionById(\n    tokenId: string\n  ): Promise<{ liquidity_position: ILiquidityPosition }> {\n    return this.request.get<{ liquidity_position: ILiquidityPosition }>(\n      `/sophon-labs/sophon/swap/liquidity_positions/${tokenId}`\n    );\n  }\n\n  public async apiLiquidityRewardsByIds(\n    tokenIds: Array<string>\n  ): Promise<{ liquidity_positions: Array<ILiquidityPosition> }> {\n    return this.request.get<{ liquidity_positions: Array<ILiquidityPosition> }>(\n      `/sophon-labs/sophon/swap/liquidity_position_by_ids?${tokenIds.join(\"&\")}`\n    );\n  }\n\n  public async apiTickImagePath(tokenId: string): Promise<{ uri: string }> {\n    return this.request.get<{ uri: string }>(\n      `/sophon-labs/sophon/swap/liquidity_positions/${tokenId}/token_uri`\n    );\n  }\n\n  public async apiActiveFarmList(): Promise<IResFarmList> {\n    return this.request.get<IResFarmList>(\n      `/sophon-labs/sophon/swap/activating_pools`\n    );\n  }\n\n  public async apiLiquidityPositionList(\n    accountAddress: string\n  ): Promise<IResLiquidityPositionList> {\n    return this.request.get<IResLiquidityPositionList>(\n      `/sophon-labs/sophon/swap/liquidity_positions_owner/${accountAddress}`\n    );\n  }\n}\n","import { BaseAPI } from \"./BaseAPI\";\nimport { TxResponse } from \"../proto/cosmos/base/abci/v1beta1/abci\";\nimport {\n  BroadcastMode,\n  BroadcastTxRequest,\n  BroadcastTxResponse,\n} from \"../proto/cosmos/tx/v1beta1/service\";\n\nexport class TxAPI extends BaseAPI {\n  public async txInfo(txHash: string): Promise<TxResponse> {\n    return this.request.get<TxResponse>(`/cosmos/tx/v1beta1/txs/${txHash}`);\n  }\n\n  private async _broadcast<T>(\n    tx: BroadcastTxRequest,\n    mode: keyof typeof BroadcastMode\n  ): Promise<T> {\n    return this.request.post<any>(`/cosmos/tx/v1beta1/txs`);\n  }\n\n  public async broadcast(tx: BroadcastTxRequest): Promise<BroadcastTxResponse> {\n    return this._broadcast<BroadcastTxResponse>(tx, \"BROADCAST_MODE_BLOCK\");\n  }\n}\n","export default [\n  {\n    denom: \"usop\",\n    creator: \"\",\n    name: \"Sophon\",\n    symbol: \"SOP\",\n    totalSupply: \"2000000000000000000000000000\",\n    decimal: 18,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/2025.png\",\n  },\n  {\n    denom: \"useth\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"Ethereum\",\n    symbol: \"ETH\",\n    totalSupply: \"2000000000000000000000000\",\n    decimal: 18,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/1027.png\",\n  },\n  {\n    denom: \"ustake\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"STAKE\",\n    symbol: \"STAKE\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 8,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/5601.png\",\n  },\n  {\n    denom: \"ususdc\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"USDC\",\n    symbol: \"USDC\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 6,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/3408.png\",\n  },\n  {\n    denom: \"token/token1/3\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"token1\",\n    symbol: \"token1\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 18,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/4195.png\",\n  },\n  {\n    denom: \"token/token2/4\",\n    creator: \"sop17gxqqequrm2rmehknpataddssugl4ef6auunuc\",\n    name: \"token2\",\n    symbol: \"token2\",\n    totalSupply: \"200000000000000000000000000\",\n    decimal: 8,\n    logoURI: \"https://s2.coinmarketcap.com/static/img/coins/64x64/2280.png\",\n  },\n];\n","import { IToken } from \"./IToken\";\nimport { Fee_Amount } from \"../constants\";\n\nexport interface ITickProcessed {\n  tick: number;\n  liquidityActive: string;\n  liquidityNet: string;\n  price0: string;\n}\n\nexport interface ITickData {\n  tick_idx: number;\n  liquidity_gross: string;\n  liquidity_net: string;\n  price0: string;\n  price1: string;\n}\n\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\nexport enum Bound {\n  LOWER = \"LOWER\",\n  UPPER = \"UPPER\",\n}\n\nexport interface IFeeItem {\n  label: string;\n  value: Fee_Amount;\n  description: string;\n}\n\nexport enum Tip_Level {\n  Info = \"info\",\n  Warning = \"warning\",\n  Error = \"error\",\n}\n\nexport enum Swap_Direction {\n  In = \"exactIn\",\n  Out = \"exactOut\",\n}\n\nexport enum Transaction_Status {\n  Wallet = \"wallet\",\n  Pending = \"pending\",\n  Complete = \"complete\",\n  Success = \"success\",\n  Error = \"error\",\n  Reject = \"reject\",\n}\n\nexport interface ILiquidityPosition {\n  token_id: string;\n  address: string;\n  liquidity: string;\n  fee_growth_inside0_last: string;\n  fee_growth_inside1_last: string;\n  tokens_owed0: string;\n  tokens_owed1: string;\n  tick_lower: number;\n  tick_upper: number;\n  reward_growth_inside_lasts: Array<string>;\n  reward_oweds: Array<string>;\n}\n\nexport interface IPool {\n  address: string;\n  denom0: string;\n  denom1: string;\n  decimal0: number;\n  decimal1: number;\n  fee: number;\n  tick_spacing: number;\n  max_liquidity_per_tick: string;\n}\n\nexport interface IV3RewardConfig {\n  denom: string;\n  mintable: boolean;\n  operator: string;\n  reward_growth_global: string;\n  reward_per_second: string;\n  vault: string;\n  token?: IToken;\n  reward_per_day?: string;\n}\n\nexport interface IV3Reward extends IV3RewardConfig {\n  amount: string;\n  token?: IToken;\n}\n\nexport interface IPoolPrice {\n  address: string;\n  tick: number;\n  sqrt_price: string;\n  liquidity: string;\n  fee_growth_global0: string;\n  fee_growth_global1: string;\n  fee_protocol_owed0: string;\n  fee_protocol_owed1: string;\n  observation_index: number;\n  observation_cardinality: number;\n  observation_cardinality_next: number;\n  reward_configs: Array<IV3RewardConfig>;\n  reward_update_time_last: string;\n}\n\nexport interface IPoolMetaData extends IPool, IPoolPrice {}\n","export const ETH = \"eth\";\nexport const BSC = \"bsc\";\nexport const OEC = \"oec\";\nexport const HOO = \"hoo\";\nexport const XDAI = \"xdai\";\nexport const HECO = \"heco\";\nexport const POLYGON = \"polygon\";\nexport const FANTOM = \"fantom\";\nexport const KCC = \"kcc\";\nexport const AVALANCHE = \"avalanche\";\nexport const SOPHON = \"sop\";\n\nexport const ETH_CHAIN_NAME = \"Ethereum\";\nexport const BSC_CHAIN_NAME = \"Binance Smart Chain\";\nexport const OEC_CHAIN_NAME = \"OKEx Chain\";\nexport const HOO_CHAIN_NAME = \"Hoo Smart Chain\";\nexport const XDAI_CHAIN_NAME = \"xDAI\";\nexport const HECO_CHAIN_NAME = \"Huobi ECO Chain\";\nexport const POLYGON_CHAIN_NAME = \"Polygon\";\nexport const FANTOM_CHAIN_NAME = \"Fantom\";\nexport const KCC_CHAIN_NAME = \"KCC\";\nexport const AVALANCHE_CHAIN_NAME = \"Avalanche\";\nexport const SOPHON_TEST_CHAIN_NAME = \"Sophon Dev\";\n\nexport const ETH_NETWORK_ID = \"1\";\nexport const BSC_NETWORK_ID = \"56\";\nexport const BSC_NETWORK_TEST_ID = \"97\";\nexport const OEC_NETWORK_ID = \"66\";\nexport const HOO_NETWORK_ID = \"70\";\nexport const XDAI_NETWORK_ID = \"100\";\nexport const HECO_NETWORK_ID = \"128\";\nexport const POLYGON_NETWORK_ID = \"137\";\nexport const FANTOM_NETWORK_ID = \"250\";\nexport const KCC_NETWORK_ID = \"321\";\nexport const AVALANCHE_NETWORK_ID = \"43114\";\nexport const ETH_TEST_NETWORK_ID = \"2117\";\nexport const SOPHON_TEST_NETWORK_ID = \"118\";\n\nexport const ETH_CHAIN_ID = \"0x1\";\nexport const BSC_CHAIN_ID = \"0x38\";\nexport const BSC_CHAIN_ID_TEST = \"0x61\";\nexport const OEC_CHAIN_ID = \"0x42\";\nexport const HOO_CHAIN_ID = \"0x46\";\nexport const XDAI_CHAIN_ID = \"0x64\";\nexport const HECO_CHAIN_ID = \"0x80\";\nexport const POLYGON_CHAIN_ID = \"0x89\";\nexport const FANTOM_CHAIN_ID = \"0xfa\";\nexport const KCC_CHAIN_ID = \"0x141\";\nexport const AVALANCHE_CHAIN_ID = \"0xa86a\";\nexport const SOPHON_TEST_CHAIN_ID = \"sophond_9000-1\";\n\nexport const ETH_SYMBOL = \"ETH\";\nexport const BNB_SYMBOL = \"BNB\";\nexport const OKT_SYMBOL = \"OKT\";\nexport const HOO_SYMBOL = \"HOO\";\nexport const XDAI_SYMBOL = \"XDAI\";\nexport const HT_SYMBOL = \"HT\";\nexport const POLYGON_SYMBOL = \"MATIC\";\nexport const FANTOM_SYMBOL = \"FTM\";\nexport const KCC_SYMBOL = \"KCS\";\nexport const AVALANCHE_SYMBOL = \"AVAX\";\nexport const SOPHON_SYMBOL = \"SOP\";\n\nexport const SUPPORTED_CHAIN_IDS = [ETH_NETWORK_ID, SOPHON_TEST_NETWORK_ID];\n\nexport const NETWORK_MAP = {\n  [ETH_NETWORK_ID]: {\n    networkId: ETH_NETWORK_ID,\n    chainId: ETH_CHAIN_ID,\n    chainName: ETH_CHAIN_NAME,\n    providerType: ETH,\n    ticker: ETH_SYMBOL,\n  },\n  [BSC_NETWORK_ID]: {\n    networkId: BSC_NETWORK_ID,\n    chainId: BSC_CHAIN_ID,\n    chainName: BSC_CHAIN_NAME,\n    providerType: BSC,\n    ticker: BNB_SYMBOL,\n  },\n  [BSC_NETWORK_TEST_ID]: {\n    networkId: BSC_NETWORK_TEST_ID,\n    chainId: BSC_CHAIN_ID_TEST,\n    chainName: BSC_CHAIN_NAME,\n    providerType: BSC,\n    ticker: BNB_SYMBOL,\n  },\n  [OEC_NETWORK_ID]: {\n    networkId: OEC_NETWORK_ID,\n    chainId: OEC_CHAIN_ID,\n    chainName: OEC_CHAIN_NAME,\n    providerType: OEC,\n    ticker: OKT_SYMBOL,\n  },\n  [HOO_NETWORK_ID]: {\n    networkId: HOO_NETWORK_ID,\n    chainId: HOO_CHAIN_ID,\n    chainName: HOO_CHAIN_NAME,\n    providerType: HOO,\n    ticker: HOO_SYMBOL,\n  },\n  [XDAI_NETWORK_ID]: {\n    networkId: XDAI_NETWORK_ID,\n    chainId: XDAI_CHAIN_ID,\n    chainName: XDAI_CHAIN_NAME,\n    providerType: XDAI,\n    ticker: XDAI_SYMBOL,\n  },\n  [HECO_NETWORK_ID]: {\n    networkId: HECO_NETWORK_ID,\n    chainId: HECO_CHAIN_ID,\n    chainName: HECO_CHAIN_NAME,\n    providerType: HECO,\n    ticker: HT_SYMBOL,\n  },\n  [POLYGON_NETWORK_ID]: {\n    networkId: POLYGON_NETWORK_ID,\n    chainId: POLYGON_CHAIN_ID,\n    chainName: POLYGON_CHAIN_NAME,\n    providerType: POLYGON,\n    ticker: POLYGON_SYMBOL,\n  },\n  [FANTOM_NETWORK_ID]: {\n    networkId: FANTOM_NETWORK_ID,\n    chainId: FANTOM_CHAIN_ID,\n    chainName: FANTOM_CHAIN_NAME,\n    providerType: FANTOM,\n    ticker: FANTOM_SYMBOL,\n  },\n  [KCC_NETWORK_ID]: {\n    networkId: KCC_NETWORK_ID,\n    chainId: KCC_CHAIN_ID,\n    chainName: KCC_CHAIN_NAME,\n    providerType: KCC,\n    ticker: KCC_SYMBOL,\n  },\n  [AVALANCHE_NETWORK_ID]: {\n    networkId: AVALANCHE_NETWORK_ID,\n    chainId: AVALANCHE_CHAIN_ID,\n    chainName: AVALANCHE_CHAIN_NAME,\n    providerType: AVALANCHE,\n    ticker: AVALANCHE_SYMBOL,\n  },\n  [SOPHON_TEST_NETWORK_ID]: {\n    networkId: SOPHON_TEST_NETWORK_ID,\n    chainId: SOPHON_TEST_CHAIN_ID,\n    chainName: SOPHON_TEST_CHAIN_NAME,\n    providerType: SOPHON,\n    ticker: SOPHON_SYMBOL,\n  },\n};\n\nexport const CONFIG_CHAIN_SOPHON = {\n  RPC_URL: \"\",\n  REST_URL: \"\",\n  EXPLORER_URL: \"https://explorer.evmos.org\",\n  NETWORK_NAME: \"Sophon TestNet\",\n  NETWORK_TYPE: \"testnet\",\n  CHAIN_ID: \"sophon_99237-1\",\n  CHAIN_NAME: \"Sophon Dev\",\n  COIN_DENOM: \"usop\",\n  COIN_MINIMAL_DENOM: \"SOP\",\n  COIN_DECIMALS: 18,\n  PREFIX: \"sophon\",\n  COIN_TYPE: 118,\n  COINGECKO_ID: \"sophon\",\n  DEFAULT_GAS: 1000000000,\n  GAS_PRICE_STEP_LOW: 0.005,\n  GAS_PRICE_STEP_AVERAGE: 0.025,\n  GAS_PRICE_STEP_HIGH: 0.08,\n  FEATURES: [\"stargate\", \"ibc-transfer\", \"sophon\"],\n};\n\nexport const CHAIN_ETH = {\n  chainId: \"0x1\",\n  name: \"Ethereum\",\n  logoURI:\n    \"https://assets.trustwalletapp.com/blockchains/smartchain/assets/0x2170Ed0880ac9A755fd29B2688956BD959F933F8/logo.png\",\n  symbol: \"ETH\",\n};\n\nexport const CHAIN_SOP = {\n  chainId: \"sophon\",\n  name: \"Sophon\",\n  logoURI:\n    \"https://assets.trustwalletapp.com/blockchains/smartchain/assets/0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51/logo.png\",\n  symbol: \"sop\",\n};\n","export const DEFAULT_USER_PRECISION = 6;\n\nexport const DEFAULT_PRECISION = 18;\n\nexport const MAX_PRECISION = 28;\n\nexport const REG_NUMBER = new RegExp(\n  \"^[1-9]+[0-9]*(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n\nexport const REG_DECIMAL_SIMPLE = /^\\d*(\\.\\d*)?$/;\n\nexport const REG_DECIMAL = new RegExp(\n  \"^0(\\\\.\\\\d{0,\" + DEFAULT_PRECISION + \"})?$\"\n);\n","export const TICK_SPACINGS = {\n  500: 10,\n  3000: 60,\n  10000: 200,\n};\n\nexport const BASE_UNIT_TICK = 1.0001;\n","import Decimal from \"decimal.js\";\nimport { Decimal as CosmosDecimal } from \"@cosmjs/math\";\nimport {\n  DEFAULT_PRECISION,\n  DEFAULT_USER_PRECISION,\n  MAX_PRECISION,\n} from \"../constants\";\n\nexport function toDecimalPlaces(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION\n) {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_UP)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountString(\n  value: Decimal.Value | undefined = \"\",\n  precision: number = DEFAULT_USER_PRECISION,\n  roundingMode: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  try {\n    return new Decimal(value)\n      .toSignificantDigits(precision, roundingMode)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function toAmountFloor(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n): string {\n  return toAmountString(value, precision, Decimal.ROUND_DOWN);\n}\n\nexport function toAmountCeil(\n  value: string | number,\n  precision: number = DEFAULT_USER_PRECISION\n) {\n  return toAmountString(value, precision, Decimal.ROUND_UP);\n}\n\nexport function toAmountFee(\n  value: string | number,\n  precision: number = DEFAULT_PRECISION\n): string {\n  try {\n    return new Decimal(value)\n      .toDecimalPlaces(precision, Decimal.ROUND_DOWN)\n      .toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport function isEmptyAmount(\n  value: Decimal.Value,\n  precision: number = MAX_PRECISION\n): boolean {\n  const _value = new Decimal(value).mul(Math.pow(10, precision)).floor();\n  return _value.isZero();\n}\n\nexport function toExactAmount(\n  value: string,\n  precision = MAX_PRECISION\n): string {\n  try {\n    return CosmosDecimal.fromUserInput(value, precision).toString();\n  } catch (e) {\n    return String(value || \"-\");\n  }\n}\n\nexport const formatNumber = (\n  value: Decimal.Value,\n  seperator: number = 3,\n  fixed: number = 2\n) => {\n  return `${new Decimal(value)\n    .div(new Decimal(10).pow(seperator))\n    .toFixed(fixed)}k`;\n};\n","import { REG_DECIMAL, REG_NUMBER, ZERO } from \"../constants\";\nimport Decimal from \"decimal.js\";\n\nexport function isNumeric(value: string) {\n  return !isNaN(parseFloat(value));\n  // return new Decimal(value).lessThan(ZERO);\n}\n\nexport function checkInputNumber(value: string) {\n  if (REG_NUMBER.test(value) || REG_DECIMAL.test(value) === true) {\n    return true;\n  }\n  return false;\n}\n","import { IToken } from \"../types\";\n\nexport function sortsBefore(baseToken: IToken, quoteToken: IToken) {\n  return baseToken.denom.toLowerCase() < quoteToken.denom.toLowerCase();\n}\n","import moment from \"moment\";\n\nmoment.locale(\"en-ca\");\n\nexport function formatMoment(value: string, pattern = \"YYYY/MM/DD HH:mm:ss\") {\n  return moment(+value).format(pattern);\n}\n\nexport function formatUnixMoment(value: string, pattern = \"MM/DD HH:mm:ss\") {\n  return moment(+value * 1000).format(pattern);\n}\n\nexport const formatTime = (time: string) => {\n  return moment(time).format(\"YYYY-MM-DD HH:mm:ss\");\n};\n\nexport const formatDiffTime = (time: string) => {\n  return moment(time).fromNow();\n};\n","import { IToken } from \"../types\";\nimport { toDecimalPlaces } from \"../utils\";\nimport Decimal from \"decimal.js\";\n\nexport class LiquidityMath {\n  private static getRightSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(leftRangeValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return numerator.div(denominator);\n  }\n\n  private static getLeftSideLiquidity(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount: string\n  ): Decimal {\n    const numerator = new Decimal(amount);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(rightRangeValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return numerator.div(denominator);\n  }\n\n  public static getLiquidityFromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n    if (pc.lessThan(leftRangeValue) === true) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    } else if (pc.greaterThan(rightRangeValue) === true) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount0\n      );\n    }\n    const deltaX = new Decimal(amount0);\n    const _value1 = new Decimal(1).div(Decimal.sqrt(priceValue));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(rightRangeValue));\n    const denominator = Decimal.sub(_value1, _value2);\n    return deltaX.div(denominator);\n  }\n\n  private static _getDiverForDeltaX(\n    lower: number | string,\n    upper: number | string\n  ): Decimal {\n    const _value1 = new Decimal(1).div(Decimal.sqrt(lower));\n    const _value2 = new Decimal(1).div(Decimal.sqrt(upper));\n    return Decimal.sub(_value1, _value2);\n  }\n\n  private static _getDiverForDeltaY(\n    lower: number | string,\n    upper: number | string\n  ) {\n    return Decimal.sub(Decimal.sqrt(upper), Decimal.sqrt(lower));\n  }\n\n  public static getLiquidityFromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string\n  ): Decimal {\n    const pc = new Decimal(priceValue);\n\n    if (pc.lessThan(leftRangeValue) === true) {\n      return this.getRightSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    } else if (pc.greaterThan(rightRangeValue) === true) {\n      return this.getLeftSideLiquidity(\n        leftRangeValue,\n        rightRangeValue,\n        priceValue,\n        amount1\n      );\n    }\n\n    const deltaY = new Decimal(amount1);\n    const denominator = Decimal.sub(\n      Decimal.sqrt(priceValue),\n      Decimal.sqrt(leftRangeValue)\n    );\n    return deltaY.div(denominator);\n  }\n\n  public static getAmount1FromAmount0(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount0: string,\n    token0: IToken\n  ): string {\n    const liquidity = this.getLiquidityFromAmount0(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount0\n    );\n    console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmount0FromAmount1(\n    leftRangeValue: number, // pa\n    rightRangeValue: number, // pb\n    priceValue: number,\n    amount1: string,\n    token1: IToken\n  ): string {\n    const liquidity = this.getLiquidityFromAmount1(\n      leftRangeValue,\n      rightRangeValue,\n      priceValue,\n      amount1\n    );\n\n    console.log(\"liquidity: \" + liquidity);\n\n    const _value1 = new Decimal(liquidity);\n    const _value2 = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    return _value1.mul(_value2).toString();\n  }\n\n  public static getAmountByLiquidity(\n    leftRangeValue: number | string,\n    rightRangeValue: number | string,\n    priceValue: number | string,\n    liquidity: string,\n    token0: IToken,\n    token1: IToken\n  ): { amount0: string; amount1: string } {\n    const pc = new Decimal(priceValue);\n\n    const _value1 = new Decimal(liquidity);\n\n    if (pc.lessThan(leftRangeValue) === true) {\n      const _value2 = this._getDiverForDeltaX(leftRangeValue, rightRangeValue);\n      return {\n        amount0: toDecimalPlaces(_value1.mul(_value2), token0.decimal),\n        amount1: \"0\",\n      };\n    } else if (pc.greaterThan(rightRangeValue) === true) {\n      const _value2 = this._getDiverForDeltaY(leftRangeValue, rightRangeValue);\n      return {\n        amount0: \"0\",\n        amount1: toDecimalPlaces(_value1.mul(_value2), token1.decimal),\n      };\n    }\n    const deltaXDiver = this._getDiverForDeltaX(priceValue, rightRangeValue);\n    const deltaYDiver = this._getDiverForDeltaY(leftRangeValue, priceValue);\n    return {\n      amount0: toDecimalPlaces(_value1.mul(deltaXDiver), token0.decimal),\n      amount1: toDecimalPlaces(_value1.mul(deltaYDiver), token1.decimal),\n    };\n  }\n}\n","import invariant from \"tiny-invariant\";\nimport Decimal from \"decimal.js\";\nimport { Fee_Amount, TICK_SPACINGS, BASE_UNIT_TICK } from \"../constants\";\nimport { IToken } from \"../types\";\nimport { sortsBefore, toAmountString } from \"../utils\";\n\nexport class TickMath {\n  public static INVALID_TICK = -99999999;\n\n  public static MIN_TICK = -887272;\n\n  public static MIN_TICK_VALUE = \"0\";\n\n  public static MAX_TICK: number = -TickMath.MIN_TICK;\n\n  public static MAX_TICK_VALUE = \"âˆž\";\n\n  public static nearestUsableTick = (\n    tick: number,\n    tickSpacing: number\n  ): number => {\n    const rounded = Math.round(tick / tickSpacing) * tickSpacing;\n    if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;\n    else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;\n    else return rounded;\n  };\n\n  private static priceToClosestTick(price: string): number {\n    const numerator = Decimal.log2(Decimal.sqrt(price));\n    const denominator = Decimal.log2(Decimal.sqrt(BASE_UNIT_TICK));\n    return numerator.div(denominator).toNumber();\n  }\n\n  /**\n   * Compute nearest tick of price for input\n   * @param feeAmount\n   * @param value\n   */\n  public static getNearestTickByPrice(\n    feeAmount: Fee_Amount,\n    value: string\n  ): number {\n    const _value = value.trim();\n    if (_value === \"\") {\n      return this.INVALID_TICK;\n    }\n    if (value === this.MIN_TICK_VALUE) {\n      return this.MIN_TICK;\n    }\n    if (value === this.MAX_TICK_VALUE) {\n      return this.MAX_TICK;\n    }\n    const tick: number = this.priceToClosestTick(value);\n    // console.log(`[priceToClosestTick]: ` + tick);\n    const result = this.nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n    // console.log(`[nearestUsableTick]: ` + result);\n    return result;\n  }\n\n  public static getFormattedPriceByTick(\n    tick: Decimal.Value,\n    fee: Fee_Amount\n  ): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    if (this.isLowestTick(tick, fee)) {\n      return this.MIN_TICK_VALUE;\n    }\n    if (this.isHighestTick(tick, fee)) {\n      return this.MAX_TICK_VALUE;\n    }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getPriceByTick(tick: Decimal.Value): string {\n    if (tick === this.INVALID_TICK) {\n      return \"\";\n    }\n    // if (this.isLowestTick(tick, fee)) {\n    //   return this.MIN_TICK_VALUE;\n    // }\n    // if (this.isHighestTick(tick, fee)) {\n    //   return this.MAX_TICK_VALUE;\n    // }\n    const base = Decimal.pow(Decimal.sqrt(BASE_UNIT_TICK), tick);\n    return Decimal.pow(base, 2).toString();\n  }\n\n  public static getNearestPriceByInput(\n    feeAmount: Fee_Amount,\n    price: string\n  ): string {\n    // console.log('INPUT price: ' + price);\n    const nearestTick = this.getNearestTickByPrice(feeAmount, price);\n    const result = this.getPriceByTick(nearestTick);\n    // console.log('getPriceByTick: ' + result);\n    // console.log('==========');\n    return toAmountString(result);\n  }\n\n  public static getPriceBySqrtPrice(sqrtPrice: string): string {\n    if (!sqrtPrice) {\n      return \"\";\n    }\n    if (sqrtPrice === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(sqrtPrice).pow(2).toString();\n  }\n\n  public static getSqrtPriceByPrice(price: string): string {\n    if (price === \"0\") {\n      return \"0\";\n    }\n    return new Decimal(price).sqrt().toString();\n  }\n\n  public static getBaseTickRange(\n    fromToken: IToken,\n    toToken: IToken,\n    fee: Fee_Amount,\n    leftRange: string,\n    rightRange: string\n  ): { tickLower: number; tickUpper: number } {\n    let tickLower: number;\n    let tickUpper: number;\n    if (sortsBefore(fromToken, toToken)) {\n      tickLower =\n        leftRange === TickMath.MIN_TICK_VALUE\n          ? TickMath.getNearestLowestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, leftRange);\n      tickUpper =\n        rightRange === TickMath.MAX_TICK_VALUE\n          ? TickMath.getNearestHighestTick(fee)\n          : TickMath.getNearestTickByPrice(fee, rightRange);\n    } else {\n      if (leftRange === TickMath.MIN_TICK_VALUE) {\n        tickUpper = TickMath.getNearestHighestTick(fee);\n      } else {\n        tickUpper = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(leftRange).toString()\n        );\n      }\n      if (rightRange === TickMath.MAX_TICK_VALUE) {\n        tickLower = TickMath.getNearestLowestTick(fee);\n      } else {\n        tickLower = TickMath.getNearestTickByPrice(\n          fee,\n          new Decimal(1).div(rightRange).toString()\n        );\n      }\n    }\n    console.log(\"tickLower: \" + tickLower);\n    console.log(\"tickUpper: \" + tickUpper);\n    return {\n      tickLower,\n      tickUpper,\n    };\n  }\n\n  public static getNearestLowestTick(fee: Fee_Amount): number {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestLowestTick: ' + tickLower);\n    return tickLower;\n  }\n\n  public static getNearestHighestTick(fee: Fee_Amount): number {\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    // console.log('getNearestHighestTick: ' + tickUpper);\n    return tickUpper;\n  }\n\n  public static getNearestPricesByFullTick(fee: Fee_Amount): {\n    lowestPrice: string;\n    highestPrice: string;\n  } {\n    const tickLower = this.nearestUsableTick(this.MIN_TICK, TICK_SPACINGS[fee]);\n    const tickUpper = this.nearestUsableTick(this.MAX_TICK, TICK_SPACINGS[fee]);\n    const lowestPrice = this.getPriceByTick(tickLower);\n    const highestPrice = this.getPriceByTick(tickUpper);\n    return {\n      lowestPrice,\n      highestPrice,\n    };\n  }\n\n  public static isHighestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const highestTick = this.getNearestHighestTick(fee);\n    return tick >= highestTick;\n  }\n\n  public static isLowestTick(tick: Decimal.Value, fee: Fee_Amount): boolean {\n    const lowestTick = this.getNearestLowestTick(fee);\n    return tick <= lowestTick;\n  }\n}\n","import { EncodeObject, TxBodyEncodeObject } from \"@cosmjs/proto-signing\";\n\nexport abstract class BaseMsg {\n  constructor() {}\n  public abstract generateMessage(): EncodeObject;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n * ) to obtain a formatter capable of generating timestamps in this format.\n */\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: Long;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseTimestamp(): Timestamp {\n  return { seconds: Long.ZERO, nanos: 0 };\n}\n\nexport const Timestamp = {\n  encode(\n    message: Timestamp,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (!message.seconds.isZero()) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Timestamp {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = reader.int64() as Long;\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Timestamp {\n    return {\n      seconds: isSet(object.seconds)\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Timestamp): unknown {\n    const obj: any = {};\n    message.seconds !== undefined &&\n      (obj.seconds = (message.seconds || Long.ZERO).toString());\n    message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(\n    object: I\n  ): Timestamp {\n    const message = createBaseTimestamp();\n    message.seconds =\n      object.seconds !== undefined && object.seconds !== null\n        ? Long.fromValue(object.seconds)\n        : Long.ZERO;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Timestamp } from \"../google/protobuf/timestamp\";\n\nexport const protobufPackage = \"sophonlabs.sophon.swap\";\n\nexport interface MsgCreatePool {\n  creator: string;\n  /** the denom of denom0 in the pool */\n  denom0: string;\n  /** the denom of denom1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the initial square root price of the poo */\n  sqrtPrice: string;\n}\n\nexport interface MsgCreatePoolResponse {}\n\nexport interface MsgCreatePosition {\n  creator: string;\n  /** the denom of token0 in the pool */\n  denom0: string;\n  /** the denom of token1 in the pool */\n  denom1: string;\n  /** the fee rate for the pool */\n  fee: number;\n  /** the price lower bound of the position */\n  tickLower: number;\n  /** the price higher bound of the position */\n  tickUpper: number;\n  /** the desired amount of denom0 in the position */\n  amount0Desired: string;\n  /** the desired amount of denom1 in the position */\n  amount1Desired: string;\n  /** the minimum amount that denom0 needs to add when slippage occurs */\n  amount0Min: string;\n  /** the minimum amount that denom1 needs to add when slippage occurs */\n  amount1Min: string;\n  /** the minted NFT holder address */\n  recipient: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgCreatePositionResponse {}\n\nexport interface MsgIncreaseLiquidity {\n  /** the message creator, with tokens paid for the message */\n  creator: string;\n  /** then id of the NFT for which liquidity is being increased */\n  tokenId: string;\n  /** the desired amount of denom0 to be spent */\n  amount0Desired: string;\n  /** the desired amount of denom1 to be spent */\n  amount1Desired: string;\n  /** the minimum amount of denom0 to spend, which serves as a slippage check */\n  amount0Min: string;\n  /** the minimum amount of denom1 to spend, which serves as a slippage check */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgIncreaseLiquidityResponse {}\n\nexport interface MsgDecreaseLiquidity {\n  creator: string;\n  /** then id of the NFT for which liquidity is being decreased */\n  tokenId: string;\n  /** the amount by which liquidity will be decreased */\n  liquidity: string;\n  /** the minimum amount of denom0 that should be accounted for the burned liquidity */\n  amount0Min: string;\n  /** the minimum amount of denom1 that should be accounted for the burned liquidity */\n  amount1Min: string;\n  /** the time by which the transaction must be included to effect the change */\n  deadline?: Date;\n}\n\nexport interface MsgDecreaseLiquidityResponse {}\n\nexport interface MsgCollect {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** the maximum amount of denom0 to collect */\n  amount0Max: string;\n  /** the maximum amount of denom1 to collect */\n  amount1Max: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectResponse {}\n\nexport interface MsgSwapExactIn {\n  creator: string;\n  recipient: string;\n  amountIn: string;\n  amountOutMin: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactInResponse {}\n\nexport interface MsgSwapExactOut {\n  creator: string;\n  recipient: string;\n  amountOut: string;\n  amountInMax: string;\n  denoms: string[];\n  fees: number[];\n  deadline?: Date;\n}\n\nexport interface MsgSwapExactOutResponse {}\n\nexport interface MsgCollectReward {\n  creator: string;\n  /** the id of the NFT for which tokens are being collected */\n  tokenId: string;\n  /** the address that should receive the tokens */\n  recipient: string;\n  /** whether to get only owed tokens. True means only get the tokens that are owed(less gas), false means trigger settlement first, then collect(more gas) */\n  collectOnly: boolean;\n}\n\nexport interface MsgCollectRewardResponse {}\n\nexport interface MsgCollectFeeProtocol {\n  creator: string;\n  /** the pool address */\n  address: string;\n}\n\nexport interface MsgCollectFeeProtocolResponse {}\n\nexport interface MsgGovCorePool {\n  creator: string;\n  address: string;\n  action: string;\n  triggerTime?: Date;\n}\n\nexport interface MsgGovCorePoolResponse {}\n\nfunction createBaseMsgCreatePool(): MsgCreatePool {\n  return { creator: \"\", denom0: \"\", denom1: \"\", fee: 0, sqrtPrice: \"\" };\n}\n\nexport const MsgCreatePool = {\n  encode(\n    message: MsgCreatePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.sqrtPrice !== \"\") {\n      writer.uint32(42).string(message.sqrtPrice);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.sqrtPrice = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      sqrtPrice: isSet(object.sqrtPrice) ? String(object.sqrtPrice) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCreatePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.sqrtPrice !== undefined && (obj.sqrtPrice = message.sqrtPrice);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePool>, I>>(\n    object: I\n  ): MsgCreatePool {\n    const message = createBaseMsgCreatePool();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.sqrtPrice = object.sqrtPrice ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePoolResponse(): MsgCreatePoolResponse {\n  return {};\n}\n\nexport const MsgCreatePoolResponse = {\n  encode(\n    _: MsgCreatePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePoolResponse>, I>>(\n    _: I\n  ): MsgCreatePoolResponse {\n    const message = createBaseMsgCreatePoolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePosition(): MsgCreatePosition {\n  return {\n    creator: \"\",\n    denom0: \"\",\n    denom1: \"\",\n    fee: 0,\n    tickLower: 0,\n    tickUpper: 0,\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    recipient: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgCreatePosition = {\n  encode(\n    message: MsgCreatePosition,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.denom0 !== \"\") {\n      writer.uint32(18).string(message.denom0);\n    }\n    if (message.denom1 !== \"\") {\n      writer.uint32(26).string(message.denom1);\n    }\n    if (message.fee !== 0) {\n      writer.uint32(32).int32(message.fee);\n    }\n    if (message.tickLower !== 0) {\n      writer.uint32(40).int32(message.tickLower);\n    }\n    if (message.tickUpper !== 0) {\n      writer.uint32(48).int32(message.tickUpper);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(58).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(66).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(74).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(82).string(message.amount1Min);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(90).string(message.recipient);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(98).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreatePosition {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePosition();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.denom0 = reader.string();\n          break;\n        case 3:\n          message.denom1 = reader.string();\n          break;\n        case 4:\n          message.fee = reader.int32();\n          break;\n        case 5:\n          message.tickLower = reader.int32();\n          break;\n        case 6:\n          message.tickUpper = reader.int32();\n          break;\n        case 7:\n          message.amount0Desired = reader.string();\n          break;\n        case 8:\n          message.amount1Desired = reader.string();\n          break;\n        case 9:\n          message.amount0Min = reader.string();\n          break;\n        case 10:\n          message.amount1Min = reader.string();\n          break;\n        case 11:\n          message.recipient = reader.string();\n          break;\n        case 12:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCreatePosition {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      denom0: isSet(object.denom0) ? String(object.denom0) : \"\",\n      denom1: isSet(object.denom1) ? String(object.denom1) : \"\",\n      fee: isSet(object.fee) ? Number(object.fee) : 0,\n      tickLower: isSet(object.tickLower) ? Number(object.tickLower) : 0,\n      tickUpper: isSet(object.tickUpper) ? Number(object.tickUpper) : 0,\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgCreatePosition): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.denom0 !== undefined && (obj.denom0 = message.denom0);\n    message.denom1 !== undefined && (obj.denom1 = message.denom1);\n    message.fee !== undefined && (obj.fee = Math.round(message.fee));\n    message.tickLower !== undefined &&\n      (obj.tickLower = Math.round(message.tickLower));\n    message.tickUpper !== undefined &&\n      (obj.tickUpper = Math.round(message.tickUpper));\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePosition>, I>>(\n    object: I\n  ): MsgCreatePosition {\n    const message = createBaseMsgCreatePosition();\n    message.creator = object.creator ?? \"\";\n    message.denom0 = object.denom0 ?? \"\";\n    message.denom1 = object.denom1 ?? \"\";\n    message.fee = object.fee ?? 0;\n    message.tickLower = object.tickLower ?? 0;\n    message.tickUpper = object.tickUpper ?? 0;\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgCreatePositionResponse(): MsgCreatePositionResponse {\n  return {};\n}\n\nexport const MsgCreatePositionResponse = {\n  encode(\n    _: MsgCreatePositionResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCreatePositionResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCreatePositionResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCreatePositionResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCreatePositionResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCreatePositionResponse>, I>>(\n    _: I\n  ): MsgCreatePositionResponse {\n    const message = createBaseMsgCreatePositionResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidity(): MsgIncreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    amount0Desired: \"\",\n    amount1Desired: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgIncreaseLiquidity = {\n  encode(\n    message: MsgIncreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.amount0Desired !== \"\") {\n      writer.uint32(26).string(message.amount0Desired);\n    }\n    if (message.amount1Desired !== \"\") {\n      writer.uint32(34).string(message.amount1Desired);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(42).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(50).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.amount0Desired = reader.string();\n          break;\n        case 4:\n          message.amount1Desired = reader.string();\n          break;\n        case 5:\n          message.amount0Min = reader.string();\n          break;\n        case 6:\n          message.amount1Min = reader.string();\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgIncreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      amount0Desired: isSet(object.amount0Desired)\n        ? String(object.amount0Desired)\n        : \"\",\n      amount1Desired: isSet(object.amount1Desired)\n        ? String(object.amount1Desired)\n        : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgIncreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.amount0Desired !== undefined &&\n      (obj.amount0Desired = message.amount0Desired);\n    message.amount1Desired !== undefined &&\n      (obj.amount1Desired = message.amount1Desired);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidity>, I>>(\n    object: I\n  ): MsgIncreaseLiquidity {\n    const message = createBaseMsgIncreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.amount0Desired = object.amount0Desired ?? \"\";\n    message.amount1Desired = object.amount1Desired ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgIncreaseLiquidityResponse(): MsgIncreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgIncreaseLiquidityResponse = {\n  encode(\n    _: MsgIncreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgIncreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgIncreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgIncreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgIncreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgIncreaseLiquidityResponse {\n    const message = createBaseMsgIncreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidity(): MsgDecreaseLiquidity {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    liquidity: \"\",\n    amount0Min: \"\",\n    amount1Min: \"\",\n    deadline: undefined,\n  };\n}\n\nexport const MsgDecreaseLiquidity = {\n  encode(\n    message: MsgDecreaseLiquidity,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.liquidity !== \"\") {\n      writer.uint32(26).string(message.liquidity);\n    }\n    if (message.amount0Min !== \"\") {\n      writer.uint32(34).string(message.amount0Min);\n    }\n    if (message.amount1Min !== \"\") {\n      writer.uint32(42).string(message.amount1Min);\n    }\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(50).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidity {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.liquidity = reader.string();\n          break;\n        case 4:\n          message.amount0Min = reader.string();\n          break;\n        case 5:\n          message.amount1Min = reader.string();\n          break;\n        case 6:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDecreaseLiquidity {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      liquidity: isSet(object.liquidity) ? String(object.liquidity) : \"\",\n      amount0Min: isSet(object.amount0Min) ? String(object.amount0Min) : \"\",\n      amount1Min: isSet(object.amount1Min) ? String(object.amount1Min) : \"\",\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgDecreaseLiquidity): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.liquidity !== undefined && (obj.liquidity = message.liquidity);\n    message.amount0Min !== undefined && (obj.amount0Min = message.amount0Min);\n    message.amount1Min !== undefined && (obj.amount1Min = message.amount1Min);\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidity>, I>>(\n    object: I\n  ): MsgDecreaseLiquidity {\n    const message = createBaseMsgDecreaseLiquidity();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.liquidity = object.liquidity ?? \"\";\n    message.amount0Min = object.amount0Min ?? \"\";\n    message.amount1Min = object.amount1Min ?? \"\";\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgDecreaseLiquidityResponse(): MsgDecreaseLiquidityResponse {\n  return {};\n}\n\nexport const MsgDecreaseLiquidityResponse = {\n  encode(\n    _: MsgDecreaseLiquidityResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgDecreaseLiquidityResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgDecreaseLiquidityResponse {\n    return {};\n  },\n\n  toJSON(_: MsgDecreaseLiquidityResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgDecreaseLiquidityResponse>, I>>(\n    _: I\n  ): MsgDecreaseLiquidityResponse {\n    const message = createBaseMsgDecreaseLiquidityResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollect(): MsgCollect {\n  return {\n    creator: \"\",\n    tokenId: \"\",\n    recipient: \"\",\n    amount0Max: \"\",\n    amount1Max: \"\",\n    collectOnly: false,\n  };\n}\n\nexport const MsgCollect = {\n  encode(\n    message: MsgCollect,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.amount0Max !== \"\") {\n      writer.uint32(34).string(message.amount0Max);\n    }\n    if (message.amount1Max !== \"\") {\n      writer.uint32(42).string(message.amount1Max);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(48).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollect {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollect();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.amount0Max = reader.string();\n          break;\n        case 5:\n          message.amount1Max = reader.string();\n          break;\n        case 6:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollect {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amount0Max: isSet(object.amount0Max) ? String(object.amount0Max) : \"\",\n      amount1Max: isSet(object.amount1Max) ? String(object.amount1Max) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollect): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amount0Max !== undefined && (obj.amount0Max = message.amount0Max);\n    message.amount1Max !== undefined && (obj.amount1Max = message.amount1Max);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollect>, I>>(\n    object: I\n  ): MsgCollect {\n    const message = createBaseMsgCollect();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amount0Max = object.amount0Max ?? \"\";\n    message.amount1Max = object.amount1Max ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectResponse(): MsgCollectResponse {\n  return {};\n}\n\nexport const MsgCollectResponse = {\n  encode(\n    _: MsgCollectResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectResponse>, I>>(\n    _: I\n  ): MsgCollectResponse {\n    const message = createBaseMsgCollectResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactIn(): MsgSwapExactIn {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountIn: \"\",\n    amountOutMin: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactIn = {\n  encode(\n    message: MsgSwapExactIn,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountIn !== \"\") {\n      writer.uint32(26).string(message.amountIn);\n    }\n    if (message.amountOutMin !== \"\") {\n      writer.uint32(34).string(message.amountOutMin);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactIn {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactIn();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountIn = reader.string();\n          break;\n        case 4:\n          message.amountOutMin = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactIn {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountIn: isSet(object.amountIn) ? String(object.amountIn) : \"\",\n      amountOutMin: isSet(object.amountOutMin)\n        ? String(object.amountOutMin)\n        : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactIn): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountIn !== undefined && (obj.amountIn = message.amountIn);\n    message.amountOutMin !== undefined &&\n      (obj.amountOutMin = message.amountOutMin);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactIn>, I>>(\n    object: I\n  ): MsgSwapExactIn {\n    const message = createBaseMsgSwapExactIn();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountIn = object.amountIn ?? \"\";\n    message.amountOutMin = object.amountOutMin ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactInResponse(): MsgSwapExactInResponse {\n  return {};\n}\n\nexport const MsgSwapExactInResponse = {\n  encode(\n    _: MsgSwapExactInResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactInResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactInResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactInResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactInResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactInResponse>, I>>(\n    _: I\n  ): MsgSwapExactInResponse {\n    const message = createBaseMsgSwapExactInResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOut(): MsgSwapExactOut {\n  return {\n    creator: \"\",\n    recipient: \"\",\n    amountOut: \"\",\n    amountInMax: \"\",\n    denoms: [],\n    fees: [],\n    deadline: undefined,\n  };\n}\n\nexport const MsgSwapExactOut = {\n  encode(\n    message: MsgSwapExactOut,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(18).string(message.recipient);\n    }\n    if (message.amountOut !== \"\") {\n      writer.uint32(26).string(message.amountOut);\n    }\n    if (message.amountInMax !== \"\") {\n      writer.uint32(34).string(message.amountInMax);\n    }\n    for (const v of message.denoms) {\n      writer.uint32(42).string(v!);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.fees) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.deadline !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.deadline),\n        writer.uint32(58).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactOut {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOut();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.recipient = reader.string();\n          break;\n        case 3:\n          message.amountOut = reader.string();\n          break;\n        case 4:\n          message.amountInMax = reader.string();\n          break;\n        case 5:\n          message.denoms.push(reader.string());\n          break;\n        case 6:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.fees.push(reader.int32());\n            }\n          } else {\n            message.fees.push(reader.int32());\n          }\n          break;\n        case 7:\n          message.deadline = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgSwapExactOut {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      amountOut: isSet(object.amountOut) ? String(object.amountOut) : \"\",\n      amountInMax: isSet(object.amountInMax) ? String(object.amountInMax) : \"\",\n      denoms: Array.isArray(object?.denoms)\n        ? object.denoms.map((e: any) => String(e))\n        : [],\n      fees: Array.isArray(object?.fees)\n        ? object.fees.map((e: any) => Number(e))\n        : [],\n      deadline: isSet(object.deadline)\n        ? fromJsonTimestamp(object.deadline)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgSwapExactOut): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.amountOut !== undefined && (obj.amountOut = message.amountOut);\n    message.amountInMax !== undefined &&\n      (obj.amountInMax = message.amountInMax);\n    if (message.denoms) {\n      obj.denoms = message.denoms.map((e) => e);\n    } else {\n      obj.denoms = [];\n    }\n    if (message.fees) {\n      obj.fees = message.fees.map((e) => Math.round(e));\n    } else {\n      obj.fees = [];\n    }\n    message.deadline !== undefined &&\n      (obj.deadline = message.deadline.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOut>, I>>(\n    object: I\n  ): MsgSwapExactOut {\n    const message = createBaseMsgSwapExactOut();\n    message.creator = object.creator ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amountOut = object.amountOut ?? \"\";\n    message.amountInMax = object.amountInMax ?? \"\";\n    message.denoms = object.denoms?.map((e) => e) || [];\n    message.fees = object.fees?.map((e) => e) || [];\n    message.deadline = object.deadline ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgSwapExactOutResponse(): MsgSwapExactOutResponse {\n  return {};\n}\n\nexport const MsgSwapExactOutResponse = {\n  encode(\n    _: MsgSwapExactOutResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgSwapExactOutResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgSwapExactOutResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgSwapExactOutResponse {\n    return {};\n  },\n\n  toJSON(_: MsgSwapExactOutResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgSwapExactOutResponse>, I>>(\n    _: I\n  ): MsgSwapExactOutResponse {\n    const message = createBaseMsgSwapExactOutResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectReward(): MsgCollectReward {\n  return { creator: \"\", tokenId: \"\", recipient: \"\", collectOnly: false };\n}\n\nexport const MsgCollectReward = {\n  encode(\n    message: MsgCollectReward,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.tokenId !== \"\") {\n      writer.uint32(18).string(message.tokenId);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.collectOnly === true) {\n      writer.uint32(32).bool(message.collectOnly);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCollectReward {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectReward();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.tokenId = reader.string();\n          break;\n        case 3:\n          message.recipient = reader.string();\n          break;\n        case 4:\n          message.collectOnly = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectReward {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n      recipient: isSet(object.recipient) ? String(object.recipient) : \"\",\n      collectOnly: isSet(object.collectOnly)\n        ? Boolean(object.collectOnly)\n        : false,\n    };\n  },\n\n  toJSON(message: MsgCollectReward): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n    message.recipient !== undefined && (obj.recipient = message.recipient);\n    message.collectOnly !== undefined &&\n      (obj.collectOnly = message.collectOnly);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectReward>, I>>(\n    object: I\n  ): MsgCollectReward {\n    const message = createBaseMsgCollectReward();\n    message.creator = object.creator ?? \"\";\n    message.tokenId = object.tokenId ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.collectOnly = object.collectOnly ?? false;\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectRewardResponse(): MsgCollectRewardResponse {\n  return {};\n}\n\nexport const MsgCollectRewardResponse = {\n  encode(\n    _: MsgCollectRewardResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectRewardResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectRewardResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectRewardResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectRewardResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectRewardResponse>, I>>(\n    _: I\n  ): MsgCollectRewardResponse {\n    const message = createBaseMsgCollectRewardResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocol(): MsgCollectFeeProtocol {\n  return { creator: \"\", address: \"\" };\n}\n\nexport const MsgCollectFeeProtocol = {\n  encode(\n    message: MsgCollectFeeProtocol,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocol {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocol();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgCollectFeeProtocol {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n    };\n  },\n\n  toJSON(message: MsgCollectFeeProtocol): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocol>, I>>(\n    object: I\n  ): MsgCollectFeeProtocol {\n    const message = createBaseMsgCollectFeeProtocol();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgCollectFeeProtocolResponse(): MsgCollectFeeProtocolResponse {\n  return {};\n}\n\nexport const MsgCollectFeeProtocolResponse = {\n  encode(\n    _: MsgCollectFeeProtocolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgCollectFeeProtocolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgCollectFeeProtocolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgCollectFeeProtocolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgCollectFeeProtocolResponse>, I>>(\n    _: I\n  ): MsgCollectFeeProtocolResponse {\n    const message = createBaseMsgCollectFeeProtocolResponse();\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePool(): MsgGovCorePool {\n  return { creator: \"\", address: \"\", action: \"\", triggerTime: undefined };\n}\n\nexport const MsgGovCorePool = {\n  encode(\n    message: MsgGovCorePool,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.creator !== \"\") {\n      writer.uint32(10).string(message.creator);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(18).string(message.address);\n    }\n    if (message.action !== \"\") {\n      writer.uint32(26).string(message.action);\n    }\n    if (message.triggerTime !== undefined) {\n      Timestamp.encode(\n        toTimestamp(message.triggerTime),\n        writer.uint32(34).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MsgGovCorePool {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePool();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creator = reader.string();\n          break;\n        case 2:\n          message.address = reader.string();\n          break;\n        case 3:\n          message.action = reader.string();\n          break;\n        case 4:\n          message.triggerTime = fromTimestamp(\n            Timestamp.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgGovCorePool {\n    return {\n      creator: isSet(object.creator) ? String(object.creator) : \"\",\n      address: isSet(object.address) ? String(object.address) : \"\",\n      action: isSet(object.action) ? String(object.action) : \"\",\n      triggerTime: isSet(object.triggerTime)\n        ? fromJsonTimestamp(object.triggerTime)\n        : undefined,\n    };\n  },\n\n  toJSON(message: MsgGovCorePool): unknown {\n    const obj: any = {};\n    message.creator !== undefined && (obj.creator = message.creator);\n    message.address !== undefined && (obj.address = message.address);\n    message.action !== undefined && (obj.action = message.action);\n    message.triggerTime !== undefined &&\n      (obj.triggerTime = message.triggerTime.toISOString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePool>, I>>(\n    object: I\n  ): MsgGovCorePool {\n    const message = createBaseMsgGovCorePool();\n    message.creator = object.creator ?? \"\";\n    message.address = object.address ?? \"\";\n    message.action = object.action ?? \"\";\n    message.triggerTime = object.triggerTime ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseMsgGovCorePoolResponse(): MsgGovCorePoolResponse {\n  return {};\n}\n\nexport const MsgGovCorePoolResponse = {\n  encode(\n    _: MsgGovCorePoolResponse,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): MsgGovCorePoolResponse {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgGovCorePoolResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(_: any): MsgGovCorePoolResponse {\n    return {};\n  },\n\n  toJSON(_: MsgGovCorePoolResponse): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MsgGovCorePoolResponse>, I>>(\n    _: I\n  ): MsgGovCorePoolResponse {\n    const message = createBaseMsgGovCorePoolResponse();\n    return message;\n  },\n};\n\n/** Msg defines the Msg service. */\nexport interface Msg {\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse>;\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse>;\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse>;\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse>;\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse>;\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse>;\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse>;\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse>;\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse>;\n  /** this line is used by starport scaffolding # proto/tx/rpc */\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse>;\n}\n\nexport class MsgClientImpl implements Msg {\n  private readonly rpc: Rpc;\n\n  constructor(rpc: Rpc) {\n    this.rpc = rpc;\n    this.CreatePool = this.CreatePool.bind(this);\n    this.CreatePosition = this.CreatePosition.bind(this);\n    this.IncreaseLiquidity = this.IncreaseLiquidity.bind(this);\n    this.DecreaseLiquidity = this.DecreaseLiquidity.bind(this);\n    this.Collect = this.Collect.bind(this);\n    this.SwapExactIn = this.SwapExactIn.bind(this);\n    this.SwapExactOut = this.SwapExactOut.bind(this);\n    this.CollectReward = this.CollectReward.bind(this);\n    this.CollectFeeProtocol = this.CollectFeeProtocol.bind(this);\n    this.GovCorePool = this.GovCorePool.bind(this);\n  }\n\n  CreatePool(\n    request: DeepPartial<MsgCreatePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePoolResponse> {\n    return this.rpc.unary(\n      MsgCreatePoolDesc,\n      MsgCreatePool.fromPartial(request),\n      metadata\n    );\n  }\n\n  CreatePosition(\n    request: DeepPartial<MsgCreatePosition>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCreatePositionResponse> {\n    return this.rpc.unary(\n      MsgCreatePositionDesc,\n      MsgCreatePosition.fromPartial(request),\n      metadata\n    );\n  }\n\n  IncreaseLiquidity(\n    request: DeepPartial<MsgIncreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgIncreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgIncreaseLiquidityDesc,\n      MsgIncreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  DecreaseLiquidity(\n    request: DeepPartial<MsgDecreaseLiquidity>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgDecreaseLiquidityResponse> {\n    return this.rpc.unary(\n      MsgDecreaseLiquidityDesc,\n      MsgDecreaseLiquidity.fromPartial(request),\n      metadata\n    );\n  }\n\n  Collect(\n    request: DeepPartial<MsgCollect>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectResponse> {\n    return this.rpc.unary(\n      MsgCollectDesc,\n      MsgCollect.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactIn(\n    request: DeepPartial<MsgSwapExactIn>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactInResponse> {\n    return this.rpc.unary(\n      MsgSwapExactInDesc,\n      MsgSwapExactIn.fromPartial(request),\n      metadata\n    );\n  }\n\n  SwapExactOut(\n    request: DeepPartial<MsgSwapExactOut>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgSwapExactOutResponse> {\n    return this.rpc.unary(\n      MsgSwapExactOutDesc,\n      MsgSwapExactOut.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectReward(\n    request: DeepPartial<MsgCollectReward>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectRewardResponse> {\n    return this.rpc.unary(\n      MsgCollectRewardDesc,\n      MsgCollectReward.fromPartial(request),\n      metadata\n    );\n  }\n\n  CollectFeeProtocol(\n    request: DeepPartial<MsgCollectFeeProtocol>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgCollectFeeProtocolResponse> {\n    return this.rpc.unary(\n      MsgCollectFeeProtocolDesc,\n      MsgCollectFeeProtocol.fromPartial(request),\n      metadata\n    );\n  }\n\n  GovCorePool(\n    request: DeepPartial<MsgGovCorePool>,\n    metadata?: grpc.Metadata\n  ): Promise<MsgGovCorePoolResponse> {\n    return this.rpc.unary(\n      MsgGovCorePoolDesc,\n      MsgGovCorePool.fromPartial(request),\n      metadata\n    );\n  }\n}\n\nexport const MsgDesc = {\n  serviceName: \"sophonlabs.sophon.swap.Msg\",\n};\n\nexport const MsgCreatePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCreatePositionDesc: UnaryMethodDefinitionish = {\n  methodName: \"CreatePosition\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCreatePosition.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCreatePositionResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgIncreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"IncreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgIncreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgIncreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgDecreaseLiquidityDesc: UnaryMethodDefinitionish = {\n  methodName: \"DecreaseLiquidity\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgDecreaseLiquidity.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgDecreaseLiquidityResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectDesc: UnaryMethodDefinitionish = {\n  methodName: \"Collect\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollect.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactInDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactIn\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactIn.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactInResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgSwapExactOutDesc: UnaryMethodDefinitionish = {\n  methodName: \"SwapExactOut\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgSwapExactOut.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgSwapExactOutResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectRewardDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectReward\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectReward.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectRewardResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgCollectFeeProtocolDesc: UnaryMethodDefinitionish = {\n  methodName: \"CollectFeeProtocol\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgCollectFeeProtocol.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgCollectFeeProtocolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\nexport const MsgGovCorePoolDesc: UnaryMethodDefinitionish = {\n  methodName: \"GovCorePool\",\n  service: MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return MsgGovCorePool.encode(this).finish();\n    },\n  } as any,\n  responseType: {\n    deserializeBinary(data: Uint8Array) {\n      return {\n        ...MsgGovCorePoolResponse.decode(data),\n        toObject() {\n          return this;\n        },\n      };\n    },\n  } as any,\n};\n\ninterface UnaryMethodDefinitionishR\n  extends grpc.UnaryMethodDefinition<any, any> {\n  requestStream: any;\n  responseStream: any;\n}\n\ntype UnaryMethodDefinitionish = UnaryMethodDefinitionishR;\n\ninterface Rpc {\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any>;\n}\n\nexport class GrpcWebImpl {\n  private host: string;\n  private options: {\n    transport?: grpc.TransportFactory;\n\n    debug?: boolean;\n    metadata?: grpc.Metadata;\n  };\n\n  constructor(\n    host: string,\n    options: {\n      transport?: grpc.TransportFactory;\n\n      debug?: boolean;\n      metadata?: grpc.Metadata;\n    }\n  ) {\n    this.host = host;\n    this.options = options;\n  }\n\n  unary<T extends UnaryMethodDefinitionish>(\n    methodDesc: T,\n    _request: any,\n    metadata: grpc.Metadata | undefined\n  ): Promise<any> {\n    const request = { ..._request, ...methodDesc.requestType };\n    const maybeCombinedMetadata =\n      metadata && this.options.metadata\n        ? new BrowserHeaders({\n            ...this.options?.metadata.headersMap,\n            ...metadata?.headersMap,\n          })\n        : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage) as any;\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        },\n      });\n    });\n  }\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nfunction toTimestamp(date: Date): Timestamp {\n  const seconds = numberToLong(date.getTime() / 1_000);\n  const nanos = (date.getTime() % 1_000) * 1_000_000;\n  return { seconds, nanos };\n}\n\nfunction fromTimestamp(t: Timestamp): Date {\n  let millis = t.seconds.toNumber() * 1_000;\n  millis += t.nanos / 1_000_000;\n  return new Date(millis);\n}\n\nfunction fromJsonTimestamp(o: any): Date {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\n\nfunction numberToLong(number: number) {\n  return Long.fromNumber(number);\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import {\n  MsgCollect as MsgCollect_pb,\n  MsgCollectReward as MsgCollectReward_pb,\n  MsgCreatePool as MsgCreatePool_pb,\n  MsgCreatePosition as MsgCreatePosition_pb,\n  MsgDecreaseLiquidity as MsgDecreaseLiquidity_pb,\n  MsgIncreaseLiquidity as MsgIncreaseLiquidity_pb,\n  MsgSwapExactIn as MsgSwapExactIn_pb,\n  MsgSwapExactOut as MsgSwapExactOut_pb,\n  protobufPackage,\n} from \"../proto/swap/tx\";\nimport { BaseMsg } from \"./BaseMsg\";\nimport { EncodeObject } from \"@cosmjs/proto-signing\";\n\nexport class MsgCollectReward extends BaseMsg {\n  public protoMsg: MsgCollectReward_pb;\n  constructor(msg: MsgCollectReward_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePool.typeUrl,\n      value: MsgCollectReward_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollectReward {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollectReward`;\n  export const Proto = MsgCollectReward_pb;\n  export interface Proto extends MsgCollectReward_pb {}\n}\n\nexport class MsgSwapExactOut extends BaseMsg {\n  public protoMsg: MsgSwapExactOut_pb;\n  constructor(msg: MsgSwapExactOut_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactOut.typeUrl,\n      value: MsgSwapExactOut_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactOut {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactOut`;\n  export const Proto = MsgSwapExactOut_pb;\n  export interface Proto extends MsgSwapExactOut_pb {}\n}\n\nexport class MsgSwapExactIn extends BaseMsg {\n  public protoMsg: MsgSwapExactIn_pb;\n  constructor(msg: MsgSwapExactIn_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgSwapExactIn.typeUrl,\n      value: MsgSwapExactIn_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgSwapExactIn {\n  export const typeUrl: string = `/${protobufPackage}.MsgSwapExactIn`;\n  export const Proto = MsgSwapExactIn_pb;\n  export interface Proto extends MsgSwapExactIn_pb {}\n}\n\nexport class MsgCreatePool extends BaseMsg {\n  public protoMsg: MsgCreatePool_pb;\n  constructor(msg: MsgCreatePool_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePool.typeUrl,\n      value: MsgCreatePool_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePool {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePool`;\n  export const Proto = MsgCreatePool_pb;\n  export interface Proto extends MsgCreatePool_pb {}\n}\n\nexport class MsgCollect extends BaseMsg {\n  public protoMsg: MsgCollect_pb;\n  constructor(msg: MsgCollect_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCollect.typeUrl,\n      value: MsgCollect_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCollect {\n  export const typeUrl: string = `/${protobufPackage}.MsgCollect`;\n  export const Proto = MsgCollect_pb;\n  export interface Proto extends MsgCollect_pb {}\n}\n\nexport class MsgCreatePosition extends BaseMsg {\n  public protoMsg: MsgCreatePosition_pb;\n  constructor(msg: MsgCreatePosition_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgCreatePosition.typeUrl,\n      value: MsgCreatePosition_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgCreatePosition {\n  export const typeUrl: string = `/${protobufPackage}.MsgCreatePosition`;\n  export const Proto = MsgCreatePosition_pb;\n  export interface Proto extends MsgCreatePosition_pb {}\n}\n\nexport class MsgDecreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgDecreaseLiquidity_pb;\n  constructor(msg: MsgDecreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgDecreaseLiquidity.typeUrl,\n      value: MsgDecreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgDecreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgDecreaseLiquidity`;\n  export const Proto = MsgDecreaseLiquidity_pb;\n  export interface Proto extends MsgDecreaseLiquidity_pb {}\n}\n\nexport class MsgIncreaseLiquidity extends BaseMsg {\n  public protoMsg: MsgIncreaseLiquidity_pb;\n  constructor(msg: MsgIncreaseLiquidity_pb) {\n    super();\n    this.protoMsg = msg;\n  }\n  generateMessage(): EncodeObject {\n    return {\n      typeUrl: MsgIncreaseLiquidity.typeUrl,\n      value: MsgIncreaseLiquidity_pb.fromPartial(this.protoMsg),\n    };\n  }\n}\n\nexport namespace MsgIncreaseLiquidity {\n  export const typeUrl: string = `/${protobufPackage}.MsgIncreaseLiquidity`;\n  export const Proto = MsgIncreaseLiquidity_pb;\n  export interface Proto extends MsgIncreaseLiquidity_pb {}\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := ptypes.MarshalAny(foo)\n *      ...\n *      foo := &pb.Foo{}\n *      if err := ptypes.UnmarshalAny(any, foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n */\nexport interface Any {\n  /**\n   * A URL/resource name that uniquely identifies the type of the serialized\n   * protocol buffer message. This string must contain at least\n   * one \"/\" character. The last segment of the URL's path must represent\n   * the fully qualified name of the type (as in\n   * `path/google.protobuf.Duration`). The name should be in a canonical form\n   * (e.g., leading \".\" is not accepted).\n   *\n   * In practice, teams usually precompile into the binary all types that they\n   * expect it to use in the context of Any. However, for URLs which use the\n   * scheme `http`, `https`, or no scheme, one can optionally set up a type\n   * server that maps type URLs to message definitions as follows:\n   *\n   * * If no scheme is provided, `https` is assumed.\n   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   *   value in binary format, or produce an error.\n   * * Applications are allowed to cache lookup results based on the\n   *   URL, or have them precompiled into a binary to avoid any\n   *   lookup. Therefore, binary compatibility needs to be preserved\n   *   on changes to types. (Use versioned type names to manage\n   *   breaking changes.)\n   *\n   * Note: this functionality is not currently available in the official\n   * protobuf release, and it is not used for type URLs beginning with\n   * type.googleapis.com.\n   *\n   * Schemes other than `http`, `https` (or the empty scheme) might be\n   * used with implementation specific semantics.\n   */\n  typeUrl: string;\n  /** Must be a valid serialized protocol buffer of the above specified type. */\n  value: Uint8Array;\n}\n\nfunction createBaseAny(): Any {\n  return { typeUrl: \"\", value: new Uint8Array() };\n}\n\nexport const Any = {\n  encode(message: Any, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.typeUrl !== \"\") {\n      writer.uint32(10).string(message.typeUrl);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Any {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAny();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.typeUrl = reader.string();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Any {\n    return {\n      typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : \"\",\n      value: isSet(object.value)\n        ? bytesFromBase64(object.value)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: Any): unknown {\n    const obj: any = {};\n    message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);\n    message.value !== undefined &&\n      (obj.value = base64FromBytes(\n        message.value !== undefined ? message.value : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Any>, I>>(object: I): Any {\n    const message = createBaseAny();\n    message.typeUrl = object.typeUrl ?? \"\";\n    message.value = object.value ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.secp256k1\";\n\n/**\n * PubKey defines a secp256k1 public key\n * Key is the compressed form of the pubkey. The first byte depends is a 0x02\n * byte if the y-coordinate is the lexicographically largest of the two\n * associated with the x-coordinate. Otherwise the first byte is a 0x03. This\n * prefix is followed with the x-coordinate.\n */\nexport interface PubKey {\n  key: Uint8Array;\n}\n\n/** PrivKey defines a secp256k1 private key. */\nexport interface PrivKey {\n  key: Uint8Array;\n}\n\nfunction createBasePubKey(): PubKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PubKey = {\n  encode(\n    message: PubKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PubKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePubKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PubKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PubKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PubKey>, I>>(object: I): PubKey {\n    const message = createBasePubKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBasePrivKey(): PrivKey {\n  return { key: new Uint8Array() };\n}\n\nexport const PrivKey = {\n  encode(\n    message: PrivKey,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): PrivKey {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePrivKey();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PrivKey {\n    return {\n      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: PrivKey): unknown {\n    const obj: any = {};\n    message.key !== undefined &&\n      (obj.key = base64FromBytes(\n        message.key !== undefined ? message.key : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<PrivKey>, I>>(object: I): PrivKey {\n    const message = createBasePrivKey();\n    message.key = object.key ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.crypto.multisig.v1beta1\";\n\n/**\n * MultiSignature wraps the signatures from a multisig.LegacyAminoPubKey.\n * See cosmos.tx.v1betata1.ModeInfo.Multi for how to specify which signers\n * signed and with which modes.\n */\nexport interface MultiSignature {\n  signatures: Uint8Array[];\n}\n\n/**\n * CompactBitArray is an implementation of a space efficient bit array.\n * This is used to ensure that the encoded data takes up a minimal amount of\n * space after proto encoding.\n * This is not thread safe, and is not intended for concurrent usage.\n */\nexport interface CompactBitArray {\n  extraBitsStored: number;\n  elems: Uint8Array;\n}\n\nfunction createBaseMultiSignature(): MultiSignature {\n  return { signatures: [] };\n}\n\nexport const MultiSignature = {\n  encode(\n    message: MultiSignature,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      writer.uint32(10).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): MultiSignature {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMultiSignature();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MultiSignature {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: MultiSignature): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<MultiSignature>, I>>(\n    object: I\n  ): MultiSignature {\n    const message = createBaseMultiSignature();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseCompactBitArray(): CompactBitArray {\n  return { extraBitsStored: 0, elems: new Uint8Array() };\n}\n\nexport const CompactBitArray = {\n  encode(\n    message: CompactBitArray,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.extraBitsStored !== 0) {\n      writer.uint32(8).uint32(message.extraBitsStored);\n    }\n    if (message.elems.length !== 0) {\n      writer.uint32(18).bytes(message.elems);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CompactBitArray {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCompactBitArray();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.extraBitsStored = reader.uint32();\n          break;\n        case 2:\n          message.elems = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CompactBitArray {\n    return {\n      extraBitsStored: isSet(object.extraBitsStored)\n        ? Number(object.extraBitsStored)\n        : 0,\n      elems: isSet(object.elems)\n        ? bytesFromBase64(object.elems)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: CompactBitArray): unknown {\n    const obj: any = {};\n    message.extraBitsStored !== undefined &&\n      (obj.extraBitsStored = Math.round(message.extraBitsStored));\n    message.elems !== undefined &&\n      (obj.elems = base64FromBytes(\n        message.elems !== undefined ? message.elems : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CompactBitArray>, I>>(\n    object: I\n  ): CompactBitArray {\n    const message = createBaseCompactBitArray();\n    message.extraBitsStored = object.extraBitsStored ?? 0;\n    message.elems = object.elems ?? new Uint8Array();\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../../google/protobuf/any\";\nimport { CompactBitArray } from \"../../../crypto/multisig/v1beta1/multisig\";\n\nexport const protobufPackage = \"cosmos.tx.signing.v1beta1\";\n\n/** SignMode represents a signing mode with its own security guarantees. */\nexport enum SignMode {\n  /**\n   * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n   * rejected\n   */\n  SIGN_MODE_UNSPECIFIED = 0,\n  /**\n   * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n   * verified with raw bytes from Tx\n   */\n  SIGN_MODE_DIRECT = 1,\n  /**\n   * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n   * human-readable textual representation on top of the binary representation\n   * from SIGN_MODE_DIRECT\n   */\n  SIGN_MODE_TEXTUAL = 2,\n  /**\n   * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n   * Amino JSON and will be removed in the future\n   */\n  SIGN_MODE_LEGACY_AMINO_JSON = 127,\n  UNRECOGNIZED = -1,\n}\n\nexport function signModeFromJSON(object: any): SignMode {\n  switch (object) {\n    case 0:\n    case \"SIGN_MODE_UNSPECIFIED\":\n      return SignMode.SIGN_MODE_UNSPECIFIED;\n    case 1:\n    case \"SIGN_MODE_DIRECT\":\n      return SignMode.SIGN_MODE_DIRECT;\n    case 2:\n    case \"SIGN_MODE_TEXTUAL\":\n      return SignMode.SIGN_MODE_TEXTUAL;\n    case 127:\n    case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n      return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignMode.UNRECOGNIZED;\n  }\n}\n\nexport function signModeToJSON(object: SignMode): string {\n  switch (object) {\n    case SignMode.SIGN_MODE_UNSPECIFIED:\n      return \"SIGN_MODE_UNSPECIFIED\";\n    case SignMode.SIGN_MODE_DIRECT:\n      return \"SIGN_MODE_DIRECT\";\n    case SignMode.SIGN_MODE_TEXTUAL:\n      return \"SIGN_MODE_TEXTUAL\";\n    case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n      return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    case SignMode.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** SignatureDescriptors wraps multiple SignatureDescriptor's. */\nexport interface SignatureDescriptors {\n  /** signatures are the signature descriptors */\n  signatures: SignatureDescriptor[];\n}\n\n/**\n * SignatureDescriptor is a convenience type which represents the full data for\n * a signature including the public key of the signer, signing modes and the\n * signature itself. It is primarily used for coordinating signatures between\n * clients.\n */\nexport interface SignatureDescriptor {\n  /** public_key is the public key of the signer */\n  publicKey?: Any;\n  data?: SignatureDescriptor_Data;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to\n   * prevent replay attacks.\n   */\n  sequence: Long;\n}\n\n/** Data represents signature data */\nexport interface SignatureDescriptor_Data {\n  /** single represents a single signer */\n  single?: SignatureDescriptor_Data_Single | undefined;\n  /** multi represents a multisig signer */\n  multi?: SignatureDescriptor_Data_Multi | undefined;\n}\n\n/** Single is the signature data for a single signer */\nexport interface SignatureDescriptor_Data_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n  /** signature is the raw signature bytes */\n  signature: Uint8Array;\n}\n\n/** Multi is the signature data for a multisig public key */\nexport interface SignatureDescriptor_Data_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /** signatures is the signatures of the multi-signature */\n  signatures: SignatureDescriptor_Data[];\n}\n\nfunction createBaseSignatureDescriptors(): SignatureDescriptors {\n  return { signatures: [] };\n}\n\nexport const SignatureDescriptors = {\n  encode(\n    message: SignatureDescriptors,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signatures) {\n      SignatureDescriptor.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptors {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptors();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(\n            SignatureDescriptor.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptors {\n    return {\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => SignatureDescriptor.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptors): unknown {\n    const obj: any = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptors>, I>>(\n    object: I\n  ): SignatureDescriptors {\n    const message = createBaseSignatureDescriptors();\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor(): SignatureDescriptor {\n  return { publicKey: undefined, data: undefined, sequence: Long.UZERO };\n}\n\nexport const SignatureDescriptor = {\n  encode(\n    message: SignatureDescriptor,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.data !== undefined) {\n      SignatureDescriptor_Data.encode(\n        message.data,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureDescriptor {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.data = SignatureDescriptor_Data.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      data: isSet(object.data)\n        ? SignatureDescriptor_Data.fromJSON(object.data)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.data !== undefined &&\n      (obj.data = message.data\n        ? SignatureDescriptor_Data.toJSON(message.data)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor>, I>>(\n    object: I\n  ): SignatureDescriptor {\n    const message = createBaseSignatureDescriptor();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.data =\n      object.data !== undefined && object.data !== null\n        ? SignatureDescriptor_Data.fromPartial(object.data)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data(): SignatureDescriptor_Data {\n  return { single: undefined, multi: undefined };\n}\n\nexport const SignatureDescriptor_Data = {\n  encode(\n    message: SignatureDescriptor_Data,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      SignatureDescriptor_Data_Single.encode(\n        message.single,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    if (message.multi !== undefined) {\n      SignatureDescriptor_Data_Multi.encode(\n        message.multi,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = SignatureDescriptor_Data_Single.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 2:\n          message.multi = SignatureDescriptor_Data_Multi.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data {\n    return {\n      single: isSet(object.single)\n        ? SignatureDescriptor_Data_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? SignatureDescriptor_Data_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? SignatureDescriptor_Data_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? SignatureDescriptor_Data_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data>, I>>(\n    object: I\n  ): SignatureDescriptor_Data {\n    const message = createBaseSignatureDescriptor_Data();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? SignatureDescriptor_Data_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? SignatureDescriptor_Data_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Single(): SignatureDescriptor_Data_Single {\n  return { mode: 0, signature: new Uint8Array() };\n}\n\nexport const SignatureDescriptor_Data_Single = {\n  encode(\n    message: SignatureDescriptor_Data_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(18).bytes(message.signature);\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        case 2:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n      signature: isSet(object.signature)\n        ? bytesFromBase64(object.signature)\n        : new Uint8Array(),\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    message.signature !== undefined &&\n      (obj.signature = base64FromBytes(\n        message.signature !== undefined ? message.signature : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Single>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Single {\n    const message = createBaseSignatureDescriptor_Data_Single();\n    message.mode = object.mode ?? 0;\n    message.signature = object.signature ?? new Uint8Array();\n    return message;\n  },\n};\n\nfunction createBaseSignatureDescriptor_Data_Multi(): SignatureDescriptor_Data_Multi {\n  return { bitarray: undefined, signatures: [] };\n}\n\nexport const SignatureDescriptor_Data_Multi = {\n  encode(\n    message: SignatureDescriptor_Data_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.signatures) {\n      SignatureDescriptor_Data.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(\n    input: _m0.Reader | Uint8Array,\n    length?: number\n  ): SignatureDescriptor_Data_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signatures.push(\n            SignatureDescriptor_Data.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignatureDescriptor_Data_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) =>\n            SignatureDescriptor_Data.fromJSON(e)\n          )\n        : [],\n    };\n  },\n\n  toJSON(message: SignatureDescriptor_Data_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        e ? SignatureDescriptor_Data.toJSON(e) : undefined\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor_Data_Multi>, I>>(\n    object: I\n  ): SignatureDescriptor_Data_Multi {\n    const message = createBaseSignatureDescriptor_Data_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.signatures =\n      object.signatures?.map((e) => SignatureDescriptor_Data.fromPartial(e)) ||\n      [];\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"cosmos.base.v1beta1\";\n\n/**\n * Coin defines a token with a denomination and an amount.\n *\n * NOTE: The amount field is an Int which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface Coin {\n  denom: string;\n  amount: string;\n}\n\n/**\n * DecCoin defines a token with a denomination and a decimal amount.\n *\n * NOTE: The amount field is an Dec which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface DecCoin {\n  denom: string;\n  amount: string;\n}\n\n/** IntProto defines a Protobuf wrapper around an Int object. */\nexport interface IntProto {\n  int: string;\n}\n\n/** DecProto defines a Protobuf wrapper around a Dec object. */\nexport interface DecProto {\n  dec: string;\n}\n\nfunction createBaseCoin(): Coin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const Coin = {\n  encode(message: Coin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Coin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Coin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: Coin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Coin>, I>>(object: I): Coin {\n    const message = createBaseCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecCoin(): DecCoin {\n  return { denom: \"\", amount: \"\" };\n}\n\nexport const DecCoin = {\n  encode(\n    message: DecCoin,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(18).string(message.amount);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecCoin {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecCoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.amount = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecCoin {\n    return {\n      denom: isSet(object.denom) ? String(object.denom) : \"\",\n      amount: isSet(object.amount) ? String(object.amount) : \"\",\n    };\n  },\n\n  toJSON(message: DecCoin): unknown {\n    const obj: any = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.amount !== undefined && (obj.amount = message.amount);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecCoin>, I>>(object: I): DecCoin {\n    const message = createBaseDecCoin();\n    message.denom = object.denom ?? \"\";\n    message.amount = object.amount ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseIntProto(): IntProto {\n  return { int: \"\" };\n}\n\nexport const IntProto = {\n  encode(\n    message: IntProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.int !== \"\") {\n      writer.uint32(10).string(message.int);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): IntProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseIntProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.int = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): IntProto {\n    return {\n      int: isSet(object.int) ? String(object.int) : \"\",\n    };\n  },\n\n  toJSON(message: IntProto): unknown {\n    const obj: any = {};\n    message.int !== undefined && (obj.int = message.int);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<IntProto>, I>>(object: I): IntProto {\n    const message = createBaseIntProto();\n    message.int = object.int ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseDecProto(): DecProto {\n  return { dec: \"\" };\n}\n\nexport const DecProto = {\n  encode(\n    message: DecProto,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.dec !== \"\") {\n      writer.uint32(10).string(message.dec);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): DecProto {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseDecProto();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.dec = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): DecProto {\n    return {\n      dec: isSet(object.dec) ? String(object.dec) : \"\",\n    };\n  },\n\n  toJSON(message: DecProto): unknown {\n    const obj: any = {};\n    message.dec !== undefined && (obj.dec = message.dec);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<DecProto>, I>>(object: I): DecProto {\n    const message = createBaseDecProto();\n    message.dec = object.dec ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","/* eslint-disable */\nimport Long from \"long\";\nimport * as _m0 from \"protobufjs/minimal\";\nimport { Any } from \"../../../google/protobuf/any\";\nimport {\n  SignMode,\n  signModeFromJSON,\n  signModeToJSON,\n} from \"../signing/v1beta1/signing\";\nimport { CompactBitArray } from \"../../crypto/multisig/v1beta1/multisig\";\nimport { Coin } from \"../../base/v1beta1/coin\";\n\nexport const protobufPackage = \"cosmos.tx.v1beta1\";\n\n/** Tx is the standard type used for broadcasting transactions. */\nexport interface Tx {\n  /** body is the processable content of the transaction */\n  body?: TxBody;\n  /**\n   * auth_info is the authorization related content of the transaction,\n   * specifically signers, signer modes and fee\n   */\n  authInfo?: AuthInfo;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/**\n * TxRaw is a variant of Tx that pins the signer's exact binary representation\n * of body and auth_info. This is used for signing, broadcasting and\n * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and\n * the hash `sha256(serialize(tx: TxRaw))` becomes the \"txhash\", commonly used\n * as the transaction ID.\n */\nexport interface TxRaw {\n  /**\n   * body_bytes is a protobuf serialization of a TxBody that matches the\n   * representation in SignDoc.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in SignDoc.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * signatures is a list of signatures that matches the length and order of\n   * AuthInfo's signer_infos to allow connecting signature meta information like\n   * public key and signing mode by position.\n   */\n  signatures: Uint8Array[];\n}\n\n/** SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT. */\nexport interface SignDoc {\n  /**\n   * body_bytes is protobuf serialization of a TxBody that matches the\n   * representation in TxRaw.\n   */\n  bodyBytes: Uint8Array;\n  /**\n   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n   * representation in TxRaw.\n   */\n  authInfoBytes: Uint8Array;\n  /**\n   * chain_id is the unique identifier of the chain this transaction targets.\n   * It prevents signed transactions from being used on another chain by an\n   * attacker\n   */\n  chainId: string;\n  /** account_number is the account number of the account in state */\n  accountNumber: Long;\n}\n\n/** TxBody is the body of a transaction that all signers sign over. */\nexport interface TxBody {\n  /**\n   * messages is a list of messages to be executed. The required signers of\n   * those messages define the number and order of elements in AuthInfo's\n   * signer_infos and Tx's signatures. Each required signer address is added to\n   * the list only the first time it occurs.\n   * By convention, the first required signer (usually from the first message)\n   * is referred to as the primary signer and pays the fee for the whole\n   * transaction.\n   */\n  messages: Any[];\n  /**\n   * memo is any arbitrary note/comment to be added to the transaction.\n   * WARNING: in clients, any publicly exposed text should not be called memo,\n   * but should be called `note` instead (see\n   * https://github.com/cosmos/cosmos-sdk/issues/9122).\n   */\n  memo: string;\n  /**\n   * timeout is the block height after which this transaction will not\n   * be processed by the chain\n   */\n  timeoutHeight: Long;\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, the transaction will be rejected\n   */\n  extensionOptions: Any[];\n  /**\n   * extension_options are arbitrary options that can be added by chains\n   * when the default options are not sufficient. If any of these are present\n   * and can't be handled, they will be ignored\n   */\n  nonCriticalExtensionOptions: Any[];\n}\n\n/**\n * AuthInfo describes the fee and signer modes that are used to sign a\n * transaction.\n */\nexport interface AuthInfo {\n  /**\n   * signer_infos defines the signing modes for the required signers. The number\n   * and order of elements must match the required signers from TxBody's\n   * messages. The first element is the primary signer and the one which pays\n   * the fee.\n   */\n  signerInfos: SignerInfo[];\n  /**\n   * Fee is the fee and gas limit for the transaction. The first signer is the\n   * primary signer and the one which pays the fee. The fee can be calculated\n   * based on the cost of evaluating the body and doing signature verification\n   * of the signers. This can be estimated via simulation.\n   */\n  fee?: Fee;\n}\n\n/**\n * SignerInfo describes the public key and signing mode of a single top-level\n * signer.\n */\nexport interface SignerInfo {\n  /**\n   * public_key is the public key of the signer. It is optional for accounts\n   * that already exist in state. If unset, the verifier can use the required \\\n   * signer address for this position and lookup the public key.\n   */\n  publicKey?: Any;\n  /**\n   * mode_info describes the signing mode of the signer and is a nested\n   * structure to support nested multisig pubkey's\n   */\n  modeInfo?: ModeInfo;\n  /**\n   * sequence is the sequence of the account, which describes the\n   * number of committed transactions signed by a given address. It is used to\n   * prevent replay attacks.\n   */\n  sequence: Long;\n}\n\n/** ModeInfo describes the signing mode of a single or nested multisig signer. */\nexport interface ModeInfo {\n  /** single represents a single signer */\n  single?: ModeInfo_Single | undefined;\n  /** multi represents a nested multisig signer */\n  multi?: ModeInfo_Multi | undefined;\n}\n\n/**\n * Single is the mode info for a single signer. It is structured as a message\n * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\n * future\n */\nexport interface ModeInfo_Single {\n  /** mode is the signing mode of the single signer */\n  mode: SignMode;\n}\n\n/** Multi is the mode info for a multisig public key */\nexport interface ModeInfo_Multi {\n  /** bitarray specifies which keys within the multisig are signing */\n  bitarray?: CompactBitArray;\n  /**\n   * mode_infos is the corresponding modes of the signers of the multisig\n   * which could include nested multisig public keys\n   */\n  modeInfos: ModeInfo[];\n}\n\n/**\n * Fee includes the amount of coins paid in fees and the maximum\n * gas to be used by the transaction. The ratio yields an effective \"gasprice\",\n * which must be above some miminum to be accepted into the mempool.\n */\nexport interface Fee {\n  /** amount is the amount of coins to be paid as a fee */\n  amount: Coin[];\n  /**\n   * gas_limit is the maximum gas that can be used in transaction processing\n   * before an out of gas error occurs\n   */\n  gasLimit: Long;\n  /**\n   * if unset, the first signer is responsible for paying the fees. If set, the\n   * specified account must pay the fees. the payer must be a tx signer (and\n   * thus have signed this field in AuthInfo). setting this field does *not*\n   * change the ordering of required signers for the transaction.\n   */\n  payer: string;\n  /**\n   * if set, the fee payer (either the first signer or the value of the payer\n   * field) requests that a fee grant be used to pay fees instead of the fee\n   * payer's own balance. If an appropriate fee grant does not exist or the\n   * chain does not support fee grants, this will fail\n   */\n  granter: string;\n}\n\nfunction createBaseTx(): Tx {\n  return { body: undefined, authInfo: undefined, signatures: [] };\n}\n\nexport const Tx = {\n  encode(message: Tx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.body !== undefined) {\n      TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.authInfo !== undefined) {\n      AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Tx {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.body = TxBody.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.authInfo = AuthInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Tx {\n    return {\n      body: isSet(object.body) ? TxBody.fromJSON(object.body) : undefined,\n      authInfo: isSet(object.authInfo)\n        ? AuthInfo.fromJSON(object.authInfo)\n        : undefined,\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: Tx): unknown {\n    const obj: any = {};\n    message.body !== undefined &&\n      (obj.body = message.body ? TxBody.toJSON(message.body) : undefined);\n    message.authInfo !== undefined &&\n      (obj.authInfo = message.authInfo\n        ? AuthInfo.toJSON(message.authInfo)\n        : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Tx>, I>>(object: I): Tx {\n    const message = createBaseTx();\n    message.body =\n      object.body !== undefined && object.body !== null\n        ? TxBody.fromPartial(object.body)\n        : undefined;\n    message.authInfo =\n      object.authInfo !== undefined && object.authInfo !== null\n        ? AuthInfo.fromPartial(object.authInfo)\n        : undefined;\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseTxRaw(): TxRaw {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    signatures: [],\n  };\n}\n\nexport const TxRaw = {\n  encode(message: TxRaw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v!);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxRaw {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxRaw();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxRaw {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      signatures: Array.isArray(object?.signatures)\n        ? object.signatures.map((e: any) => bytesFromBase64(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxRaw): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    if (message.signatures) {\n      obj.signatures = message.signatures.map((e) =>\n        base64FromBytes(e !== undefined ? e : new Uint8Array())\n      );\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxRaw>, I>>(object: I): TxRaw {\n    const message = createBaseTxRaw();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.signatures = object.signatures?.map((e) => e) || [];\n    return message;\n  },\n};\n\nfunction createBaseSignDoc(): SignDoc {\n  return {\n    bodyBytes: new Uint8Array(),\n    authInfoBytes: new Uint8Array(),\n    chainId: \"\",\n    accountNumber: Long.UZERO,\n  };\n}\n\nexport const SignDoc = {\n  encode(\n    message: SignDoc,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(26).string(message.chainId);\n    }\n    if (!message.accountNumber.isZero()) {\n      writer.uint32(32).uint64(message.accountNumber);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignDoc {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignDoc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.chainId = reader.string();\n          break;\n        case 4:\n          message.accountNumber = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignDoc {\n    return {\n      bodyBytes: isSet(object.bodyBytes)\n        ? bytesFromBase64(object.bodyBytes)\n        : new Uint8Array(),\n      authInfoBytes: isSet(object.authInfoBytes)\n        ? bytesFromBase64(object.authInfoBytes)\n        : new Uint8Array(),\n      chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n      accountNumber: isSet(object.accountNumber)\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignDoc): unknown {\n    const obj: any = {};\n    message.bodyBytes !== undefined &&\n      (obj.bodyBytes = base64FromBytes(\n        message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()\n      ));\n    message.authInfoBytes !== undefined &&\n      (obj.authInfoBytes = base64FromBytes(\n        message.authInfoBytes !== undefined\n          ? message.authInfoBytes\n          : new Uint8Array()\n      ));\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.accountNumber !== undefined &&\n      (obj.accountNumber = (message.accountNumber || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignDoc>, I>>(object: I): SignDoc {\n    const message = createBaseSignDoc();\n    message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n    message.chainId = object.chainId ?? \"\";\n    message.accountNumber =\n      object.accountNumber !== undefined && object.accountNumber !== null\n        ? Long.fromValue(object.accountNumber)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseTxBody(): TxBody {\n  return {\n    messages: [],\n    memo: \"\",\n    timeoutHeight: Long.UZERO,\n    extensionOptions: [],\n    nonCriticalExtensionOptions: [],\n  };\n}\n\nexport const TxBody = {\n  encode(\n    message: TxBody,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.messages) {\n      Any.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.memo !== \"\") {\n      writer.uint32(18).string(message.memo);\n    }\n    if (!message.timeoutHeight.isZero()) {\n      writer.uint32(24).uint64(message.timeoutHeight);\n    }\n    for (const v of message.extensionOptions) {\n      Any.encode(v!, writer.uint32(8186).fork()).ldelim();\n    }\n    for (const v of message.nonCriticalExtensionOptions) {\n      Any.encode(v!, writer.uint32(16378).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): TxBody {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTxBody();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.messages.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.memo = reader.string();\n          break;\n        case 3:\n          message.timeoutHeight = reader.uint64() as Long;\n          break;\n        case 1023:\n          message.extensionOptions.push(Any.decode(reader, reader.uint32()));\n          break;\n        case 2047:\n          message.nonCriticalExtensionOptions.push(\n            Any.decode(reader, reader.uint32())\n          );\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TxBody {\n    return {\n      messages: Array.isArray(object?.messages)\n        ? object.messages.map((e: any) => Any.fromJSON(e))\n        : [],\n      memo: isSet(object.memo) ? String(object.memo) : \"\",\n      timeoutHeight: isSet(object.timeoutHeight)\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO,\n      extensionOptions: Array.isArray(object?.extensionOptions)\n        ? object.extensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n      nonCriticalExtensionOptions: Array.isArray(\n        object?.nonCriticalExtensionOptions\n      )\n        ? object.nonCriticalExtensionOptions.map((e: any) => Any.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TxBody): unknown {\n    const obj: any = {};\n    if (message.messages) {\n      obj.messages = message.messages.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.messages = [];\n    }\n    message.memo !== undefined && (obj.memo = message.memo);\n    message.timeoutHeight !== undefined &&\n      (obj.timeoutHeight = (message.timeoutHeight || Long.UZERO).toString());\n    if (message.extensionOptions) {\n      obj.extensionOptions = message.extensionOptions.map((e) =>\n        e ? Any.toJSON(e) : undefined\n      );\n    } else {\n      obj.extensionOptions = [];\n    }\n    if (message.nonCriticalExtensionOptions) {\n      obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(\n        (e) => (e ? Any.toJSON(e) : undefined)\n      );\n    } else {\n      obj.nonCriticalExtensionOptions = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<TxBody>, I>>(object: I): TxBody {\n    const message = createBaseTxBody();\n    message.messages = object.messages?.map((e) => Any.fromPartial(e)) || [];\n    message.memo = object.memo ?? \"\";\n    message.timeoutHeight =\n      object.timeoutHeight !== undefined && object.timeoutHeight !== null\n        ? Long.fromValue(object.timeoutHeight)\n        : Long.UZERO;\n    message.extensionOptions =\n      object.extensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    message.nonCriticalExtensionOptions =\n      object.nonCriticalExtensionOptions?.map((e) => Any.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseAuthInfo(): AuthInfo {\n  return { signerInfos: [], fee: undefined };\n}\n\nexport const AuthInfo = {\n  encode(\n    message: AuthInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    for (const v of message.signerInfos) {\n      SignerInfo.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.fee !== undefined) {\n      Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): AuthInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseAuthInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signerInfos.push(SignerInfo.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.fee = Fee.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): AuthInfo {\n    return {\n      signerInfos: Array.isArray(object?.signerInfos)\n        ? object.signerInfos.map((e: any) => SignerInfo.fromJSON(e))\n        : [],\n      fee: isSet(object.fee) ? Fee.fromJSON(object.fee) : undefined,\n    };\n  },\n\n  toJSON(message: AuthInfo): unknown {\n    const obj: any = {};\n    if (message.signerInfos) {\n      obj.signerInfos = message.signerInfos.map((e) =>\n        e ? SignerInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.signerInfos = [];\n    }\n    message.fee !== undefined &&\n      (obj.fee = message.fee ? Fee.toJSON(message.fee) : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<AuthInfo>, I>>(object: I): AuthInfo {\n    const message = createBaseAuthInfo();\n    message.signerInfos =\n      object.signerInfos?.map((e) => SignerInfo.fromPartial(e)) || [];\n    message.fee =\n      object.fee !== undefined && object.fee !== null\n        ? Fee.fromPartial(object.fee)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseSignerInfo(): SignerInfo {\n  return { publicKey: undefined, modeInfo: undefined, sequence: Long.UZERO };\n}\n\nexport const SignerInfo = {\n  encode(\n    message: SignerInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.publicKey !== undefined) {\n      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.modeInfo !== undefined) {\n      ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): SignerInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseSignerInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfo = ModeInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.sequence = reader.uint64() as Long;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): SignerInfo {\n    return {\n      publicKey: isSet(object.publicKey)\n        ? Any.fromJSON(object.publicKey)\n        : undefined,\n      modeInfo: isSet(object.modeInfo)\n        ? ModeInfo.fromJSON(object.modeInfo)\n        : undefined,\n      sequence: isSet(object.sequence)\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO,\n    };\n  },\n\n  toJSON(message: SignerInfo): unknown {\n    const obj: any = {};\n    message.publicKey !== undefined &&\n      (obj.publicKey = message.publicKey\n        ? Any.toJSON(message.publicKey)\n        : undefined);\n    message.modeInfo !== undefined &&\n      (obj.modeInfo = message.modeInfo\n        ? ModeInfo.toJSON(message.modeInfo)\n        : undefined);\n    message.sequence !== undefined &&\n      (obj.sequence = (message.sequence || Long.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<SignerInfo>, I>>(\n    object: I\n  ): SignerInfo {\n    const message = createBaseSignerInfo();\n    message.publicKey =\n      object.publicKey !== undefined && object.publicKey !== null\n        ? Any.fromPartial(object.publicKey)\n        : undefined;\n    message.modeInfo =\n      object.modeInfo !== undefined && object.modeInfo !== null\n        ? ModeInfo.fromPartial(object.modeInfo)\n        : undefined;\n    message.sequence =\n      object.sequence !== undefined && object.sequence !== null\n        ? Long.fromValue(object.sequence)\n        : Long.UZERO;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo(): ModeInfo {\n  return { single: undefined, multi: undefined };\n}\n\nexport const ModeInfo = {\n  encode(\n    message: ModeInfo,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.single !== undefined) {\n      ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.multi !== undefined) {\n      ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = ModeInfo_Single.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.multi = ModeInfo_Multi.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo {\n    return {\n      single: isSet(object.single)\n        ? ModeInfo_Single.fromJSON(object.single)\n        : undefined,\n      multi: isSet(object.multi)\n        ? ModeInfo_Multi.fromJSON(object.multi)\n        : undefined,\n    };\n  },\n\n  toJSON(message: ModeInfo): unknown {\n    const obj: any = {};\n    message.single !== undefined &&\n      (obj.single = message.single\n        ? ModeInfo_Single.toJSON(message.single)\n        : undefined);\n    message.multi !== undefined &&\n      (obj.multi = message.multi\n        ? ModeInfo_Multi.toJSON(message.multi)\n        : undefined);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo>, I>>(object: I): ModeInfo {\n    const message = createBaseModeInfo();\n    message.single =\n      object.single !== undefined && object.single !== null\n        ? ModeInfo_Single.fromPartial(object.single)\n        : undefined;\n    message.multi =\n      object.multi !== undefined && object.multi !== null\n        ? ModeInfo_Multi.fromPartial(object.multi)\n        : undefined;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Single(): ModeInfo_Single {\n  return { mode: 0 };\n}\n\nexport const ModeInfo_Single = {\n  encode(\n    message: ModeInfo_Single,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Single {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Single();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32() as any;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Single {\n    return {\n      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n    };\n  },\n\n  toJSON(message: ModeInfo_Single): unknown {\n    const obj: any = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Single>, I>>(\n    object: I\n  ): ModeInfo_Single {\n    const message = createBaseModeInfo_Single();\n    message.mode = object.mode ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseModeInfo_Multi(): ModeInfo_Multi {\n  return { bitarray: undefined, modeInfos: [] };\n}\n\nexport const ModeInfo_Multi = {\n  encode(\n    message: ModeInfo_Multi,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.bitarray !== undefined) {\n      CompactBitArray.encode(\n        message.bitarray,\n        writer.uint32(10).fork()\n      ).ldelim();\n    }\n    for (const v of message.modeInfos) {\n      ModeInfo.encode(v!, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Multi {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseModeInfo_Multi();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfos.push(ModeInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ModeInfo_Multi {\n    return {\n      bitarray: isSet(object.bitarray)\n        ? CompactBitArray.fromJSON(object.bitarray)\n        : undefined,\n      modeInfos: Array.isArray(object?.modeInfos)\n        ? object.modeInfos.map((e: any) => ModeInfo.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: ModeInfo_Multi): unknown {\n    const obj: any = {};\n    message.bitarray !== undefined &&\n      (obj.bitarray = message.bitarray\n        ? CompactBitArray.toJSON(message.bitarray)\n        : undefined);\n    if (message.modeInfos) {\n      obj.modeInfos = message.modeInfos.map((e) =>\n        e ? ModeInfo.toJSON(e) : undefined\n      );\n    } else {\n      obj.modeInfos = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<ModeInfo_Multi>, I>>(\n    object: I\n  ): ModeInfo_Multi {\n    const message = createBaseModeInfo_Multi();\n    message.bitarray =\n      object.bitarray !== undefined && object.bitarray !== null\n        ? CompactBitArray.fromPartial(object.bitarray)\n        : undefined;\n    message.modeInfos =\n      object.modeInfos?.map((e) => ModeInfo.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseFee(): Fee {\n  return { amount: [], gasLimit: Long.UZERO, payer: \"\", granter: \"\" };\n}\n\nexport const Fee = {\n  encode(message: Fee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.amount) {\n      Coin.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.gasLimit.isZero()) {\n      writer.uint32(16).uint64(message.gasLimit);\n    }\n    if (message.payer !== \"\") {\n      writer.uint32(26).string(message.payer);\n    }\n    if (message.granter !== \"\") {\n      writer.uint32(34).string(message.granter);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Fee {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseFee();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.amount.push(Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.gasLimit = reader.uint64() as Long;\n          break;\n        case 3:\n          message.payer = reader.string();\n          break;\n        case 4:\n          message.granter = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Fee {\n    return {\n      amount: Array.isArray(object?.amount)\n        ? object.amount.map((e: any) => Coin.fromJSON(e))\n        : [],\n      gasLimit: isSet(object.gasLimit)\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO,\n      payer: isSet(object.payer) ? String(object.payer) : \"\",\n      granter: isSet(object.granter) ? String(object.granter) : \"\",\n    };\n  },\n\n  toJSON(message: Fee): unknown {\n    const obj: any = {};\n    if (message.amount) {\n      obj.amount = message.amount.map((e) => (e ? Coin.toJSON(e) : undefined));\n    } else {\n      obj.amount = [];\n    }\n    message.gasLimit !== undefined &&\n      (obj.gasLimit = (message.gasLimit || Long.UZERO).toString());\n    message.payer !== undefined && (obj.payer = message.payer);\n    message.granter !== undefined && (obj.granter = message.granter);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Fee>, I>>(object: I): Fee {\n    const message = createBaseFee();\n    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];\n    message.gasLimit =\n      object.gasLimit !== undefined && object.gasLimit !== null\n        ? Long.fromValue(object.gasLimit)\n        : Long.UZERO;\n    message.payer = object.payer ?? \"\";\n    message.granter = object.granter ?? \"\";\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\ndeclare var global: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  arr.forEach((byte) => {\n    bin.push(String.fromCharCode(byte));\n  });\n  return btoa(bin.join(\"\"));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Long\n  ? string | number | Long\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<\n        Exclude<keyof I, KeysOfUnion<P>>,\n        never\n      >;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n","import { Keccak } from \"sha3\";\nimport invariant from \"tiny-invariant\";\nimport { APIClient } from \"../index\";\nimport { Buffer } from \"buffer\";\nimport { CONFIG_CHAIN_SOPHON } from \"../constants\";\nimport {\n  EncodeObject,\n  GeneratedType,\n  OfflineSigner,\n  Registry,\n  TxBodyEncodeObject,\n} from \"@cosmjs/proto-signing\";\nimport { Any } from \"cosmjs-types/google/protobuf/any\";\nimport {\n  BaseMsg,\n  MsgCollect,\n  MsgCollectReward,\n  MsgCreatePool,\n  MsgCreatePosition,\n  MsgDecreaseLiquidity,\n  MsgIncreaseLiquidity,\n  MsgSwapExactIn,\n  MsgSwapExactOut,\n} from \"../msgs\";\nimport { SigningStargateClient } from \"@cosmjs/stargate\";\nimport { PubKey } from \"../proto/cosmos/crypto/secp256k1/keys\";\nimport {\n  SignerInfo,\n  ModeInfo,\n  ModeInfo_Single,\n  TxBody,\n  Fee,\n  AuthInfo,\n  SignDoc,\n  TxRaw,\n} from \"../proto/cosmos/tx/v1beta1/tx\";\nimport { SignMode } from \"../proto/cosmos/tx/signing/v1beta1/signing\";\nimport { Coin } from \"../proto/cosmos/base/v1beta1/coin\";\nimport { fromBase64 } from \"@cosmjs/encoding\";\n\nexport interface ISender {\n  address: string;\n  pubkey: Uint8Array;\n  accountNumber: number;\n  sequence: number;\n}\n\n// FIXME\nexport interface TxGenerated {\n  signDirect: {\n    body: TxBodyEncodeObject;\n    authInfo: AuthInfo;\n    signBytes: string;\n  };\n}\n\nexport const SIGN_DIRECT = SignMode.SIGN_MODE_DIRECT;\n\n// const defaultFee: StdFee = {\n//   amount: [],\n//   gas: CONFIG_CHAIN_SOPHON.DEFAULT_GAS,\n// };\n\nconst defaultFee = {\n  amount: \"\",\n  denom: CONFIG_CHAIN_SOPHON.COIN_DENOM,\n  gas: CONFIG_CHAIN_SOPHON.DEFAULT_GAS as number,\n};\n\nexport class TxClient {\n  public apiClient: APIClient;\n  public rpcUrl: string;\n  public accountAddress: string;\n  public signer: OfflineSigner;\n  public registry: Registry;\n\n  // public walletClient: SigningStargateClient | null = null;\n  // public sender: ISender | null = null;\n\n  constructor(\n    apiClient: APIClient,\n    rpcUrl: string,\n    signer: OfflineSigner,\n    accountAddress: string\n  ) {\n    invariant(!!signer, \"wallet is required!\");\n\n    this.apiClient = apiClient;\n    this.rpcUrl = rpcUrl;\n    this.signer = signer;\n    this.accountAddress = accountAddress;\n\n    const registryTypes = new Map<string, GeneratedType>();\n    registryTypes.set(MsgCollect.typeUrl, MsgCollect.Proto);\n    registryTypes.set(MsgCollectReward.typeUrl, MsgCollectReward.Proto);\n    registryTypes.set(MsgCreatePool.typeUrl, MsgCreatePool.Proto);\n    registryTypes.set(MsgCreatePosition.typeUrl, MsgCreatePosition.Proto);\n    registryTypes.set(MsgDecreaseLiquidity.typeUrl, MsgDecreaseLiquidity.Proto);\n    registryTypes.set(MsgIncreaseLiquidity.typeUrl, MsgIncreaseLiquidity.Proto);\n    registryTypes.set(MsgSwapExactIn.typeUrl, MsgSwapExactIn.Proto);\n    registryTypes.set(MsgSwapExactOut.typeUrl, MsgSwapExactOut.Proto);\n\n    this.registry = new Registry(registryTypes);\n  }\n\n  public async getSender(): Promise<ISender> {\n    const { authAPI } = this.apiClient;\n    const {\n      account: {\n        base_account: {\n          pub_key,\n          account_number,\n          sequence,\n        },\n      },\n    } = await authAPI.apiAccountInfo(this.accountAddress);\n    const { address, pubkey } = (await this.signer.getAccounts())[0];\n    return {\n      address: this.accountAddress,\n      pubkey,\n      accountNumber: parseInt(account_number),\n      sequence: parseInt(sequence),\n    } as ISender;\n  }\n\n  public async sendTransaction(\n    messages: BaseMsg | Array<BaseMsg>,\n    memo: string = \"\"\n    // fee: string,\n    // denom: string,\n    // gasLimit: number,\n  ) {\n    const sender = await this.getSender();\n    // const pubKeyDecoded = Buffer.from(sender.pubkey, \"base64\");\n\n    // 1. SignDirect\n    const signInfoDirect = createSignerInfo(\n      sender.pubkey,\n      sender.sequence,\n      SIGN_DIRECT\n    );\n\n    // 2. Fee\n    const feeMessage = createFee(\n      defaultFee.amount,\n      defaultFee.denom,\n      defaultFee.gas\n    );\n\n    // 3. authInfo\n    const authInfoDirect = createAuthInfo(signInfoDirect, feeMessage);\n\n    // console.log(AuthInfo.encode(authInfoDirect).finish());\n\n    // 4. txbody\n    // const body = createBodyWithMultipleMessages(messages, memo);\n    const _messages = messages instanceof Array ? messages : [messages];\n    const body = createTxBodyEncodeObject(_messages, memo);\n\n    // 5. signDoc\n    const signDocDirect = createSigDoc(\n      this.registry.encode(body),\n      AuthInfo.encode(authInfoDirect).finish(),\n      CONFIG_CHAIN_SOPHON.CHAIN_ID,\n      sender.accountNumber\n    );\n\n    let walletClient;\n    walletClient = await SigningStargateClient.connectWithSigner(\n      this.rpcUrl,\n      this.signer,\n      {\n        registry: this.registry,\n        prefix: CONFIG_CHAIN_SOPHON.COIN_MINIMAL_DENOM.toLowerCase(),\n      }\n    );\n    // @ts-ignore\n    const { signed, signature } = await walletClient.signer.signDirect(\n      this.accountAddress,\n      signDocDirect\n    );\n\n    const txRaw = TxRaw.fromPartial({\n      bodyBytes: signed.bodyBytes,\n      authInfoBytes: signed.authInfoBytes,\n      signatures: [fromBase64(signature.signature)],\n    });\n    const txBytes = TxRaw.encode(txRaw).finish();\n\n    return walletClient.broadcastTx(txBytes);\n  }\n\n  // public async signTransaction(\n  //   tx: TxGenerated,\n  //   broadcastMode: string = 'BROADCAST_MODE_BLOCK',\n  // ) {\n  //   const dataToSign = `0x${Buffer.from(\n  //     tx.signDirect.signBytes,\n  //     'base64',\n  //   ).toString('hex')}`\n  //\n  //   /* eslint-disable no-underscore-dangle */\n  //   const signatureRaw = wallet._signingKey().signDigest(dataToSign)\n  //   const splitedSignature = splitSignature(signatureRaw)\n  //   const signature = arrayify(concat([splitedSignature.r, splitedSignature.s]))\n  //\n  //   const signedTx = createTxRaw(\n  //     tx.signDirect.body.serializeBinary(),\n  //     tx.signDirect.authInfo.serializeBinary(),\n  //     [signature],\n  //   )\n  //   const body = `{ \"tx_bytes\": [${signedTx.message\n  //     .serializeBinary()\n  //     .toString()}], \"mode\": \"${broadcastMode}\" }`\n  //\n  //   return body\n  // }\n}\n\nexport function createTxBodyEncodeObject(\n  messages: Array<BaseMsg>,\n  memo: string\n): TxBodyEncodeObject {\n  const results = messages.map((item) => {\n    return item.generateMessage();\n  });\n  return {\n    typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n    value: {\n      messages: results,\n      memo: memo,\n    },\n  };\n}\n\nexport function createSigDoc(\n  bodyBytes: Uint8Array,\n  authInfoBytes: Uint8Array,\n  chainId: string,\n  accountNumber: number\n) {\n  return SignDoc.fromPartial({\n    bodyBytes,\n    authInfoBytes,\n    chainId,\n    accountNumber,\n  });\n}\n\nfunction createAuthInfo(signerInfo: SignerInfo, fee: Fee) {\n  return AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee,\n  });\n}\n\nfunction createFee(fee: string, denom: string, gasLimit: number) {\n  return Fee.fromPartial({\n    amount: [\n      Coin.fromPartial({\n        denom,\n        amount: fee,\n      }),\n    ],\n    gasLimit,\n  });\n}\n\nfunction createSignerInfo(\n  publicKey: Uint8Array,\n  sequence: number,\n  mode: number\n) {\n  const pubkey = Any.fromPartial({\n    typeUrl: \"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\n    value: PubKey.encode({\n      key: publicKey,\n    }).finish(),\n  });\n  const signerInfo = SignerInfo.fromPartial({\n    publicKey: pubkey,\n    modeInfo: ModeInfo.fromPartial({\n      single: ModeInfo_Single.fromPartial({\n        mode,\n      }),\n    }),\n    sequence,\n  });\n\n  return signerInfo;\n}\n","import { APIRequester, TxAPI } from \"../api\";\nimport { BankAPI, AuthAPI, SwapAPI } from \"../api\";\nimport { CONFIG_CHAIN_SOPHON } from \"../constants\";\n\nexport class APIClient {\n  public apiRequester: APIRequester;\n\n  // API access\n  public bankAPI: BankAPI;\n  public authAPI: AuthAPI;\n  public swapAPI: SwapAPI;\n  public txAPI: TxAPI;\n  public nodeUrl: string;\n\n  constructor(URL: string, chainId: string = CONFIG_CHAIN_SOPHON.CHAIN_ID) {\n    this.nodeUrl = URL;\n    this.apiRequester = new APIRequester(URL);\n\n    // instantiate APIs\n    this.bankAPI = new BankAPI(this.apiRequester);\n    this.authAPI = new AuthAPI(this.apiRequester);\n    this.swapAPI = new SwapAPI(this.apiRequester);\n    this.txAPI = new TxAPI(this.apiRequester);\n  }\n}\n","export const ONE_DAY_TO_SECONDS = 86400;\n\nexport const ONE_YEAR_TO_DAYS = 365;\n","import { Transaction_Status } from \"../types\";\n\nexport class TransactionLooper {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n  counter: number;\n  onTransactionSuccess: Function | undefined;\n\n  constructor(\n    txHash: string,\n    description: string,\n    status: Transaction_Status,\n    onTransactionSuccess?: Function\n  ) {\n    this.transactionHash = txHash;\n    this.description = description;\n    this.status = status;\n    this.counter = 0;\n    this.onTransactionSuccess = onTransactionSuccess;\n  }\n}\n","export const ZERO = \"0\";\n","export function objectToMap<K, T>(source: Object) {\n  return new Map(Object.entries(source));\n}\n\nexport function arrayToMap<T, K extends keyof T>(array: Array<T>, property: K) {\n  const map = new Map<T[K], T>();\n  for (const item of array) {\n    map.set(item[property], item);\n  }\n  return map;\n}\n","import Decimal from \"decimal.js\";\n\nexport const decimalNumber = (number = \" \") => {\n  const [int = \"\", float = \"\"] = number.toString().replace(\"$\", \"\").split(\".\");\n\n  if (int.length > 10) {\n    return `${new Decimal(int).div(new Decimal(10).pow(10)).toFixed(2)}B`;\n  } else if (int.length > 7) {\n    return `${new Decimal(int).div(new Decimal(10).pow(7)).toFixed(2)}M`;\n  } else if (int.length > 3) {\n    return `${new Decimal(int).div(new Decimal(10).pow(3)).toFixed(2)}K`;\n  } else {\n    return `${Number(int) > 0 ? int : 0}.${\n      float.length > 0 ? float.slice(0, 2) : \"00\"\n    }`;\n  }\n};\n","export function deepCopy(source: Object) {\n  // if (typeof source != \"object\") {\n  //   return source;\n  // }\n  // if (source == null) {\n  //   return source;\n  // }\n  // const newObj = source.constructor === Array ? [] as Array<T> : {};\n  // for (const i in source) {\n  //   newObj[i] = deepCopy(source[i]);\n  // }\n  // return newObj;\n\n  return JSON.parse(JSON.stringify(source));\n}\n","import Decimal from \"decimal.js\";\nimport { DEFAULT_PRECISION } from \"../constants\";\n\nexport function plus(value1: string, value2: string) {\n  return new Decimal(value1).plus(value2).toString();\n}\n\nexport function minus(value1: string | number, value2: string | number) {\n  return new Decimal(value1).minus(value2).toString();\n}\n\nexport function multipliedBy(value1: string | number, value2: string | number) {\n  return new Decimal(value1).mul(value2).toString();\n}\n\nexport function div(value1: string, value2: string): string {\n  return new Decimal(value1).div(value2).toString();\n}\n\nexport function isGreaterThan(value1: string, value2: string) {\n  return new Decimal(value1).greaterThanOrEqualTo(value2);\n}\n\nexport function isLessThan(value1: string, value2: string) {\n  return new Decimal(value1).lessThan(value2);\n}\n\nexport function isEqualTo(value1: string, value2: string) {\n  return new Decimal(value1).equals(value2);\n}\n\nexport function pow18(value: string): string {\n  return new Decimal(value).mul(Math.pow(10, DEFAULT_PRECISION)).toString();\n}\n\nexport function pow(\n  value: string | number | Decimal,\n  precision: number = DEFAULT_PRECISION,\n  round: Decimal.Rounding = Decimal.ROUND_DOWN\n): string {\n  if (value === \"\") {\n    return \"0\";\n  }\n  const _value = new Decimal(value).mul(Math.pow(10, precision));\n  if (round === Decimal.ROUND_UP) {\n    return _value.ceil().toString();\n  }\n  return _value.floor().toString();\n}\n\nexport function powM18(value: string | number) {\n  return new Decimal(value).div(Math.pow(10, DEFAULT_PRECISION)).toString();\n}\n\nexport function shift(value: string, precision: number = DEFAULT_PRECISION) {\n  return new Decimal(value).div(Math.pow(10, precision)).toString();\n}\n\nexport function isPositive(value: string | number) {\n  if (!value) {\n    return false;\n  }\n  return new Decimal(value).greaterThan(0);\n}\n","export function encrypt(value: string, prefix = 6, suffix = 4) {\n  if (value) {\n    return value.substr(0, prefix) + \"...\" + value.substr(-suffix);\n  } else {\n    return value;\n  }\n}\n","import { IToken } from \"../types\";\nimport DEFAULT_TOKEN_LIST from \"../constants/tokenlist.default\";\n\nexport function findTokenByDenom(tokenDenom?: string): IToken {\n  const tokens: Array<IToken> = DEFAULT_TOKEN_LIST;\n  const result = tokens.find((item) => item.denom === tokenDenom);\n  if (result) {\n    return result;\n  } else {\n    return DEFAULT_TOKEN_LIST[0];\n  }\n}\n\nexport function findTokenBySymbol(symbol: string): IToken {\n  const tokens: Array<IToken> = DEFAULT_TOKEN_LIST;\n  const result = tokens.find(\n    (item) => item.symbol.toUpperCase() === symbol.toUpperCase()\n  );\n  if (result) {\n    return result;\n  } else {\n    return DEFAULT_TOKEN_LIST[0];\n  }\n}\n","import { Fee_Amount, FEE_AMOUNT_DETAIL } from \"../constants\";\n\nexport function getPercentByFeeAmount(fee: Fee_Amount | undefined) {\n  if (fee) {\n    return `${FEE_AMOUNT_DETAIL[fee].label}%`;\n  } else {\n    return \"-\";\n  }\n}\n","import { Fee_Amount } from \"../constants\";\nimport { Bech32, toUtf8 } from \"@cosmjs/encoding\";\nimport { sha256 } from \"@cosmjs/crypto\";\n\nexport function getPoolAddress(\n  denom0: string,\n  denom1: string,\n  fee: Fee_Amount\n) {\n  let key;\n  if (denom0 > denom1) {\n    key = `${denom1}-${denom0}-${fee}`;\n  } else {\n    key = `${denom0}-${denom1}-${fee}`;\n  }\n  // console.log('poolAddress: ' + Bech32.encode('sop', sha256(toUtf8(key)).slice(0, 20)));\n  return Bech32.encode(\"sop\", sha256(toUtf8(key)).slice(0, 20));\n}\n","import { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { Transaction_Status } from \"./ICommon\";\n\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>;\n    }\n  : T;\n\nexport type BroadcastResult = DeliverTxResponse;\n\nexport interface ITransaction {\n  transactionHash: string;\n  description: string;\n  status: Transaction_Status;\n}\n\nexport function longToNumber(long: Long): number {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\n","import Decimal from \"decimal.js\";\nimport { isNumeric } from \"./isNumberic\";\n\n// export function toPercent(percent: number, balance: string) {\n//   return new Decimal(percent).div(100).mul(balance).toFixed(2);\n// }\n\nexport function percentage(value: string): string {\n  if (isNumeric(value)) {\n    return `${new Decimal(value).toFixed(2)}%`;\n  } else {\n    return value;\n  }\n}\n\nexport function toPercent(value: Decimal.Value): string {\n  try {\n    return `${new Decimal(value).mul(100).toFixed(2)}%`;\n  } catch (e) {\n    return value.toString();\n  }\n}\n","export function to32(value: string) {\n  const arr = value.split(\",\");\n  const len = 32 - arr.length;\n  const result: Array<number> = [];\n  arr.forEach((item) => {\n    result.push(+item);\n  });\n  for (let i = 0; i < len; i++) {\n    result.unshift(0);\n  }\n  return result;\n}\n","import Decimal from \"decimal.js\";\n\nexport function toUsd(value: string | undefined): string | number {\n  if (!value) {\n    return 0;\n  }\n  return \"$\" + new Decimal(value).toFixed(2);\n}\n"],"names":["Fee_Amount","APIRequester","baseURL","axios","this","Axios","create","headers","Accept","timeout","_proto","get","endpoint","params","then","d","data","post","BaseAPI","request","BankAPI","_inheritsLoose","apiTokenBalance","token","accountAddress","denom","apiAccountBalance","AuthAPI","apiAccountInfo","SwapAPI","apiPoolListByAddresses","addresses","join","apiPoolMetadataByAddress","address","apiPoolMetadataPriceByAddress","apiLiquidityPositionById","tokenId","apiLiquidityRewardsByIds","tokenIds","apiTickImagePath","apiActiveFarmList","apiLiquidityPositionList","TxAPI","txInfo","txHash","_broadcast","tx","mode","broadcast","creator","name","symbol","totalSupply","decimal","logoURI","Bound","Tip_Level","Swap_Direction","Transaction_Status","FEE_AMOUNT_DETAIL","LOW","label","value","description","MEDIUM","HIGH","NETWORK_MAP","networkId","chainId","chainName","providerType","ticker","CONFIG_CHAIN_SOPHON","RPC_URL","REST_URL","EXPLORER_URL","NETWORK_NAME","NETWORK_TYPE","CHAIN_ID","CHAIN_NAME","COIN_DENOM","COIN_MINIMAL_DENOM","COIN_DECIMALS","PREFIX","COIN_TYPE","COINGECKO_ID","DEFAULT_GAS","GAS_PRICE_STEP_LOW","GAS_PRICE_STEP_AVERAGE","GAS_PRICE_STEP_HIGH","FEATURES","REG_NUMBER","RegExp","REG_DECIMAL","TICK_SPACINGS","500","3000","10000","toDecimalPlaces","precision","Decimal","ROUND_UP","toString","e","String","toAmountString","roundingMode","ROUND_DOWN","toSignificantDigits","isNumeric","isNaN","parseFloat","sortsBefore","baseToken","quoteToken","toLowerCase","moment","locale","LiquidityMath","getRightSideLiquidity","leftRangeValue","rightRangeValue","priceValue","amount","numerator","_value1","div","sqrt","_value2","denominator","sub","getLeftSideLiquidity","getLiquidityFromAmount0","amount0","pc","lessThan","greaterThan","deltaX","_getDiverForDeltaX","lower","upper","_getDiverForDeltaY","getLiquidityFromAmount1","amount1","deltaY","getAmount1FromAmount0","token0","liquidity","console","log","mul","getAmount0FromAmount1","token1","getAmountByLiquidity","deltaXDiver","deltaYDiver","TickMath","priceToClosestTick","price","log2","toNumber","getNearestTickByPrice","feeAmount","trim","INVALID_TICK","MIN_TICK_VALUE","MIN_TICK","MAX_TICK_VALUE","MAX_TICK","tick","nearestUsableTick","getFormattedPriceByTick","fee","isLowestTick","isHighestTick","base","pow","getPriceByTick","getNearestPriceByInput","nearestTick","getPriceBySqrtPrice","sqrtPrice","getSqrtPriceByPrice","getBaseTickRange","fromToken","toToken","leftRange","rightRange","tickLower","tickUpper","getNearestLowestTick","getNearestHighestTick","getNearestPricesByFullTick","lowestPrice","highestPrice","tickSpacing","rounded","Math","round","BaseMsg","Timestamp","message","writer","_m0","seconds","isZero","uint32","int64","nanos","int32","input","length","reader","end","undefined","len","pos","Long","ZERO","tag","skipType","isSet","MsgCollectReward","MsgSwapExactOut","MsgSwapExactIn","MsgCreatePool","MsgCollect","MsgCreatePosition","MsgDecreaseLiquidity","MsgIncreaseLiquidity","protobufPackage","encode","string","denom0","denom1","decode","fromJSON","object","Number","toJSON","obj","fromPartial","amount0Desired","amount1Desired","amount0Min","amount1Min","recipient","deadline","toTimestamp","fork","ldelim","fromTimestamp","fromJsonTimestamp","toISOString","amount0Max","amount1Max","collectOnly","bool","Boolean","amountIn","amountOutMin","denoms","v","fees","push","end2","Array","isArray","map","amountOut","amountInMax","date","number","getTime","fromNumber","t","millis","Date","o","fromValue","createBaseAny","typeUrl","Uint8Array","msg","_this","protoMsg","generateMessage","MsgCollectReward_pb","_this2","MsgSwapExactOut_pb","_this3","MsgSwapExactIn_pb","_this4","MsgCreatePool_pb","_this5","MsgCollect_pb","_this6","MsgCreatePosition_pb","_this7","MsgDecreaseLiquidity_pb","_this8","MsgIncreaseLiquidity_pb","Any","bytes","bytesFromBase64","globalThis","self","window","global","atob","b64","Buffer","from","bin","arr","i","charCodeAt","btoa","createBaseCompactBitArray","extraBitsStored","elems","CompactBitArray","SignMode","signModeFromJSON","SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_LEGACY_AMINO_JSON","UNRECOGNIZED","Coin","TxRaw","bodyBytes","authInfoBytes","signatures","AuthInfo","signerInfos","SignerInfo","Fee","createBaseSignerInfo","publicKey","modeInfo","sequence","UZERO","ModeInfo","uint64","forEach","byte","fromCharCode","single","ModeInfo_Single","multi","ModeInfo_Multi","signModeToJSON","bitarray","modeInfos","createBaseFee","gasLimit","payer","granter","SIGN_DIRECT","defaultFee","gas","TxClient","apiClient","rpcUrl","signer","registry","invariant","registryTypes","Map","set","Proto","Registry","getSender","authAPI","_context","account_number","_yield$authAPI$apiAcc2","account","base_account","getAccounts","pubkey","accountNumber","parseInt","sendTransaction","messages","memo","_context2","sender","key","PubKey","finish","signerInfo","signInfoDirect","feeMessage","authInfoDirect","createAuthInfo","body","createTxBodyEncodeObject","signDocDirect","createSigDoc","SigningStargateClient","connectWithSigner","prefix","walletClient","signDirect","txRaw","signed","_yield$walletClient$s","fromBase64","signature","txBytes","broadcastTx","item","URL","apiRequester","bankAPI","swapAPI","txAPI","nodeUrl","status","onTransactionSuccess","transactionHash","counter","array","property","test","replace","split","int","float","toFixed","slice","source","JSON","parse","stringify","value1","value2","suffix","substr","tokenDenom","DEFAULT_TOKEN_LIST","find","toUpperCase","time","fromNow","pattern","format","seperator","fixed","Bech32","sha256","toUtf8","floor","equals","greaterThanOrEqualTo","long","gt","MAX_SAFE_INTEGER","Error","minus","Object","entries","plus","_value","ceil","result","unshift","CosmosDecimal","fromUserInput"],"mappings":"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"}